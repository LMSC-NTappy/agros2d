<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<module:module xmlns:module="XMLModule" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="XMLModule ../xsd/module_xml.xsd">

  <module:general id="richards" name="Richard's equation">
    <module:description>The Richards equation represents the movement of water in unsaturated soils.</module:description>
    <module:analyses>
      <module:analysis id="steadystate" name="Steady state" solutions="1" type="steadystate">
        <module:field_config>
          <field_item field_key="NewtonDampingCoeff" field_value="0.8"/>
          <field_item field_key="NewtonAutomaticDampingCoeff" field_value="0.8"/>
        </module:field_config>
      </module:analysis>
      <module:analysis id="transient" name="Transient" solutions="1" type="transient"/>
    </module:analyses>
  </module:general>

  <module:constants/>

  <module:spaces>
    <module:space analysistype="steadystate">
      <module:space_config i="1" orderadjust="0" type="h1"/>
    </module:space>
    <module:space analysistype="transient">
      <module:space_config i="1" orderadjust="0" type="h1"/>
    </module:space>
  </module:spaces>

  <module:volume>
    <module:quantity id="richards_ks" shortname="re_ks"/>
    <module:quantity id="richards_a" shortname="re_a"/>
    <module:quantity id="richards_m" shortname="re_m"/>
    <module:quantity id="richards_n" shortname="re_n"/>
    <module:quantity id="richards_storativity" shortname="re_st"/>
    <module:quantity id="richards_theta_s" shortname="re_theta_s"/>
    <module:quantity id="richards_theta_r" shortname="re_theta_r"/>

    <module:function id="richards_func_k" shortname="re_func_k" switch="constitutive_variant">
      <!-- mela by mit kazda funkce vyjmenovane parametry? tedy neco jako seznam
      <module:quantity id="richards_ks"/>
      <module:quantity id="richards_a"/>
      <module:quantity id="richards_m"/>
      <module:quantity id="richards_n"/>
      nebo se proste vezmou vsechny quantity v poradi, jak jsou vyjmenovany pro modul?
      -->
      <module:function_variant switch_value="van_genuchten" bound_low="-40" bound_hi="0" extrapolate_hi="re_ks"  expr="re_ks*std::pow((1 + std::pow((-re_a*h),n)),(-m/2))*std::pow((1 -std::pow((-re_a*h),(m*n))*std::pow((1 + std::pow((-re_a*h),n)),(-m))),2)"/>
    </module:function>
    <module:function id="richards_func_dkdh" shortname="re_func_dkdh" switch="constitutive_variant">
      <module:function_variant switch_value="van_genuchten" bound_low="-40" bound_hi="0" extrapolate_hi="0"  expr="re_ks*std::pow((1 + std::pow((-re_a*h),n)),(-m/2))*(1 -std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m)))*(-2*m*n*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/h +2*m*n*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(h*(1 + std::pow((-re_a*h),n)))) -re_ks*m*n*std::pow((-re_a*h),n)*std::pow((1 + std::pow((-re_a*h),n)),(-m/2))*std::pow((1 -std::pow((-re_a*h),(m*n))*std::pow((1 + std::pow((-re_a*h),n)),(-m))),2)/(2*h*(1 +std::pow((-re_a*h),n)))"/>
    </module:function>
    <module:function id="richards_func_ddkdhh" shortname="re_func_ddkddh" switch="constitutive_variant">
      <module:function_variant switch_value="van_genuchten" bound_low="-40" bound_hi="0" extrapolate_hi="0"  expr="re_ks*std::pow((1 + std::pow((-re_a*h),n)),(-m/2))*(1 -std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m)))*(-2*std::pow(m,2)*std::pow(n,2)*std::pow((-re_a*h),(m*n))*std::pow((1+ std::pow((-re_a*h),n)),(-m))/std::pow(h,2) +2*m*n*std::pow((-re_a*h),(m*n))*std::pow((1 + std::pow((-re_a*h),n)),(-m))/std::pow(h,2)- 2*m*n*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(std::pow(h,2)*(1 + std::pow((-re_a*h),n))) -2*m*std::pow(n,2)*std::pow((-re_a*h),(2*n))*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(std::pow(h,2)*std::pow((1 + std::pow((-re_a*h),n)),2)) -2*std::pow(m,2)*std::pow(n,2)*std::pow((-re_a*h),(2*n))*std::pow((-re_a*h),(m*n))*std::pow((1+ std::pow((-re_a*h),n)),(-m))/(std::pow(h,2)*std::pow((1 + std::pow((-re_a*h),n)),2)) +2*m*std::pow(n,2)*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(std::pow(h,2)*(1 + std::pow((-re_a*h),n))) +4*std::pow(m,2)*std::pow(n,2)*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(std::pow(h,2)*(1 + std::pow((-re_a*h),n)))) +re_ks*std::pow((1 + std::pow((-re_a*h),n)),(-m/2))*(-m*n*std::pow((-re_a*h),(m*n))*std::pow((1+ std::pow((-re_a*h),n)),(-m))/h +m*n*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(h*(1 +std::pow((-re_a*h),n))))*(-2*m*n*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/h +2*m*n*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(h*(1 + std::pow((-re_a*h),n)))) -re_ks*m*n*std::pow((-re_a*h),n)*std::pow((1 + std::pow((-re_a*h),n)),(-m/2))*(1 -std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m)))*(-2*m*n*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/h +2*m*n*std::pow((-re_a*h),n)*std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))/(h*(1 + std::pow((-re_a*h),n))))/(h*(1 +std::pow((-re_a*h),n))) + re_ks*m*n*std::pow((-re_a*h),n)*std::pow((1 +std::pow((-re_a*h),n)),(-m/2))*std::pow((1 - std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))),2)/(2*std::pow(h,2)*(1 + std::pow((-re_a*h),n))) +re_ks*m*std::pow(n,2)*std::pow((-re_a*h),(2*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m/2))*std::pow((1 - std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))),2)/(2*std::pow(h,2)*std::pow((1 +std::pow((-re_a*h),n)),2)) - re_ks*m*std::pow(n,2)*std::pow((-re_a*h),n)*std::pow((1 +std::pow((-re_a*h),n)),(-m/2))*std::pow((1 - std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))),2)/(2*std::pow(h,2)*(1 + std::pow((-re_a*h),n))) +re_ks*std::pow(m,2)*std::pow(n,2)*std::pow((-re_a*h),(2*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m/2))*std::pow((1 - std::pow((-re_a*h),(m*n))*std::pow((1 +std::pow((-re_a*h),n)),(-m))),2)/(4*std::pow(h,2)*std::pow((1 +std::pow((-re_a*h),n)),2))"/>
    </module:function>
    <module:function id="richards_func_c" shortname="re_func_c" switch="constitutive_variant">
      <module:function_variant switch_value="van_genuchten" bound_low="-40" bound_hi="0" extrapolate_hi="st"  expr="st*std::pow((1 + std::pow((-re_a*h),n)),(-m))*(theta_s - theta_r)/theta_s - m*n*std::pow((-re_a*h),n)*std::pow((1 + std::pow((-re_a*h),n)),(-m))*(theta_s - theta_r)/(h*(1 + std::pow((-re_a*h),n)))"/>
    </module:function>

    <module:matrix_form id="conductivity" i="1" j="1" planar="re_function_k(value1, re_ks, re_a, re_m, re_n) * (udx * vdx + udy * vdy)"
                                                      axi="re_function_k(value1, re_ks, re_a, re_m, re_n) * r * (udr * vdr + udz * vdz)"/>
    <module:matrix_form id="conductivity_derivative" i="1" j="1" planar="- re_function_dkdh(value1, re_ks, re_a, re_m, re_n) * udy * vval"
                                                                 axi="- re_function_dkdh(value1, re_ks, re_a, re_m, re_n) * udz * vval"/>
    <module:matrix_form id="conductivity_jacobian" i="1" j="1" planar="re_function_dkdh(value1, re_ks, re_a, re_m, re_n) * uval * (updx * vdx + updy * vdy)"
                                                               axi="re_function_dkdh(value1, re_ks, re_a, re_m, re_n) * r * uval * (updr * vdr + updz * vdz)"/>
    <module:matrix_form id="conductivity_derivative_jacobian" i="1" j="1" planar="- re_function_ddkdhh(value1, re_ks, re_a, re_m, re_n) * uval * updy * vval"
                                                                          axi="- re_function_ddkdhh(value1, re_ks, re_a, re_m, re_n) * r * uval * updz * vval"/>
    <module:matrix_form id="time_mat" i="1" j="1" planar="re_function_c(value1, re_ks, re_a, re_m, re_n, re_st, re_theta_s, re_theta_r) * uval * vval * timedermat"
                                                  axi="re_function_c(value1, re_ks, re_a, re_m, re_n, re_st, re_theta_s, re_theta_r) * r * uval * vval * timedermat" />
    <module:vector_form id="time_vec" i="1" j="1" planar="re_function_c(value1, re_ks, re_a, re_m, re_n, re_st, re_theta_s, re_theta_r) * timedervec * vval"
                                                  axi="re_function_c(value1, re_ks, re_a, re_m, re_n, re_st, re_theta_s, re_theta_r) * r * timedervec * vval"/>
    
    <module:weakforms_volume>
      <module:weakform_volume analysistype="steadystate" equation="-\, \div \left( \lambda\,\, \grad T \right) + k c_\mathrm{p} \left(\vec{v} \cdot \grad T\right) = Q">
        <module:quantity id="richards_ks"/>
        <module:quantity id="richards_a"/>
        <module:quantity id="richards_m"/>
        <module:quantity id="richards_n"/>
        <module:quantity id="richards_storativity"/>
        <module:quantity id="richards_theta_s"/>
        <module:quantity id="richards_theta_r"/>

        <module:linearity_option type="linear">
          <module:matrix_form id="conductivity" />
          <module:matrix_form id="conductivity_derivative" />
        </module:linearity_option>

        <module:linearity_option type="newton">
          <module:matrix_form id="conductivity" />
          <module:matrix_form id="conductivity_derivative" />
          <module:matrix_form id="conductivity_jacobian" />
          <module:matrix_form id="conductivity_derivative_jacobian" />
          <module:vector_form id="conductivity" variant="residual" />
          <module:vector_form id="conductivity_derivative" variant="residual" />
        </module:linearity_option>

      </module:weakform_volume>
      <module:weakform_volume analysistype="transient" equation="-\, \div \left( \lambda\,\, \grad T \right) + k c_\mathrm{p} \left(\frac{\partial T}{\partial t} + \vec{v} \cdot \grad T\right) = Q">
        <module:quantity id="richards_ks"/>
        <module:quantity id="richards_a"/>
        <module:quantity id="richards_m"/>
        <module:quantity id="richards_n"/>
        <module:quantity id="richards_storativity"/>
        <module:quantity id="richards_theta_s"/>
        <module:quantity id="richards_theta_r"/>

        <module:linearity_option type="linear">
          <module:matrix_form id="conductivity" />
          <module:matrix_form id="conductivity_derivative" />
      <module:matrix_form id="time_mat" />
	  <module:vector_form id="time_vec" />
        </module:linearity_option>

        <module:linearity_option type="newton">
          <module:matrix_form id="conductivity" />
          <module:matrix_form id="conductivity_derivative" />
          <module:matrix_form id="conductivity_jacobian" />
          <module:matrix_form id="conductivity_derivative_jacobian" />
          <module:matrix_form id="time_mat" />
          <module:vector_form id="conductivity" variant="residual" />
          <module:vector_form id="conductivity_derivative" variant="residual" />
	  <module:vector_form id="time_mat" variant="residual"/>
	  <module:vector_form id="time_vec" coefficient="-1"/>
        </module:linearity_option>

        <module:linearity_option type="picard">
        <module:matrix_form id="conductivity" />
        <module:matrix_form id="conductivity_derivative" />
    <module:matrix_form id="time_mat" />
    <module:vector_form id="time_vec" />
        </module:linearity_option>

      </module:weakform_volume>
    </module:weakforms_volume>
  </module:volume>

  <module:surface>
    <module:quantity id="richards_pressure_head" shortname="re_h"/>
    <module:quantity id="richards_darcy_velocity" shortname="re_q"/>
    <module:weakforms_surface>
      <module:weakform_surface analysistype="steadystate" default="richards_pressure_head">
        <module:boundary equation="h = h_0" id="richards_pressure_head" name="Pressure head">
          <module:quantity dependence="space" id="richards_pressure_head"/>
          <module:essential_form axi_linear="re_h" axi_newton="re_h" i="1" id="form" planar_linear="re_h" planar_newton="re_h"/>
        </module:boundary>
        <module:boundary equation="f = - \lambda \frac{\partial T}{\partial n_0} = f_0 + \alpha \left ( T_\mathrm{ext} - T \right) + \epsilon \sigma \left ( T_\mathrm{amb}^4 - T^4 \right)" id="richards_darcy_velocity" name="Darcy velocity">
          <module:quantity id="richards_darcy_velocity"/>
          <module:vector_form axi_linear="r * re_q * vval" axi_newton="r * (- re_q) * vval" i="1" id="form" j="1" planar_linear="re_q * vval" planar_newton="- re_q * vval"/>
        </module:boundary>
      </module:weakform_surface>
      <module:weakform_surface analysistype="transient" default="richards_pressure_head">
        <module:boundary equation="T = T_0" id="richards_pressure_head" name="Pressure head">
          <module:quantity dependence="space" id="richards_pressure_head"/>
          <module:essential_form axi_linear="re_h" axi_newton="re_h" i="1" id="form" planar_linear="re_h" planar_newton="re_h"/>
        </module:boundary>
        <module:boundary equation="f = - \lambda \frac{\partial T}{\partial n_0} = f_0 + \alpha \left ( T_\mathrm{ext} - T \right) + \epsilon \sigma \left ( T_\mathrm{amb}^4 - T^4 \right)" id="richards_darcy_velocity" name="Heat flux">
          <module:quantity id="richards_darcy_velocity"/>
          <module:vector_form axi_linear="r * re_q * vval" axi_newton="r * (- re_q) * vval" i="1" id="form" j="1" planar_linear="re_q * vval" planar_newton="- re_q * vval"/>
        </module:boundary>
      </module:weakform_surface>
    </module:weakforms_surface>
  </module:surface>

  <module:preprocessor>
    <module:gui type="volume">
      <module:group>        
        <module:quantity condition="value >= 0" default="0" id="richards_ks" name="richards_ks" shortname="ks" shortname_html="&lt;i>k&lt;/i>&lt;sub>s&lt;/sub>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>
        <module:quantity condition="value >= 0" default="0" id="richards_a" name="richards_a" shortname="a" shortname_html="&lt;i>a&lt;/i>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>
        <module:quantity condition="value >= 0" default="0" id="richards_m" name="richards_m" shortname="m" shortname_html="&lt;i>m&lt;/i>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>
        <module:quantity condition="value >= 0" default="0" id="richards_n" name="richards_n" shortname="n" shortname_html="&lt;i>n&lt;/i>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>
        <module:quantity condition="value >= 0" default="0" id="richards_storativity" name="richards_storativity" shortname="st" shortname_html="&lt;i>st&lt;/i>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>
        <module:quantity condition="value >= 0" default="0" id="richards_theta_s" name="richards_theta_s" shortname="ts" shortname_html="&lt;i>&amp;theta;&lt;/i>&lt;/i>&lt;sub>s&lt;/sub>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>
        <module:quantity condition="value >= 0" default="0" id="richards_theta_r" name="richards_theta_r" shortname="tr" shortname_html="&lt;i>&amp;theta;&lt;/i>&lt;/i>&lt;sub>r&lt;/sub>" shortname_latex="L/t" unit="L/t" unit_html="Lt&lt;sup>-1&lt;/sup>" unit_latex="L\cdott^{-1}"/>

        <module:switch id="constitutive_variant" name="Constitutive relations">
          <module:switch_option id="van_genuchten" name="van Genuchten" />
        </module:switch>
      </module:group>
    </module:gui>
    <module:gui type="surface">
      <module:group>
        <module:quantity condition="" default="0" id="richards_pressure_head" name="Pressure head" shortname="h" shortname_html="&lt;i>ph&lt;/i>" shortname_latex="h" unit="m" unit_html="m" unit_latex="m"/>
        <module:quantity condition="" default="0" id="richards_darcy_velocity" name="Darcy velocity" shortname="q" shortname_html="&lt;i>f&lt;/i>" shortname_latex="" unit="?" unit_html="?" unit_latex="?"/>
      </module:group>
    </module:gui>
  </module:preprocessor>

  <module:postprocessor>
    <module:localvariables>
      <module:localvariable id="richards_pressure_head" name="Pressure head" shortname="h" shortname_html="&lt;i>ph&lt;/i>" shortname_latex="h" type="scalar" unit="L" unit_html="L" unit_latex="L">
        <module:expression analysistype="steadystate" axi="value1" planar="value1"/>
        <module:expression analysistype="transient" axi="value1" planar="value1"/>
      </module:localvariable>
      <module:localvariable format="%5.3e" id="richards_pressure_darcy_velocity" name="Darcy velocity" shortname="q" shortname_html="&lt;i>q&lt;/i>" shortname_latex="q" type="vector" unit="L/T" unit_html="L.T&lt;sup>-1&lt;/sup>" unit_latex="T \cdot T^{-1}">
        <module:expression analysistype="steadystate" axi_r="- tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dr1" axi_z="- tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dz1" planar_x="- tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dx1" planar_y="- tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dy1"/>
        <module:expression analysistype="transient" axi_r="tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dr1" axi_z="tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dz1" planar_x="tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dx1" planar_y="tern(value1 > 0, re_ks, re_ks*pow((1 + pow((-re_a*value1), re_n)),(-re_m/2))*pow((1 - pow((-re_a*value1), (re_m*re_n))*pow((1 + pow((-re_a*value1), re_n)), (-re_m))), 2)) * dy1"/>
      </module:localvariable>
      <!--
      <module:localvariable id="richards_pressure_gradient" name="Pressure gradient" shortname="G" shortname_html="&lt;i>G&lt;/i>" shortname_latex="G" type="vector" unit="-" unit_html="-" unit_latex="-">
        <module:expression analysistype="steadystate" axi_r="dr1" axi_z="dz1" planar_x="dx1" planar_y="dy1"/>
        <module:expression analysistype="transient" axi_r="dr1" axi_z="dz1" planar_x="dx1" planar_y="dy1"/>
      </module:localvariable>
      -->
    </module:localvariables>
    <module:view>
      <module:scalar_view>
        <module:default analysistype="steadystate" id="richards_pressure_head"/>
        <module:default analysistype="transient" id="richards_pressure_head"/>
      </module:scalar_view>
      <module:vector_view>
        <module:default analysistype="steadystate" id="richards_pressure_darcy_velocity"/>
        <module:default analysistype="transient" id="richards_pressure_darcy_velocity"/>
      </module:vector_view>
    </module:view>
    <module:volumeintegrals>
      <module:volumeintegral id="richards_volume" name="Volume" shortname="V" shortname_html="&lt;i>V&lt;/i>" shortname_latex="V" unit="m3" unit_html="m&lt;sup>3&lt;/sup>" unit_latex="m^{3}">
        <module:expression analysistype="steadystate" axi="2.0 * PI * r" planar="1.0"/>
        <module:expression analysistype="transient" axi="2.0 * PI * r" planar="1.0"/>
      </module:volumeintegral>
      <module:volumeintegral id="richards_cross_section" name="Cross section" shortname="S" shortname_html="&lt;i>S&lt;/i>" shortname_latex="S" unit="m2" unit_html="m&lt;sup>2&lt;/sup>" unit_latex="m^{2}">
        <module:expression analysistype="steadystate" axi="1.0" planar="1.0"/>
        <module:expression analysistype="transient" axi="1.0" planar="1.0"/>
      </module:volumeintegral>
    </module:volumeintegrals>
    <module:surfaceintegrals>
      <module:surfaceintegral id="richards_length" name="Length" shortname="l" shortname_html="&lt;i>l&lt;/i>" shortname_latex="l" unit="m" unit_html="m" unit_latex="m">
        <module:expression analysistype="steadystate" axi="1.0" planar="1.0"/>
        <module:expression analysistype="transient" axi="1.0" planar="1.0"/>
      </module:surfaceintegral>
      <module:surfaceintegral id="richards_surface" name="Surface" shortname="S" shortname_html="&lt;i>S&lt;/i>" shortname_latex="S" unit="m2" unit_html="m&lt;sup>2&lt;/sup>" unit_latex="m^{2}">
        <module:expression analysistype="steadystate" axi="2.0 * PI * r" planar="1.0"/>
        <module:expression analysistype="transient" axi="2.0 * PI * r" planar="1.0"/>
      </module:surfaceintegral>
    </module:surfaceintegrals>
    <module:force/>
  </module:postprocessor>

  <module:cpp>
  #define count 500

  // K (van Genuchten)
  static double re_function_k(double value, double k_s, double alpha, double m, double n)
  {
      if (value > 0)
      {
          return k_s;
      }
      else
      {
          // static Hermes::Hermes2D::CubicSpline *piece = NULL;
          static PiecewiseLinear *piece = NULL;
          if (!piece)
          {
              Hermes::vector&lt;double> points;
              Hermes::vector&lt;double> values;

              double from = - 500.0;
              double to = 0.0;

              double step = (to - from) / (count - 1);
              for (int i = 0; i &lt; count; i++)
              {
                  double h = from + i * step;
                  points.push_back(h);
                  values.push_back(k_s*std::pow((1 + std::pow((-alpha*h),n)),(-m/2))*std::pow((1 -std::pow((-alpha*h),(m*n))*std::pow((1 + std::pow((-alpha*h),n)),(-m))),2));
              }

              // piece = new Hermes::Hermes2D::CubicSpline(points, values, 0.0, 0.0, true, true, false, false);
              piece = new PiecewiseLinear(points, values);
          }

          return piece->value(value);
      }
  }

  static Hermes::Ord re_function_k(Hermes::Ord value, double k_s, double alpha, double m, double n)
  {
      return Hermes::Ord(10);
  }

  // dK/dh (van Genuchten)
  static double re_function_dkdh(double value, double k_s, double alpha, double m, double n)
  {
      if (value > 0)
      {
          return 0;
      }
      else
      {
          // static Hermes::Hermes2D::CubicSpline *piece = NULL;
          static PiecewiseLinear *piece = NULL;
          if (!piece)
          {
              Hermes::vector&lt;double> points;
              Hermes::vector&lt;double> values;

              double from = - 500.0;
              double to = 0.0;

              double step = (to - from) / (count - 1);
              for (int i = 0; i &lt; count; i++)
              {
                  double h = from + i * step;
                  points.push_back(h);
                  values.push_back(k_s*std::pow((1 + std::pow((-alpha*h),n)),(-m/2))*(1 -std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m)))*(-2*m*n*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/h +2*m*n*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(h*(1 + std::pow((-alpha*h),n)))) -k_s*m*n*std::pow((-alpha*h),n)*std::pow((1 + std::pow((-alpha*h),n)),(-m/2))*std::pow((1 -std::pow((-alpha*h),(m*n))*std::pow((1 + std::pow((-alpha*h),n)),(-m))),2)/(2*h*(1 +std::pow((-alpha*h),n))));
              }

              // piece = new Hermes::Hermes2D::CubicSpline(points, values, 0.0, 0.0, true, true, false, false);
              piece = new PiecewiseLinear(points, values);
          }

          return piece->value(value);
      }
  }

  static Hermes::Ord re_function_dkdh(Hermes::Ord value, double k_s, double alpha, double m, double n)
  {
      return Hermes::Ord(10);
  }

  // ddK/dhh (van Genuchten)
  static double re_function_ddkdhh(double value, double k_s, double alpha, double m, double n)
  {
      if (value > 0)
      {
          return 0.0;
      }
      else
      {
          // static Hermes::Hermes2D::CubicSpline *piece = NULL;
          static PiecewiseLinear *piece = NULL;
          if (!piece)
          {
              Hermes::vector&lt;double> points;
              Hermes::vector&lt;double> values;

              double from = - 500.0;
              double to = 0.0;

              double step = (to - from) / (count - 1);
              for (int i = 0; i &lt; count; i++)
              {
                  double h = from + i * step;
                  points.push_back(h);
                  values.push_back(k_s*std::pow((1 + std::pow((-alpha*h),n)),(-m/2))*(1 -std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m)))*(-2*std::pow(m,2)*std::pow(n,2)*std::pow((-alpha*h),(m*n))*std::pow((1+ std::pow((-alpha*h),n)),(-m))/std::pow(h,2) +2*m*n*std::pow((-alpha*h),(m*n))*std::pow((1 + std::pow((-alpha*h),n)),(-m))/std::pow(h,2)- 2*m*n*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(std::pow(h,2)*(1 + std::pow((-alpha*h),n))) -2*m*std::pow(n,2)*std::pow((-alpha*h),(2*n))*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(std::pow(h,2)*std::pow((1 + std::pow((-alpha*h),n)),2)) -2*std::pow(m,2)*std::pow(n,2)*std::pow((-alpha*h),(2*n))*std::pow((-alpha*h),(m*n))*std::pow((1+ std::pow((-alpha*h),n)),(-m))/(std::pow(h,2)*std::pow((1 + std::pow((-alpha*h),n)),2)) +2*m*std::pow(n,2)*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(std::pow(h,2)*(1 + std::pow((-alpha*h),n))) +4*std::pow(m,2)*std::pow(n,2)*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(std::pow(h,2)*(1 + std::pow((-alpha*h),n)))) +k_s*std::pow((1 + std::pow((-alpha*h),n)),(-m/2))*(-m*n*std::pow((-alpha*h),(m*n))*std::pow((1+ std::pow((-alpha*h),n)),(-m))/h +m*n*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(h*(1 +std::pow((-alpha*h),n))))*(-2*m*n*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/h +2*m*n*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(h*(1 + std::pow((-alpha*h),n)))) -k_s*m*n*std::pow((-alpha*h),n)*std::pow((1 + std::pow((-alpha*h),n)),(-m/2))*(1 -std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m)))*(-2*m*n*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/h +2*m*n*std::pow((-alpha*h),n)*std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))/(h*(1 + std::pow((-alpha*h),n))))/(h*(1 +std::pow((-alpha*h),n))) + k_s*m*n*std::pow((-alpha*h),n)*std::pow((1 +std::pow((-alpha*h),n)),(-m/2))*std::pow((1 - std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))),2)/(2*std::pow(h,2)*(1 + std::pow((-alpha*h),n))) +k_s*m*std::pow(n,2)*std::pow((-alpha*h),(2*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m/2))*std::pow((1 - std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))),2)/(2*std::pow(h,2)*std::pow((1 +std::pow((-alpha*h),n)),2)) - k_s*m*std::pow(n,2)*std::pow((-alpha*h),n)*std::pow((1 +std::pow((-alpha*h),n)),(-m/2))*std::pow((1 - std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))),2)/(2*std::pow(h,2)*(1 + std::pow((-alpha*h),n))) +k_s*std::pow(m,2)*std::pow(n,2)*std::pow((-alpha*h),(2*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m/2))*std::pow((1 - std::pow((-alpha*h),(m*n))*std::pow((1 +std::pow((-alpha*h),n)),(-m))),2)/(4*std::pow(h,2)*std::pow((1 +std::pow((-alpha*h),n)),2)));
              }

              // piece = new Hermes::Hermes2D::CubicSpline(points, values, 0.0, 0.0, true, true, false, false);
              piece = new PiecewiseLinear(points, values);
          }

          return piece->value(value);
      }
  }

  static Hermes::Ord re_function_ddkdhh(Hermes::Ord value, double k_s, double alpha, double m, double n)
  {
      return Hermes::Ord(10);
  }

  // C (van Genuchten)
  static double re_function_c(double value, double k_s, double alpha, double m, double n, double st, double theta_s, double theta_r)
  {
      if (value > 0)
      {
          return st;
      }
      else
      {
          // static Hermes::Hermes2D::CubicSpline *piece = NULL;
          static PiecewiseLinear *piece = NULL;
          if (!piece)
          {
              Hermes::vector&lt;double> points;
              Hermes::vector&lt;double> values;

              double from = - 500.0;
              double to = 0.0;

              double step = (to - from) / (count - 1);
              for (int i = 0; i &lt; count; i++)
              {
                  double h = from + i * step;
                  points.push_back(h);
                  values.push_back(st*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/theta_s - m*n*std::pow((-alpha*h),n)*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/(h*(1 + std::pow((-alpha*h),n))));
              }

              // piece = new Hermes::Hermes2D::CubicSpline(points, values, 0.0, 0.0, true, true, false, false);
              piece = new PiecewiseLinear(points, values);
          }

          return piece->value(value);
      }
  }

  static Hermes::Ord re_function_c(Hermes::Ord value, double k_s, double a, double m, double n, double re_st, double re_theta_s, double re_theta_r)
  {
      return Hermes::Ord(10);
  }

  // dC/dh (van Genuchten)
  // m*n*std::pow((-alpha*h),n)*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/(std::pow(h,2)*(1 + std::pow((-alpha*h),n))) + m*std::pow(n,2)*std::pow((-alpha*h),(2*n))*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/(std::pow(h,2)*std::pow((1 + std::pow((-alpha*h),n)),2)) + std::pow(m,2)*std::pow(n,2)*std::pow((-alpha*h),(2*n))*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/(std::pow(h,2)*std::pow((1 + std::pow((-alpha*h),n)),2)) - m*std::pow(n,2)*std::pow((-alpha*h),n)*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/(std::pow(h,2)*(1 + std::pow((-alpha*h),n))) - m*n*storativity*std::pow((-alpha*h),n)*std::pow((1 + std::pow((-alpha*h),n)),(-m))*(theta_s - theta_r)/(theta_s*h*(1 + std::pow((-alpha*h),n)))
  </module:cpp>

</module:module>
