#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Sat May 12 20:51:54 2012 by generateDS.py version 2.7a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class module(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, general=None, constants=None, volume=None, surface=None, preprocessor=None, postprocessor=None):
        self.general = general
        self.constants = constants
        self.volume = volume
        self.surface = surface
        self.preprocessor = preprocessor
        self.postprocessor = postprocessor
    def factory(*args_, **kwargs_):
        if module.subclass:
            return module.subclass(*args_, **kwargs_)
        else:
            return module(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_general(self): return self.general
    def set_general(self, general): self.general = general
    def get_constants(self): return self.constants
    def set_constants(self, constants): self.constants = constants
    def get_volume(self): return self.volume
    def set_volume(self, volume): self.volume = volume
    def get_surface(self): return self.surface
    def set_surface(self, surface): self.surface = surface
    def get_preprocessor(self): return self.preprocessor
    def set_preprocessor(self, preprocessor): self.preprocessor = preprocessor
    def get_postprocessor(self): return self.postprocessor
    def set_postprocessor(self, postprocessor): self.postprocessor = postprocessor
    def export(self, outfile, level, namespace_='module:', name_='module', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='module')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='module'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='module', fromsubclass_=False):
        if self.general is not None:
            self.general.export(outfile, level, namespace_, name_='general', )
        if self.constants is not None:
            self.constants.export(outfile, level, namespace_, name_='constants', )
        if self.volume is not None:
            self.volume.export(outfile, level, namespace_, name_='volume', )
        if self.surface is not None:
            self.surface.export(outfile, level, namespace_, name_='surface', )
        if self.preprocessor is not None:
            self.preprocessor.export(outfile, level, namespace_, name_='preprocessor', )
        if self.postprocessor is not None:
            self.postprocessor.export(outfile, level, namespace_, name_='postprocessor', )
    def hasContent_(self):
        if (
            self.general is not None or
            self.constants is not None or
            self.volume is not None or
            self.surface is not None or
            self.preprocessor is not None or
            self.postprocessor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='module'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.general is not None:
            showIndent(outfile, level)
            outfile.write('general=model_.general(\n')
            self.general.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.constants is not None:
            showIndent(outfile, level)
            outfile.write('constants=model_.constants(\n')
            self.constants.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.volume is not None:
            showIndent(outfile, level)
            outfile.write('volume=model_.volume(\n')
            self.volume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.surface is not None:
            showIndent(outfile, level)
            outfile.write('surface=model_.surface(\n')
            self.surface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.preprocessor is not None:
            showIndent(outfile, level)
            outfile.write('preprocessor=model_.preprocessor(\n')
            self.preprocessor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.postprocessor is not None:
            showIndent(outfile, level)
            outfile.write('postprocessor=model_.postprocessor(\n')
            self.postprocessor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'general':
            obj_ = general.factory()
            obj_.build(child_)
            self.set_general(obj_)
        elif nodeName_ == 'constants':
            obj_ = constants.factory()
            obj_.build(child_)
            self.set_constants(obj_)
        elif nodeName_ == 'volume':
            obj_ = volume.factory()
            obj_.build(child_)
            self.set_volume(obj_)
        elif nodeName_ == 'surface':
            obj_ = surface.factory()
            obj_.build(child_)
            self.set_surface(obj_)
        elif nodeName_ == 'preprocessor':
            obj_ = preprocessor.factory()
            obj_.build(child_)
            self.set_preprocessor(obj_)
        elif nodeName_ == 'postprocessor':
            obj_ = postprocessor.factory()
            obj_.build(child_)
            self.set_postprocessor(obj_)
# end class module


class general(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deformed_shape=None, id=None, name=None, description=None, analyses=None):
        self.deformed_shape = _cast(int, deformed_shape)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.description = description
        self.analyses = analyses
    def factory(*args_, **kwargs_):
        if general.subclass:
            return general.subclass(*args_, **kwargs_)
        else:
            return general(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_analyses(self): return self.analyses
    def set_analyses(self, analyses): self.analyses = analyses
    def get_deformed_shape(self): return self.deformed_shape
    def set_deformed_shape(self, deformed_shape): self.deformed_shape = deformed_shape
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='module:', name_='general', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='general')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='general'):
        if self.deformed_shape is not None and 'deformed_shape' not in already_processed:
            already_processed.append('deformed_shape')
            outfile.write(' deformed_shape="%s"' % self.gds_format_integer(self.deformed_shape, input_name='deformed_shape'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='general', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.analyses is not None:
            self.analyses.export(outfile, level, namespace_, name_='analyses', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.analyses is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='general'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deformed_shape is not None and 'deformed_shape' not in already_processed:
            already_processed.append('deformed_shape')
            showIndent(outfile, level)
            outfile.write('deformed_shape = %d,\n' % (self.deformed_shape,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.analyses is not None:
            showIndent(outfile, level)
            outfile.write('analyses=model_.analyses(\n')
            self.analyses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deformed_shape', node)
        if value is not None and 'deformed_shape' not in already_processed:
            already_processed.append('deformed_shape')
            try:
                self.deformed_shape = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'analyses':
            obj_ = analyses.factory()
            obj_.build(child_)
            self.set_analyses(obj_)
# end class general


class analyses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analysis=None):
        if analysis is None:
            self.analysis = []
        else:
            self.analysis = analysis
    def factory(*args_, **kwargs_):
        if analyses.subclass:
            return analyses.subclass(*args_, **kwargs_)
        else:
            return analyses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analysis(self): return self.analysis
    def set_analysis(self, analysis): self.analysis = analysis
    def add_analysis(self, value): self.analysis.append(value)
    def insert_analysis(self, index, value): self.analysis[index] = value
    def export(self, outfile, level, namespace_='module:', name_='analyses', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='analyses')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='analyses'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='analyses', fromsubclass_=False):
        for analysis_ in self.analysis:
            analysis_.export(outfile, level, namespace_, name_='analysis')
    def hasContent_(self):
        if (
            self.analysis
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analyses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('analysis=[\n')
        level += 1
        for analysis_ in self.analysis:
            showIndent(outfile, level)
            outfile.write('model_.analysis(\n')
            analysis_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'analysis':
            obj_ = analysis.factory()
            obj_.build(child_)
            self.analysis.append(obj_)
# end class analyses


class analysis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, solutions=None, id=None, name=None):
        self.type_ = _cast(None, type_)
        self.solutions = _cast(int, solutions)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if analysis.subclass:
            return analysis.subclass(*args_, **kwargs_)
        else:
            return analysis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_solutions(self): return self.solutions
    def set_solutions(self, solutions): self.solutions = solutions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='module:', name_='analysis', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='analysis')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='analysis'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.solutions is not None and 'solutions' not in already_processed:
            already_processed.append('solutions')
            outfile.write(' solutions="%s"' % self.gds_format_integer(self.solutions, input_name='solutions'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='analysis', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analysis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.solutions is not None and 'solutions' not in already_processed:
            already_processed.append('solutions')
            showIndent(outfile, level)
            outfile.write('solutions = %d,\n' % (self.solutions,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('solutions', node)
        if value is not None and 'solutions' not in already_processed:
            already_processed.append('solutions')
            try:
                self.solutions = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class analysis


class constants(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constant=None):
        if constant is None:
            self.constant = []
        else:
            self.constant = constant
    def factory(*args_, **kwargs_):
        if constants.subclass:
            return constants.subclass(*args_, **kwargs_)
        else:
            return constants(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def add_constant(self, value): self.constant.append(value)
    def insert_constant(self, index, value): self.constant[index] = value
    def export(self, outfile, level, namespace_='module:', name_='constants', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constants')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='constants'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='constants', fromsubclass_=False):
        for constant_ in self.constant:
            constant_.export(outfile, level, namespace_, name_='constant')
    def hasContent_(self):
        if (
            self.constant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='constants'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('constant=[\n')
        level += 1
        for constant_ in self.constant:
            showIndent(outfile, level)
            outfile.write('model_.constant(\n')
            constant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constant':
            obj_ = constant.factory()
            obj_.build(child_)
            self.constant.append(obj_)
# end class constants


class constant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None):
        self.id = _cast(None, id)
        self.value = _cast(float, value)
        pass
    def factory(*args_, **kwargs_):
        if constant.subclass:
            return constant.subclass(*args_, **kwargs_)
        else:
            return constant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='module:', name_='constant', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constant')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='constant'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='module:', name_='constant', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='constant'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class constant


class macros(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, macro=None):
        self.macro = macro
    def factory(*args_, **kwargs_):
        if macros.subclass:
            return macros.subclass(*args_, **kwargs_)
        else:
            return macros(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_macro(self): return self.macro
    def set_macro(self, macro): self.macro = macro
    def export(self, outfile, level, namespace_='module:', name_='macros', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='macros')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='macros'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='macros', fromsubclass_=False):
        if self.macro is not None:
            self.macro.export(outfile, level, namespace_, name_='macro', )
    def hasContent_(self):
        if (
            self.macro is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='macros'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.macro is not None:
            showIndent(outfile, level)
            outfile.write('macro=model_.macro(\n')
            self.macro.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'macro':
            obj_ = macro.factory()
            obj_.build(child_)
            self.set_macro(obj_)
# end class macros


class macro(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, expression=None, id=None):
        self.expression = _cast(None, expression)
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if macro.subclass:
            return macro.subclass(*args_, **kwargs_)
        else:
            return macro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='module:', name_='macro', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='macro')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='macro'):
        if self.expression is not None and 'expression' not in already_processed:
            already_processed.append('expression')
            outfile.write(' expression=%s' % (self.gds_format_string(quote_attrib(self.expression).encode(ExternalEncoding), input_name='expression'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='macro', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='macro'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.expression is not None and 'expression' not in already_processed:
            already_processed.append('expression')
            showIndent(outfile, level)
            outfile.write('expression = "%s",\n' % (self.expression,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expression', node)
        if value is not None and 'expression' not in already_processed:
            already_processed.append('expression')
            self.expression = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class macro


class preprocessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gui=None):
        if gui is None:
            self.gui = []
        else:
            self.gui = gui
    def factory(*args_, **kwargs_):
        if preprocessor.subclass:
            return preprocessor.subclass(*args_, **kwargs_)
        else:
            return preprocessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gui(self): return self.gui
    def set_gui(self, gui): self.gui = gui
    def add_gui(self, value): self.gui.append(value)
    def insert_gui(self, index, value): self.gui[index] = value
    def export(self, outfile, level, namespace_='module:', name_='preprocessor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='preprocessor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='preprocessor'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='preprocessor', fromsubclass_=False):
        for gui_ in self.gui:
            gui_.export(outfile, level, namespace_, name_='gui')
    def hasContent_(self):
        if (
            self.gui
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='preprocessor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('gui=[\n')
        level += 1
        for gui_ in self.gui:
            showIndent(outfile, level)
            outfile.write('model_.gui(\n')
            gui_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gui':
            obj_ = gui.factory()
            obj_.build(child_)
            self.gui.append(obj_)
# end class preprocessor


class gui(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, group=None):
        self.type_ = _cast(None, type_)
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if gui.subclass:
            return gui.subclass(*args_, **kwargs_)
        else:
            return gui(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group(self, index, value): self.group[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='module:', name_='gui', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gui')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='gui'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='gui', fromsubclass_=False):
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group')
    def hasContent_(self):
        if (
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gui'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('model_.group(\n')
            group_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            obj_ = group.factory()
            obj_.build(child_)
            self.group.append(obj_)
# end class gui


class postprocessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, localvariables=None, view=None, volumeintegrals=None, surfaceintegrals=None):
        self.localvariables = localvariables
        self.view = view
        self.volumeintegrals = volumeintegrals
        self.surfaceintegrals = surfaceintegrals
    def factory(*args_, **kwargs_):
        if postprocessor.subclass:
            return postprocessor.subclass(*args_, **kwargs_)
        else:
            return postprocessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localvariables(self): return self.localvariables
    def set_localvariables(self, localvariables): self.localvariables = localvariables
    def get_view(self): return self.view
    def set_view(self, view): self.view = view
    def get_volumeintegrals(self): return self.volumeintegrals
    def set_volumeintegrals(self, volumeintegrals): self.volumeintegrals = volumeintegrals
    def get_surfaceintegrals(self): return self.surfaceintegrals
    def set_surfaceintegrals(self, surfaceintegrals): self.surfaceintegrals = surfaceintegrals
    def export(self, outfile, level, namespace_='module:', name_='postprocessor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postprocessor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='postprocessor'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='postprocessor', fromsubclass_=False):
        if self.localvariables is not None:
            self.localvariables.export(outfile, level, namespace_, name_='localvariables', )
        if self.view is not None:
            self.view.export(outfile, level, namespace_, name_='view', )
        if self.volumeintegrals is not None:
            self.volumeintegrals.export(outfile, level, namespace_, name_='volumeintegrals', )
        if self.surfaceintegrals is not None:
            self.surfaceintegrals.export(outfile, level, namespace_, name_='surfaceintegrals', )
    def hasContent_(self):
        if (
            self.localvariables is not None or
            self.view is not None or
            self.volumeintegrals is not None or
            self.surfaceintegrals is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='postprocessor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.localvariables is not None:
            showIndent(outfile, level)
            outfile.write('localvariables=model_.localvariables(\n')
            self.localvariables.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.view is not None:
            showIndent(outfile, level)
            outfile.write('view=model_.view(\n')
            self.view.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.volumeintegrals is not None:
            showIndent(outfile, level)
            outfile.write('volumeintegrals=model_.volumeintegrals(\n')
            self.volumeintegrals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.surfaceintegrals is not None:
            showIndent(outfile, level)
            outfile.write('surfaceintegrals=model_.surfaceintegrals(\n')
            self.surfaceintegrals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localvariables':
            obj_ = localvariables.factory()
            obj_.build(child_)
            self.set_localvariables(obj_)
        elif nodeName_ == 'view':
            obj_ = view.factory()
            obj_.build(child_)
            self.set_view(obj_)
        elif nodeName_ == 'volumeintegrals':
            obj_ = volumeintegrals.factory()
            obj_.build(child_)
            self.set_volumeintegrals(obj_)
        elif nodeName_ == 'surfaceintegrals':
            obj_ = surfaceintegrals.factory()
            obj_.build(child_)
            self.set_surfaceintegrals(obj_)
# end class postprocessor


class localvariables(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, localvariable=None):
        if localvariable is None:
            self.localvariable = []
        else:
            self.localvariable = localvariable
    def factory(*args_, **kwargs_):
        if localvariables.subclass:
            return localvariables.subclass(*args_, **kwargs_)
        else:
            return localvariables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localvariable(self): return self.localvariable
    def set_localvariable(self, localvariable): self.localvariable = localvariable
    def add_localvariable(self, value): self.localvariable.append(value)
    def insert_localvariable(self, index, value): self.localvariable[index] = value
    def export(self, outfile, level, namespace_='module:', name_='localvariables', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localvariables')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='localvariables'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='localvariables', fromsubclass_=False):
        for localvariable_ in self.localvariable:
            localvariable_.export(outfile, level, namespace_, name_='localvariable')
    def hasContent_(self):
        if (
            self.localvariable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='localvariables'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('localvariable=[\n')
        level += 1
        for localvariable_ in self.localvariable:
            showIndent(outfile, level)
            outfile.write('model_.localvariable(\n')
            localvariable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localvariable':
            obj_ = localvariable.factory()
            obj_.build(child_)
            self.localvariable.append(obj_)
# end class localvariables


class localvariable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit_html=None, name=None, format=None, shortname_latex=None, shortname_html=None, unit_latex=None, shortname=None, type_=None, id=None, unit=None, expression=None):
        self.unit_html = _cast(None, unit_html)
        self.name = _cast(None, name)
        self.format = _cast(None, format)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.shortname = _cast(None, shortname)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
    def factory(*args_, **kwargs_):
        if localvariable.subclass:
            return localvariable.subclass(*args_, **kwargs_)
        else:
            return localvariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def add_expression(self, value): self.expression.append(value)
    def insert_expression(self, index, value): self.expression[index] = value
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='module:', name_='localvariable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localvariable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='localvariable'):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.append('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (self.gds_format_string(quote_attrib(self.shortname).encode(ExternalEncoding), input_name='shortname'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='localvariable', fromsubclass_=False):
        for expression_ in self.expression:
            expression_.export(outfile, level, namespace_, name_='expression')
    def hasContent_(self):
        if (
            self.expression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='localvariable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.append('format')
            showIndent(outfile, level)
            outfile.write('format = "%s",\n' % (self.format,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.expression(\n')
            expression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.append('format')
            self.format = value
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expression':
            obj_ = expression.factory()
            obj_.build(child_)
            self.expression.append(obj_)
# end class localvariable


class view(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scalar_view=None, vector_view=None):
        self.scalar_view = scalar_view
        self.vector_view = vector_view
    def factory(*args_, **kwargs_):
        if view.subclass:
            return view.subclass(*args_, **kwargs_)
        else:
            return view(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scalar_view(self): return self.scalar_view
    def set_scalar_view(self, scalar_view): self.scalar_view = scalar_view
    def get_vector_view(self): return self.vector_view
    def set_vector_view(self, vector_view): self.vector_view = vector_view
    def export(self, outfile, level, namespace_='module:', name_='view', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='view')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='view'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='view', fromsubclass_=False):
        if self.scalar_view is not None:
            self.scalar_view.export(outfile, level, namespace_, name_='scalar_view', )
        if self.vector_view is not None:
            self.vector_view.export(outfile, level, namespace_, name_='vector_view', )
    def hasContent_(self):
        if (
            self.scalar_view is not None or
            self.vector_view is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='view'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.scalar_view is not None:
            showIndent(outfile, level)
            outfile.write('scalar_view=model_.scalar_view(\n')
            self.scalar_view.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vector_view is not None:
            showIndent(outfile, level)
            outfile.write('vector_view=model_.vector_view(\n')
            self.vector_view.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scalar_view':
            obj_ = scalar_view.factory()
            obj_.build(child_)
            self.set_scalar_view(obj_)
        elif nodeName_ == 'vector_view':
            obj_ = vector_view.factory()
            obj_.build(child_)
            self.set_vector_view(obj_)
# end class view


class scalar_view(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None):
        if default is None:
            self.default = []
        else:
            self.default = default
    def factory(*args_, **kwargs_):
        if scalar_view.subclass:
            return scalar_view.subclass(*args_, **kwargs_)
        else:
            return scalar_view(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def add_default(self, value): self.default.append(value)
    def insert_default(self, index, value): self.default[index] = value
    def export(self, outfile, level, namespace_='module:', name_='scalar_view', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scalar_view')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='scalar_view'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='scalar_view', fromsubclass_=False):
        for default_ in self.default:
            default_.export(outfile, level, namespace_, name_='default')
    def hasContent_(self):
        if (
            self.default
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scalar_view'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('default=[\n')
        level += 1
        for default_ in self.default:
            showIndent(outfile, level)
            outfile.write('model_.default(\n')
            default_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'default':
            obj_ = default.factory()
            obj_.build(child_)
            self.default.append(obj_)
# end class scalar_view


class vector_view(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None):
        if default is None:
            self.default = []
        else:
            self.default = default
    def factory(*args_, **kwargs_):
        if vector_view.subclass:
            return vector_view.subclass(*args_, **kwargs_)
        else:
            return vector_view(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def add_default(self, value): self.default.append(value)
    def insert_default(self, index, value): self.default[index] = value
    def export(self, outfile, level, namespace_='module:', name_='vector_view', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vector_view')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='vector_view'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='vector_view', fromsubclass_=False):
        for default_ in self.default:
            default_.export(outfile, level, namespace_, name_='default')
    def hasContent_(self):
        if (
            self.default
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vector_view'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('default=[\n')
        level += 1
        for default_ in self.default:
            showIndent(outfile, level)
            outfile.write('model_.default(\n')
            default_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'default':
            obj_ = default.factory()
            obj_.build(child_)
            self.default.append(obj_)
# end class vector_view


class volumeintegrals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, volumeintegral=None):
        if volumeintegral is None:
            self.volumeintegral = []
        else:
            self.volumeintegral = volumeintegral
    def factory(*args_, **kwargs_):
        if volumeintegrals.subclass:
            return volumeintegrals.subclass(*args_, **kwargs_)
        else:
            return volumeintegrals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_volumeintegral(self): return self.volumeintegral
    def set_volumeintegral(self, volumeintegral): self.volumeintegral = volumeintegral
    def add_volumeintegral(self, value): self.volumeintegral.append(value)
    def insert_volumeintegral(self, index, value): self.volumeintegral[index] = value
    def export(self, outfile, level, namespace_='module:', name_='volumeintegrals', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volumeintegrals')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='volumeintegrals'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='volumeintegrals', fromsubclass_=False):
        for volumeintegral_ in self.volumeintegral:
            volumeintegral_.export(outfile, level, namespace_, name_='volumeintegral')
    def hasContent_(self):
        if (
            self.volumeintegral
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volumeintegrals'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('volumeintegral=[\n')
        level += 1
        for volumeintegral_ in self.volumeintegral:
            showIndent(outfile, level)
            outfile.write('model_.volumeintegral(\n')
            volumeintegral_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'volumeintegral':
            obj_ = volumeintegral.factory()
            obj_.build(child_)
            self.volumeintegral.append(obj_)
# end class volumeintegrals


class volumeintegral(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit_html=None, name=None, shortname_latex=None, shortname_html=None, unit_latex=None, shortname=None, id=None, unit=None, expression=None):
        self.unit_html = _cast(None, unit_html)
        self.name = _cast(None, name)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.shortname = _cast(None, shortname)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
    def factory(*args_, **kwargs_):
        if volumeintegral.subclass:
            return volumeintegral.subclass(*args_, **kwargs_)
        else:
            return volumeintegral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def add_expression(self, value): self.expression.append(value)
    def insert_expression(self, index, value): self.expression[index] = value
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='module:', name_='volumeintegral', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volumeintegral')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='volumeintegral'):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (self.gds_format_string(quote_attrib(self.shortname).encode(ExternalEncoding), input_name='shortname'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='volumeintegral', fromsubclass_=False):
        for expression_ in self.expression:
            expression_.export(outfile, level, namespace_, name_='expression')
    def hasContent_(self):
        if (
            self.expression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volumeintegral'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.expression(\n')
            expression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expression':
            obj_ = expression.factory()
            obj_.build(child_)
            self.expression.append(obj_)
# end class volumeintegral


class surfaceintegrals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, surfaceintegral=None):
        if surfaceintegral is None:
            self.surfaceintegral = []
        else:
            self.surfaceintegral = surfaceintegral
    def factory(*args_, **kwargs_):
        if surfaceintegrals.subclass:
            return surfaceintegrals.subclass(*args_, **kwargs_)
        else:
            return surfaceintegrals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_surfaceintegral(self): return self.surfaceintegral
    def set_surfaceintegral(self, surfaceintegral): self.surfaceintegral = surfaceintegral
    def add_surfaceintegral(self, value): self.surfaceintegral.append(value)
    def insert_surfaceintegral(self, index, value): self.surfaceintegral[index] = value
    def export(self, outfile, level, namespace_='module:', name_='surfaceintegrals', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surfaceintegrals')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='surfaceintegrals'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='surfaceintegrals', fromsubclass_=False):
        for surfaceintegral_ in self.surfaceintegral:
            surfaceintegral_.export(outfile, level, namespace_, name_='surfaceintegral')
    def hasContent_(self):
        if (
            self.surfaceintegral
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='surfaceintegrals'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('surfaceintegral=[\n')
        level += 1
        for surfaceintegral_ in self.surfaceintegral:
            showIndent(outfile, level)
            outfile.write('model_.surfaceintegral(\n')
            surfaceintegral_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'surfaceintegral':
            obj_ = surfaceintegral.factory()
            obj_.build(child_)
            self.surfaceintegral.append(obj_)
# end class surfaceintegrals


class surfaceintegral(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit_html=None, name=None, shortname_latex=None, shortname_html=None, unit_latex=None, shortname=None, id=None, unit=None, expression=None):
        self.unit_html = _cast(None, unit_html)
        self.name = _cast(None, name)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.shortname = _cast(None, shortname)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
    def factory(*args_, **kwargs_):
        if surfaceintegral.subclass:
            return surfaceintegral.subclass(*args_, **kwargs_)
        else:
            return surfaceintegral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def add_expression(self, value): self.expression.append(value)
    def insert_expression(self, index, value): self.expression[index] = value
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='module:', name_='surfaceintegral', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surfaceintegral')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='surfaceintegral'):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (self.gds_format_string(quote_attrib(self.shortname).encode(ExternalEncoding), input_name='shortname'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='surfaceintegral', fromsubclass_=False):
        for expression_ in self.expression:
            expression_.export(outfile, level, namespace_, name_='expression')
    def hasContent_(self):
        if (
            self.expression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='surfaceintegral'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.expression(\n')
            expression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expression':
            obj_ = expression.factory()
            obj_.build(child_)
            self.expression.append(obj_)
# end class surfaceintegral


class volume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, quantity=None, weakforms_volume=None):
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.weakforms_volume = weakforms_volume
    def factory(*args_, **kwargs_):
        if volume.subclass:
            return volume.subclass(*args_, **kwargs_)
        else:
            return volume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_weakforms_volume(self): return self.weakforms_volume
    def set_weakforms_volume(self, weakforms_volume): self.weakforms_volume = weakforms_volume
    def export(self, outfile, level, namespace_='module:', name_='volume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='volume'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='volume', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        if self.weakforms_volume is not None:
            self.weakforms_volume.export(outfile, level, namespace_, name_='weakforms_volume', )
    def hasContent_(self):
        if (
            self.quantity or
            self.weakforms_volume is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.weakforms_volume is not None:
            showIndent(outfile, level)
            outfile.write('weakforms_volume=model_.weakforms_volume(\n')
            self.weakforms_volume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'weakforms_volume':
            obj_ = weakforms_volume.factory()
            obj_.build(child_)
            self.set_weakforms_volume(obj_)
# end class volume


class surface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, quantity=None, weakforms_surface=None):
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.weakforms_surface = weakforms_surface
    def factory(*args_, **kwargs_):
        if surface.subclass:
            return surface.subclass(*args_, **kwargs_)
        else:
            return surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_weakforms_surface(self): return self.weakforms_surface
    def set_weakforms_surface(self, weakforms_surface): self.weakforms_surface = weakforms_surface
    def export(self, outfile, level, namespace_='module:', name_='surface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='surface'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='surface', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        if self.weakforms_surface is not None:
            self.weakforms_surface.export(outfile, level, namespace_, name_='weakforms_surface', )
    def hasContent_(self):
        if (
            self.quantity or
            self.weakforms_surface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='surface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.weakforms_surface is not None:
            showIndent(outfile, level)
            outfile.write('weakforms_surface=model_.weakforms_surface(\n')
            self.weakforms_surface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'weakforms_surface':
            obj_ = weakforms_surface.factory()
            obj_.build(child_)
            self.set_weakforms_surface(obj_)
# end class surface


class weakforms_surface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, group=None, weakform_surface=None):
        self.group = group
        if weakform_surface is None:
            self.weakform_surface = []
        else:
            self.weakform_surface = weakform_surface
    def factory(*args_, **kwargs_):
        if weakforms_surface.subclass:
            return weakforms_surface.subclass(*args_, **kwargs_)
        else:
            return weakforms_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_weakform_surface(self): return self.weakform_surface
    def set_weakform_surface(self, weakform_surface): self.weakform_surface = weakform_surface
    def add_weakform_surface(self, value): self.weakform_surface.append(value)
    def insert_weakform_surface(self, index, value): self.weakform_surface[index] = value
    def export(self, outfile, level, namespace_='module:', name_='weakforms_surface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weakforms_surface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='weakforms_surface'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='weakforms_surface', fromsubclass_=False):
        if self.group is not None:
            self.group.export(outfile, level, namespace_, name_='group', )
        for weakform_surface_ in self.weakform_surface:
            weakform_surface_.export(outfile, level, namespace_, name_='weakform_surface')
    def hasContent_(self):
        if (
            self.group is not None or
            self.weakform_surface
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='weakforms_surface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=model_.group(\n')
            self.group.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('weakform_surface=[\n')
        level += 1
        for weakform_surface_ in self.weakform_surface:
            showIndent(outfile, level)
            outfile.write('model_.weakform_surface(\n')
            weakform_surface_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            obj_ = group.factory()
            obj_.build(child_)
            self.set_group(obj_)
        elif nodeName_ == 'weakform_surface':
            obj_ = weakform_surface.factory()
            obj_.build(child_)
            self.weakform_surface.append(obj_)
# end class weakforms_surface


class weakform_surface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, analysistype=None, boundary=None, quantity=None, matrix_form=None, vector_form=None):
        self.default = _cast(None, default)
        self.analysistype = _cast(None, analysistype)
        if boundary is None:
            self.boundary = []
        else:
            self.boundary = boundary
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        if matrix_form is None:
            self.matrix_form = []
        else:
            self.matrix_form = matrix_form
        if vector_form is None:
            self.vector_form = []
        else:
            self.vector_form = vector_form
    def factory(*args_, **kwargs_):
        if weakform_surface.subclass:
            return weakform_surface.subclass(*args_, **kwargs_)
        else:
            return weakform_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boundary(self): return self.boundary
    def set_boundary(self, boundary): self.boundary = boundary
    def add_boundary(self, value): self.boundary.append(value)
    def insert_boundary(self, index, value): self.boundary[index] = value
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_matrix_form(self): return self.matrix_form
    def set_matrix_form(self, matrix_form): self.matrix_form = matrix_form
    def add_matrix_form(self, value): self.matrix_form.append(value)
    def insert_matrix_form(self, index, value): self.matrix_form[index] = value
    def get_vector_form(self): return self.vector_form
    def set_vector_form(self, vector_form): self.vector_form = vector_form
    def add_vector_form(self, value): self.vector_form.append(value)
    def insert_vector_form(self, index, value): self.vector_form[index] = value
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def export(self, outfile, level, namespace_='module:', name_='weakform_surface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weakform_surface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='weakform_surface'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (self.gds_format_string(quote_attrib(self.analysistype).encode(ExternalEncoding), input_name='analysistype'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='weakform_surface', fromsubclass_=False):
        for boundary_ in self.boundary:
            boundary_.export(outfile, level, namespace_, name_='boundary')
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        for matrix_form_ in self.matrix_form:
            matrix_form_.export(outfile, level, namespace_, name_='matrix_form')
        for vector_form_ in self.vector_form:
            vector_form_.export(outfile, level, namespace_, name_='vector_form')
    def hasContent_(self):
        if (
            self.boundary or
            self.quantity or
            self.matrix_form or
            self.vector_form
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='weakform_surface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('boundary=[\n')
        level += 1
        for boundary_ in self.boundary:
            showIndent(outfile, level)
            outfile.write('model_.boundary(\n')
            boundary_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('matrix_form=[\n')
        level += 1
        for matrix_form_ in self.matrix_form:
            showIndent(outfile, level)
            outfile.write('model_.matrix_form(\n')
            matrix_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vector_form=[\n')
        level += 1
        for vector_form_ in self.vector_form:
            showIndent(outfile, level)
            outfile.write('model_.vector_form(\n')
            vector_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boundary':
            obj_ = boundary.factory()
            obj_.build(child_)
            self.boundary.append(obj_)
        elif nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'matrix_form':
            obj_ = matrix_form.factory()
            obj_.build(child_)
            self.matrix_form.append(obj_)
        elif nodeName_ == 'vector_form':
            obj_ = vector_form.factory()
            obj_.build(child_)
            self.vector_form.append(obj_)
# end class weakform_surface


class expression(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, planar=None, planar_y=None, planar_x=None, axi_r=None, analysistype=None, axi=None, axi_z=None):
        self.planar = _cast(None, planar)
        self.planar_y = _cast(None, planar_y)
        self.planar_x = _cast(None, planar_x)
        self.axi_r = _cast(None, axi_r)
        self.analysistype = _cast(None, analysistype)
        self.axi = _cast(None, axi)
        self.axi_z = _cast(None, axi_z)
        pass
    def factory(*args_, **kwargs_):
        if expression.subclass:
            return expression.subclass(*args_, **kwargs_)
        else:
            return expression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_planar_y(self): return self.planar_y
    def set_planar_y(self, planar_y): self.planar_y = planar_y
    def get_planar_x(self): return self.planar_x
    def set_planar_x(self, planar_x): self.planar_x = planar_x
    def get_axi_r(self): return self.axi_r
    def set_axi_r(self, axi_r): self.axi_r = axi_r
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def get_axi_z(self): return self.axi_z
    def set_axi_z(self, axi_z): self.axi_z = axi_z
    def export(self, outfile, level, namespace_='module:', name_='expression', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='expression')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='expression'):
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.planar_y is not None and 'planar_y' not in already_processed:
            already_processed.append('planar_y')
            outfile.write(' planar_y=%s' % (self.gds_format_string(quote_attrib(self.planar_y).encode(ExternalEncoding), input_name='planar_y'), ))
        if self.planar_x is not None and 'planar_x' not in already_processed:
            already_processed.append('planar_x')
            outfile.write(' planar_x=%s' % (self.gds_format_string(quote_attrib(self.planar_x).encode(ExternalEncoding), input_name='planar_x'), ))
        if self.axi_r is not None and 'axi_r' not in already_processed:
            already_processed.append('axi_r')
            outfile.write(' axi_r=%s' % (self.gds_format_string(quote_attrib(self.axi_r).encode(ExternalEncoding), input_name='axi_r'), ))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (self.gds_format_string(quote_attrib(self.analysistype).encode(ExternalEncoding), input_name='analysistype'), ))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
        if self.axi_z is not None and 'axi_z' not in already_processed:
            already_processed.append('axi_z')
            outfile.write(' axi_z=%s' % (self.gds_format_string(quote_attrib(self.axi_z).encode(ExternalEncoding), input_name='axi_z'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='expression', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='expression'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.planar_y is not None and 'planar_y' not in already_processed:
            already_processed.append('planar_y')
            showIndent(outfile, level)
            outfile.write('planar_y = "%s",\n' % (self.planar_y,))
        if self.planar_x is not None and 'planar_x' not in already_processed:
            already_processed.append('planar_x')
            showIndent(outfile, level)
            outfile.write('planar_x = "%s",\n' % (self.planar_x,))
        if self.axi_r is not None and 'axi_r' not in already_processed:
            already_processed.append('axi_r')
            showIndent(outfile, level)
            outfile.write('axi_r = "%s",\n' % (self.axi_r,))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
        if self.axi_z is not None and 'axi_z' not in already_processed:
            already_processed.append('axi_z')
            showIndent(outfile, level)
            outfile.write('axi_z = "%s",\n' % (self.axi_z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('planar_y', node)
        if value is not None and 'planar_y' not in already_processed:
            already_processed.append('planar_y')
            self.planar_y = value
        value = find_attr_value_('planar_x', node)
        if value is not None and 'planar_x' not in already_processed:
            already_processed.append('planar_x')
            self.planar_x = value
        value = find_attr_value_('axi_r', node)
        if value is not None and 'axi_r' not in already_processed:
            already_processed.append('axi_r')
            self.axi_r = value
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
        value = find_attr_value_('axi_z', node)
        if value is not None and 'axi_z' not in already_processed:
            already_processed.append('axi_z')
            self.axi_z = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class expression


class default(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analysistype=None, id=None):
        self.analysistype = _cast(None, analysistype)
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if default.subclass:
            return default.subclass(*args_, **kwargs_)
        else:
            return default(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='module:', name_='default', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='default')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='default'):
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (self.gds_format_string(quote_attrib(self.analysistype).encode(ExternalEncoding), input_name='analysistype'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='default', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='default'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class default


class quantity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nonlinearity_axi=None, name=None, default=None, shortname_latex=None, shortname_html=None, dependence=None, unit_latex=None, unit_html=None, unit=None, nonlinearity_planar=None, shortname=None, id=None, condition=None):
        self.nonlinearity_axi = _cast(None, nonlinearity_axi)
        self.name = _cast(None, name)
        self.default = _cast(float, default)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.dependence = _cast(None, dependence)
        self.unit_latex = _cast(None, unit_latex)
        self.unit_html = _cast(None, unit_html)
        self.unit = _cast(None, unit)
        self.nonlinearity_planar = _cast(None, nonlinearity_planar)
        self.shortname = _cast(None, shortname)
        self.id = _cast(None, id)
        self.condition = _cast(None, condition)
        pass
    def factory(*args_, **kwargs_):
        if quantity.subclass:
            return quantity.subclass(*args_, **kwargs_)
        else:
            return quantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nonlinearity_axi(self): return self.nonlinearity_axi
    def set_nonlinearity_axi(self, nonlinearity_axi): self.nonlinearity_axi = nonlinearity_axi
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_dependence(self): return self.dependence
    def set_dependence(self, dependence): self.dependence = dependence
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_nonlinearity_planar(self): return self.nonlinearity_planar
    def set_nonlinearity_planar(self, nonlinearity_planar): self.nonlinearity_planar = nonlinearity_planar
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def export(self, outfile, level, namespace_='module:', name_='quantity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='quantity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='quantity'):
        if self.nonlinearity_axi is not None and 'nonlinearity_axi' not in already_processed:
            already_processed.append('nonlinearity_axi')
            outfile.write(' nonlinearity_axi=%s' % (self.gds_format_string(quote_attrib(self.nonlinearity_axi).encode(ExternalEncoding), input_name='nonlinearity_axi'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default="%s"' % self.gds_format_float(self.default, input_name='default'))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.dependence is not None and 'dependence' not in already_processed:
            already_processed.append('dependence')
            outfile.write(' dependence=%s' % (self.gds_format_string(quote_attrib(self.dependence).encode(ExternalEncoding), input_name='dependence'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
        if self.nonlinearity_planar is not None and 'nonlinearity_planar' not in already_processed:
            already_processed.append('nonlinearity_planar')
            outfile.write(' nonlinearity_planar=%s' % (self.gds_format_string(quote_attrib(self.nonlinearity_planar).encode(ExternalEncoding), input_name='nonlinearity_planar'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (self.gds_format_string(quote_attrib(self.shortname).encode(ExternalEncoding), input_name='shortname'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            outfile.write(' condition=%s' % (self.gds_format_string(quote_attrib(self.condition).encode(ExternalEncoding), input_name='condition'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='quantity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='quantity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nonlinearity_axi is not None and 'nonlinearity_axi' not in already_processed:
            already_processed.append('nonlinearity_axi')
            showIndent(outfile, level)
            outfile.write('nonlinearity_axi = "%s",\n' % (self.nonlinearity_axi,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = %f,\n' % (self.default,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.dependence is not None and 'dependence' not in already_processed:
            already_processed.append('dependence')
            showIndent(outfile, level)
            outfile.write('dependence = "%s",\n' % (self.dependence,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
        if self.nonlinearity_planar is not None and 'nonlinearity_planar' not in already_processed:
            already_processed.append('nonlinearity_planar')
            showIndent(outfile, level)
            outfile.write('nonlinearity_planar = "%s",\n' % (self.nonlinearity_planar,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            showIndent(outfile, level)
            outfile.write('condition = "%s",\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nonlinearity_axi', node)
        if value is not None and 'nonlinearity_axi' not in already_processed:
            already_processed.append('nonlinearity_axi')
            self.nonlinearity_axi = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            try:
                self.default = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('dependence', node)
        if value is not None and 'dependence' not in already_processed:
            already_processed.append('dependence')
            self.dependence = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
        value = find_attr_value_('nonlinearity_planar', node)
        if value is not None and 'nonlinearity_planar' not in already_processed:
            already_processed.append('nonlinearity_planar')
            self.nonlinearity_planar = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            self.condition = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class quantity


class weakforms_volume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, weakform_volume=None):
        if weakform_volume is None:
            self.weakform_volume = []
        else:
            self.weakform_volume = weakform_volume
    def factory(*args_, **kwargs_):
        if weakforms_volume.subclass:
            return weakforms_volume.subclass(*args_, **kwargs_)
        else:
            return weakforms_volume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weakform_volume(self): return self.weakform_volume
    def set_weakform_volume(self, weakform_volume): self.weakform_volume = weakform_volume
    def add_weakform_volume(self, value): self.weakform_volume.append(value)
    def insert_weakform_volume(self, index, value): self.weakform_volume[index] = value
    def export(self, outfile, level, namespace_='module:', name_='weakforms_volume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weakforms_volume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='weakforms_volume'):
        pass
    def exportChildren(self, outfile, level, namespace_='module:', name_='weakforms_volume', fromsubclass_=False):
        for weakform_volume_ in self.weakform_volume:
            weakform_volume_.export(outfile, level, namespace_, name_='weakform_volume')
    def hasContent_(self):
        if (
            self.weakform_volume
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='weakforms_volume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('weakform_volume=[\n')
        level += 1
        for weakform_volume_ in self.weakform_volume:
            showIndent(outfile, level)
            outfile.write('model_.weakform_volume(\n')
            weakform_volume_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weakform_volume':
            obj_ = weakform_volume.factory()
            obj_.build(child_)
            self.weakform_volume.append(obj_)
# end class weakforms_volume


class weakform_volume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analysistype=None, quantity=None, matrix_form=None, vector_form=None):
        self.analysistype = _cast(None, analysistype)
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        if matrix_form is None:
            self.matrix_form = []
        else:
            self.matrix_form = matrix_form
        if vector_form is None:
            self.vector_form = []
        else:
            self.vector_form = vector_form
    def factory(*args_, **kwargs_):
        if weakform_volume.subclass:
            return weakform_volume.subclass(*args_, **kwargs_)
        else:
            return weakform_volume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_matrix_form(self): return self.matrix_form
    def set_matrix_form(self, matrix_form): self.matrix_form = matrix_form
    def add_matrix_form(self, value): self.matrix_form.append(value)
    def insert_matrix_form(self, index, value): self.matrix_form[index] = value
    def get_vector_form(self): return self.vector_form
    def set_vector_form(self, vector_form): self.vector_form = vector_form
    def add_vector_form(self, value): self.vector_form.append(value)
    def insert_vector_form(self, index, value): self.vector_form[index] = value
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def export(self, outfile, level, namespace_='module:', name_='weakform_volume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weakform_volume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='weakform_volume'):
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (self.gds_format_string(quote_attrib(self.analysistype).encode(ExternalEncoding), input_name='analysistype'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='weakform_volume', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        for matrix_form_ in self.matrix_form:
            matrix_form_.export(outfile, level, namespace_, name_='matrix_form')
        for vector_form_ in self.vector_form:
            vector_form_.export(outfile, level, namespace_, name_='vector_form')
    def hasContent_(self):
        if (
            self.quantity or
            self.matrix_form or
            self.vector_form
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='weakform_volume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('matrix_form=[\n')
        level += 1
        for matrix_form_ in self.matrix_form:
            showIndent(outfile, level)
            outfile.write('model_.matrix_form(\n')
            matrix_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vector_form=[\n')
        level += 1
        for vector_form_ in self.vector_form:
            showIndent(outfile, level)
            outfile.write('model_.vector_form(\n')
            vector_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'matrix_form':
            obj_ = matrix_form.factory()
            obj_.build(child_)
            self.matrix_form.append(obj_)
        elif nodeName_ == 'vector_form':
            obj_ = vector_form.factory()
            obj_.build(child_)
            self.vector_form.append(obj_)
# end class weakform_volume


class group(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, quantity=None):
        self.name = _cast(None, name)
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
    def factory(*args_, **kwargs_):
        if group.subclass:
            return group.subclass(*args_, **kwargs_)
        else:
            return group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='module:', name_='group', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='group')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='group'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='group', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
    def hasContent_(self):
        if (
            self.quantity
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
# end class group


class matrix_form(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, symmetric=None, planar=None, j=None, axi=None):
        self.i = _cast(int, i)
        self.symmetric = _cast(int, symmetric)
        self.planar = _cast(None, planar)
        self.j = _cast(int, j)
        self.axi = _cast(None, axi)
        pass
    def factory(*args_, **kwargs_):
        if matrix_form.subclass:
            return matrix_form.subclass(*args_, **kwargs_)
        else:
            return matrix_form(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_symmetric(self): return self.symmetric
    def set_symmetric(self, symmetric): self.symmetric = symmetric
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_j(self): return self.j
    def set_j(self, j): self.j = j
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def export(self, outfile, level, namespace_='module:', name_='matrix_form', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrix_form')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='matrix_form'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.symmetric is not None and 'symmetric' not in already_processed:
            already_processed.append('symmetric')
            outfile.write(' symmetric="%s"' % self.gds_format_integer(self.symmetric, input_name='symmetric'))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name='j'))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='matrix_form', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='matrix_form'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.symmetric is not None and 'symmetric' not in already_processed:
            already_processed.append('symmetric')
            showIndent(outfile, level)
            outfile.write('symmetric = %d,\n' % (self.symmetric,))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            showIndent(outfile, level)
            outfile.write('j = %d,\n' % (self.j,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('symmetric', node)
        if value is not None and 'symmetric' not in already_processed:
            already_processed.append('symmetric')
            try:
                self.symmetric = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.append('j')
            try:
                self.j = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matrix_form


class vector_form(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, planar=None, j=None, axi=None):
        self.i = _cast(int, i)
        self.planar = _cast(None, planar)
        self.j = _cast(int, j)
        self.axi = _cast(None, axi)
        pass
    def factory(*args_, **kwargs_):
        if vector_form.subclass:
            return vector_form.subclass(*args_, **kwargs_)
        else:
            return vector_form(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_j(self): return self.j
    def set_j(self, j): self.j = j
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def export(self, outfile, level, namespace_='module:', name_='vector_form', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vector_form')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='vector_form'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name='j'))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='vector_form', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vector_form'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            showIndent(outfile, level)
            outfile.write('j = %d,\n' % (self.j,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.append('j')
            try:
                self.j = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vector_form


class essential_form(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, planar=None, axi=None):
        self.i = _cast(int, i)
        self.planar = _cast(None, planar)
        self.axi = _cast(None, axi)
        pass
    def factory(*args_, **kwargs_):
        if essential_form.subclass:
            return essential_form.subclass(*args_, **kwargs_)
        else:
            return essential_form(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def export(self, outfile, level, namespace_='module:', name_='essential_form', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='essential_form')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='essential_form'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='essential_form', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='essential_form'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class essential_form


class boundary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, quantity=None, matrix_form=None, vector_form=None, essential_form=None):
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        if matrix_form is None:
            self.matrix_form = []
        else:
            self.matrix_form = matrix_form
        if vector_form is None:
            self.vector_form = []
        else:
            self.vector_form = vector_form
        if essential_form is None:
            self.essential_form = []
        else:
            self.essential_form = essential_form
    def factory(*args_, **kwargs_):
        if boundary.subclass:
            return boundary.subclass(*args_, **kwargs_)
        else:
            return boundary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_matrix_form(self): return self.matrix_form
    def set_matrix_form(self, matrix_form): self.matrix_form = matrix_form
    def add_matrix_form(self, value): self.matrix_form.append(value)
    def insert_matrix_form(self, index, value): self.matrix_form[index] = value
    def get_vector_form(self): return self.vector_form
    def set_vector_form(self, vector_form): self.vector_form = vector_form
    def add_vector_form(self, value): self.vector_form.append(value)
    def insert_vector_form(self, index, value): self.vector_form[index] = value
    def get_essential_form(self): return self.essential_form
    def set_essential_form(self, essential_form): self.essential_form = essential_form
    def add_essential_form(self, value): self.essential_form.append(value)
    def insert_essential_form(self, index, value): self.essential_form[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='module:', name_='boundary', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='boundary')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='module:', name_='boundary'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='module:', name_='boundary', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        for matrix_form_ in self.matrix_form:
            matrix_form_.export(outfile, level, namespace_, name_='matrix_form')
        for vector_form_ in self.vector_form:
            vector_form_.export(outfile, level, namespace_, name_='vector_form')
        for essential_form_ in self.essential_form:
            essential_form_.export(outfile, level, namespace_, name_='essential_form')
    def hasContent_(self):
        if (
            self.quantity or
            self.matrix_form or
            self.vector_form or
            self.essential_form
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='boundary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('matrix_form=[\n')
        level += 1
        for matrix_form_ in self.matrix_form:
            showIndent(outfile, level)
            outfile.write('model_.matrix_form(\n')
            matrix_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vector_form=[\n')
        level += 1
        for vector_form_ in self.vector_form:
            showIndent(outfile, level)
            outfile.write('model_.vector_form(\n')
            vector_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('essential_form=[\n')
        level += 1
        for essential_form_ in self.essential_form:
            showIndent(outfile, level)
            outfile.write('model_.essential_form(\n')
            essential_form_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'matrix_form':
            obj_ = matrix_form.factory()
            obj_.build(child_)
            self.matrix_form.append(obj_)
        elif nodeName_ == 'vector_form':
            obj_ = vector_form.factory()
            obj_.build(child_)
            self.vector_form.append(obj_)
        elif nodeName_ == 'essential_form':
            obj_ = essential_form.factory()
            obj_.build(child_)
            self.essential_form.append(obj_)
# end class boundary


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'module'
        rootClass = module
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'module'
        rootClass = module
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="module",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'module'
        rootClass = module
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from module_xml import *\n\n')
##     sys.stdout.write('import module_xml as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "analyses",
    "analysis",
    "boundary",
    "constant",
    "constants",
    "default",
    "essential_form",
    "expression",
    "general",
    "group",
    "gui",
    "localvariable",
    "localvariables",
    "macro",
    "macros",
    "matrix_form",
    "module",
    "postprocessor",
    "preprocessor",
    "quantity",
    "scalar_view",
    "surface",
    "surfaceintegral",
    "surfaceintegrals",
    "vector_form",
    "vector_view",
    "view",
    "volume",
    "volumeintegral",
    "volumeintegrals",
    "weakform_surface",
    "weakform_volume",
    "weakforms_surface",
    "weakforms_volume"
    ]
