// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "problem_a2d_31_xml.h"

namespace XMLProblem
{
  // document
  // 

  const document::geometry_type& document::
  geometry () const
  {
    return this->geometry_.get ();
  }

  document::geometry_type& document::
  geometry ()
  {
    return this->geometry_.get ();
  }

  void document::
  geometry (const geometry_type& x)
  {
    this->geometry_.set (x);
  }

  void document::
  geometry (::std::auto_ptr< geometry_type > x)
  {
    this->geometry_.set (x);
  }

  const document::problem_type& document::
  problem () const
  {
    return this->problem_.get ();
  }

  document::problem_type& document::
  problem ()
  {
    return this->problem_.get ();
  }

  void document::
  problem (const problem_type& x)
  {
    this->problem_.set (x);
  }

  void document::
  problem (::std::auto_ptr< problem_type > x)
  {
    this->problem_.set (x);
  }

  const document::config_type& document::
  config () const
  {
    return this->config_.get ();
  }

  document::config_type& document::
  config ()
  {
    return this->config_.get ();
  }

  void document::
  config (const config_type& x)
  {
    this->config_.set (x);
  }

  void document::
  config (::std::auto_ptr< config_type > x)
  {
    this->config_.set (x);
  }

  const document::version_type& document::
  version () const
  {
    return this->version_.get ();
  }

  document::version_type& document::
  version ()
  {
    return this->version_.get ();
  }

  void document::
  version (const version_type& x)
  {
    this->version_.set (x);
  }


  // geometry
  // 

  const geometry::nodes_type& geometry::
  nodes () const
  {
    return this->nodes_.get ();
  }

  geometry::nodes_type& geometry::
  nodes ()
  {
    return this->nodes_.get ();
  }

  void geometry::
  nodes (const nodes_type& x)
  {
    this->nodes_.set (x);
  }

  void geometry::
  nodes (::std::auto_ptr< nodes_type > x)
  {
    this->nodes_.set (x);
  }

  const geometry::edges_type& geometry::
  edges () const
  {
    return this->edges_.get ();
  }

  geometry::edges_type& geometry::
  edges ()
  {
    return this->edges_.get ();
  }

  void geometry::
  edges (const edges_type& x)
  {
    this->edges_.set (x);
  }

  void geometry::
  edges (::std::auto_ptr< edges_type > x)
  {
    this->edges_.set (x);
  }

  const geometry::labels_type& geometry::
  labels () const
  {
    return this->labels_.get ();
  }

  geometry::labels_type& geometry::
  labels ()
  {
    return this->labels_.get ();
  }

  void geometry::
  labels (const labels_type& x)
  {
    this->labels_.set (x);
  }

  void geometry::
  labels (::std::auto_ptr< labels_type > x)
  {
    this->labels_.set (x);
  }


  // problem
  // 

  const problem::fields_type& problem::
  fields () const
  {
    return this->fields_.get ();
  }

  problem::fields_type& problem::
  fields ()
  {
    return this->fields_.get ();
  }

  void problem::
  fields (const fields_type& x)
  {
    this->fields_.set (x);
  }

  void problem::
  fields (::std::auto_ptr< fields_type > x)
  {
    this->fields_.set (x);
  }

  const problem::couplings_type& problem::
  couplings () const
  {
    return this->couplings_.get ();
  }

  problem::couplings_type& problem::
  couplings ()
  {
    return this->couplings_.get ();
  }

  void problem::
  couplings (const couplings_type& x)
  {
    this->couplings_.set (x);
  }

  void problem::
  couplings (::std::auto_ptr< couplings_type > x)
  {
    this->couplings_.set (x);
  }

  const problem::problem_config_type& problem::
  problem_config () const
  {
    return this->problem_config_.get ();
  }

  problem::problem_config_type& problem::
  problem_config ()
  {
    return this->problem_config_.get ();
  }

  void problem::
  problem_config (const problem_config_type& x)
  {
    this->problem_config_.set (x);
  }

  void problem::
  problem_config (::std::auto_ptr< problem_config_type > x)
  {
    this->problem_config_.set (x);
  }

  const problem::coordinate_type_type& problem::
  coordinate_type () const
  {
    return this->coordinate_type_.get ();
  }

  problem::coordinate_type_type& problem::
  coordinate_type ()
  {
    return this->coordinate_type_.get ();
  }

  void problem::
  coordinate_type (const coordinate_type_type& x)
  {
    this->coordinate_type_.set (x);
  }

  void problem::
  coordinate_type (::std::auto_ptr< coordinate_type_type > x)
  {
    this->coordinate_type_.set (x);
  }

  const problem::mesh_type_type& problem::
  mesh_type () const
  {
    return this->mesh_type_.get ();
  }

  problem::mesh_type_type& problem::
  mesh_type ()
  {
    return this->mesh_type_.get ();
  }

  void problem::
  mesh_type (const mesh_type_type& x)
  {
    this->mesh_type_.set (x);
  }

  void problem::
  mesh_type (::std::auto_ptr< mesh_type_type > x)
  {
    this->mesh_type_.set (x);
  }

  const problem::matrix_solver_type& problem::
  matrix_solver () const
  {
    return this->matrix_solver_.get ();
  }

  problem::matrix_solver_type& problem::
  matrix_solver ()
  {
    return this->matrix_solver_.get ();
  }

  void problem::
  matrix_solver (const matrix_solver_type& x)
  {
    this->matrix_solver_.set (x);
  }

  void problem::
  matrix_solver (::std::auto_ptr< matrix_solver_type > x)
  {
    this->matrix_solver_.set (x);
  }


  // config
  // 

  const config::item_sequence& config::
  item () const
  {
    return this->item_;
  }

  config::item_sequence& config::
  item ()
  {
    return this->item_;
  }

  void config::
  item (const item_sequence& s)
  {
    this->item_ = s;
  }


  // nodes
  // 

  const nodes::node_sequence& nodes::
  node () const
  {
    return this->node_;
  }

  nodes::node_sequence& nodes::
  node ()
  {
    return this->node_;
  }

  void nodes::
  node (const node_sequence& s)
  {
    this->node_ = s;
  }


  // edges
  // 

  const edges::edge_sequence& edges::
  edge () const
  {
    return this->edge_;
  }

  edges::edge_sequence& edges::
  edge ()
  {
    return this->edge_;
  }

  void edges::
  edge (const edge_sequence& s)
  {
    this->edge_ = s;
  }


  // labels
  // 

  const labels::label_sequence& labels::
  label () const
  {
    return this->label_;
  }

  labels::label_sequence& labels::
  label ()
  {
    return this->label_;
  }

  void labels::
  label (const label_sequence& s)
  {
    this->label_ = s;
  }


  // fields
  // 

  const fields::field_sequence& fields::
  field () const
  {
    return this->field_;
  }

  fields::field_sequence& fields::
  field ()
  {
    return this->field_;
  }

  void fields::
  field (const field_sequence& s)
  {
    this->field_ = s;
  }


  // couplings
  // 

  const couplings::coupling_sequence& couplings::
  coupling () const
  {
    return this->coupling_;
  }

  couplings::coupling_sequence& couplings::
  coupling ()
  {
    return this->coupling_;
  }

  void couplings::
  coupling (const coupling_sequence& s)
  {
    this->coupling_ = s;
  }


  // problem_config
  // 

  const problem_config::problem_item_sequence& problem_config::
  problem_item () const
  {
    return this->problem_item_;
  }

  problem_config::problem_item_sequence& problem_config::
  problem_item ()
  {
    return this->problem_item_;
  }

  void problem_config::
  problem_item (const problem_item_sequence& s)
  {
    this->problem_item_ = s;
  }


  // item
  // 

  const item::key_type& item::
  key () const
  {
    return this->key_.get ();
  }

  item::key_type& item::
  key ()
  {
    return this->key_.get ();
  }

  void item::
  key (const key_type& x)
  {
    this->key_.set (x);
  }

  void item::
  key (::std::auto_ptr< key_type > x)
  {
    this->key_.set (x);
  }

  const item::value_type& item::
  value () const
  {
    return this->value_.get ();
  }

  item::value_type& item::
  value ()
  {
    return this->value_.get ();
  }

  void item::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void item::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // node
  // 

  const node::id_type& node::
  id () const
  {
    return this->id_.get ();
  }

  node::id_type& node::
  id ()
  {
    return this->id_.get ();
  }

  void node::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  const node::x_type& node::
  x () const
  {
    return this->x_.get ();
  }

  node::x_type& node::
  x ()
  {
    return this->x_.get ();
  }

  void node::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const node::y_type& node::
  y () const
  {
    return this->y_.get ();
  }

  node::y_type& node::
  y ()
  {
    return this->y_.get ();
  }

  void node::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // edge
  // 

  const edge::id_type& edge::
  id () const
  {
    return this->id_.get ();
  }

  edge::id_type& edge::
  id ()
  {
    return this->id_.get ();
  }

  void edge::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  const edge::start_type& edge::
  start () const
  {
    return this->start_.get ();
  }

  edge::start_type& edge::
  start ()
  {
    return this->start_.get ();
  }

  void edge::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  const edge::end_type& edge::
  end () const
  {
    return this->end_.get ();
  }

  edge::end_type& edge::
  end ()
  {
    return this->end_.get ();
  }

  void edge::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  const edge::angle_type& edge::
  angle () const
  {
    return this->angle_.get ();
  }

  edge::angle_type& edge::
  angle ()
  {
    return this->angle_.get ();
  }

  void edge::
  angle (const angle_type& x)
  {
    this->angle_.set (x);
  }


  // label
  // 

  const label::id_type& label::
  id () const
  {
    return this->id_.get ();
  }

  label::id_type& label::
  id ()
  {
    return this->id_.get ();
  }

  void label::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  const label::x_type& label::
  x () const
  {
    return this->x_.get ();
  }

  label::x_type& label::
  x ()
  {
    return this->x_.get ();
  }

  void label::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const label::y_type& label::
  y () const
  {
    return this->y_.get ();
  }

  label::y_type& label::
  y ()
  {
    return this->y_.get ();
  }

  void label::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const label::area_type& label::
  area () const
  {
    return this->area_.get ();
  }

  label::area_type& label::
  area ()
  {
    return this->area_.get ();
  }

  void label::
  area (const area_type& x)
  {
    this->area_.set (x);
  }


  // field
  // 

  const field::refinement_edges_type& field::
  refinement_edges () const
  {
    return this->refinement_edges_.get ();
  }

  field::refinement_edges_type& field::
  refinement_edges ()
  {
    return this->refinement_edges_.get ();
  }

  void field::
  refinement_edges (const refinement_edges_type& x)
  {
    this->refinement_edges_.set (x);
  }

  void field::
  refinement_edges (::std::auto_ptr< refinement_edges_type > x)
  {
    this->refinement_edges_.set (x);
  }

  const field::refinement_labels_type& field::
  refinement_labels () const
  {
    return this->refinement_labels_.get ();
  }

  field::refinement_labels_type& field::
  refinement_labels ()
  {
    return this->refinement_labels_.get ();
  }

  void field::
  refinement_labels (const refinement_labels_type& x)
  {
    this->refinement_labels_.set (x);
  }

  void field::
  refinement_labels (::std::auto_ptr< refinement_labels_type > x)
  {
    this->refinement_labels_.set (x);
  }

  const field::polynomial_orders_type& field::
  polynomial_orders () const
  {
    return this->polynomial_orders_.get ();
  }

  field::polynomial_orders_type& field::
  polynomial_orders ()
  {
    return this->polynomial_orders_.get ();
  }

  void field::
  polynomial_orders (const polynomial_orders_type& x)
  {
    this->polynomial_orders_.set (x);
  }

  void field::
  polynomial_orders (::std::auto_ptr< polynomial_orders_type > x)
  {
    this->polynomial_orders_.set (x);
  }

  const field::boundaries_type& field::
  boundaries () const
  {
    return this->boundaries_.get ();
  }

  field::boundaries_type& field::
  boundaries ()
  {
    return this->boundaries_.get ();
  }

  void field::
  boundaries (const boundaries_type& x)
  {
    this->boundaries_.set (x);
  }

  void field::
  boundaries (::std::auto_ptr< boundaries_type > x)
  {
    this->boundaries_.set (x);
  }

  const field::materials_type& field::
  materials () const
  {
    return this->materials_.get ();
  }

  field::materials_type& field::
  materials ()
  {
    return this->materials_.get ();
  }

  void field::
  materials (const materials_type& x)
  {
    this->materials_.set (x);
  }

  void field::
  materials (::std::auto_ptr< materials_type > x)
  {
    this->materials_.set (x);
  }

  const field::field_config_type& field::
  field_config () const
  {
    return this->field_config_.get ();
  }

  field::field_config_type& field::
  field_config ()
  {
    return this->field_config_.get ();
  }

  void field::
  field_config (const field_config_type& x)
  {
    this->field_config_.set (x);
  }

  void field::
  field_config (::std::auto_ptr< field_config_type > x)
  {
    this->field_config_.set (x);
  }

  const field::field_id_type& field::
  field_id () const
  {
    return this->field_id_.get ();
  }

  field::field_id_type& field::
  field_id ()
  {
    return this->field_id_.get ();
  }

  void field::
  field_id (const field_id_type& x)
  {
    this->field_id_.set (x);
  }

  void field::
  field_id (::std::auto_ptr< field_id_type > x)
  {
    this->field_id_.set (x);
  }

  const field::analysis_type_type& field::
  analysis_type () const
  {
    return this->analysis_type_.get ();
  }

  field::analysis_type_type& field::
  analysis_type ()
  {
    return this->analysis_type_.get ();
  }

  void field::
  analysis_type (const analysis_type_type& x)
  {
    this->analysis_type_.set (x);
  }

  void field::
  analysis_type (::std::auto_ptr< analysis_type_type > x)
  {
    this->analysis_type_.set (x);
  }

  const field::adaptivity_type_type& field::
  adaptivity_type () const
  {
    return this->adaptivity_type_.get ();
  }

  field::adaptivity_type_type& field::
  adaptivity_type ()
  {
    return this->adaptivity_type_.get ();
  }

  void field::
  adaptivity_type (const adaptivity_type_type& x)
  {
    this->adaptivity_type_.set (x);
  }

  void field::
  adaptivity_type (::std::auto_ptr< adaptivity_type_type > x)
  {
    this->adaptivity_type_.set (x);
  }

  const field::linearity_type_type& field::
  linearity_type () const
  {
    return this->linearity_type_.get ();
  }

  field::linearity_type_type& field::
  linearity_type ()
  {
    return this->linearity_type_.get ();
  }

  void field::
  linearity_type (const linearity_type_type& x)
  {
    this->linearity_type_.set (x);
  }

  void field::
  linearity_type (::std::auto_ptr< linearity_type_type > x)
  {
    this->linearity_type_.set (x);
  }


  // coupling
  // 

  const coupling::id_type& coupling::
  id () const
  {
    return this->id_.get ();
  }

  coupling::id_type& coupling::
  id ()
  {
    return this->id_.get ();
  }

  void coupling::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void coupling::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const coupling::type_type& coupling::
  type () const
  {
    return this->type_.get ();
  }

  coupling::type_type& coupling::
  type ()
  {
    return this->type_.get ();
  }

  void coupling::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void coupling::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const coupling::source_fieldid_type& coupling::
  source_fieldid () const
  {
    return this->source_fieldid_.get ();
  }

  coupling::source_fieldid_type& coupling::
  source_fieldid ()
  {
    return this->source_fieldid_.get ();
  }

  void coupling::
  source_fieldid (const source_fieldid_type& x)
  {
    this->source_fieldid_.set (x);
  }

  void coupling::
  source_fieldid (::std::auto_ptr< source_fieldid_type > x)
  {
    this->source_fieldid_.set (x);
  }

  const coupling::target_fieldid_type& coupling::
  target_fieldid () const
  {
    return this->target_fieldid_.get ();
  }

  coupling::target_fieldid_type& coupling::
  target_fieldid ()
  {
    return this->target_fieldid_.get ();
  }

  void coupling::
  target_fieldid (const target_fieldid_type& x)
  {
    this->target_fieldid_.set (x);
  }

  void coupling::
  target_fieldid (::std::auto_ptr< target_fieldid_type > x)
  {
    this->target_fieldid_.set (x);
  }


  // problem_item
  // 

  const problem_item::problem_key_type& problem_item::
  problem_key () const
  {
    return this->problem_key_.get ();
  }

  problem_item::problem_key_type& problem_item::
  problem_key ()
  {
    return this->problem_key_.get ();
  }

  void problem_item::
  problem_key (const problem_key_type& x)
  {
    this->problem_key_.set (x);
  }

  void problem_item::
  problem_key (::std::auto_ptr< problem_key_type > x)
  {
    this->problem_key_.set (x);
  }

  const problem_item::problem_value_type& problem_item::
  problem_value () const
  {
    return this->problem_value_.get ();
  }

  problem_item::problem_value_type& problem_item::
  problem_value ()
  {
    return this->problem_value_.get ();
  }

  void problem_item::
  problem_value (const problem_value_type& x)
  {
    this->problem_value_.set (x);
  }

  void problem_item::
  problem_value (::std::auto_ptr< problem_value_type > x)
  {
    this->problem_value_.set (x);
  }


  // refinement_edges
  // 

  const refinement_edges::refinement_edge_sequence& refinement_edges::
  refinement_edge () const
  {
    return this->refinement_edge_;
  }

  refinement_edges::refinement_edge_sequence& refinement_edges::
  refinement_edge ()
  {
    return this->refinement_edge_;
  }

  void refinement_edges::
  refinement_edge (const refinement_edge_sequence& s)
  {
    this->refinement_edge_ = s;
  }


  // refinement_labels
  // 

  const refinement_labels::refinement_label_sequence& refinement_labels::
  refinement_label () const
  {
    return this->refinement_label_;
  }

  refinement_labels::refinement_label_sequence& refinement_labels::
  refinement_label ()
  {
    return this->refinement_label_;
  }

  void refinement_labels::
  refinement_label (const refinement_label_sequence& s)
  {
    this->refinement_label_ = s;
  }


  // polynomial_orders
  // 

  const polynomial_orders::polynomial_order_sequence& polynomial_orders::
  polynomial_order () const
  {
    return this->polynomial_order_;
  }

  polynomial_orders::polynomial_order_sequence& polynomial_orders::
  polynomial_order ()
  {
    return this->polynomial_order_;
  }

  void polynomial_orders::
  polynomial_order (const polynomial_order_sequence& s)
  {
    this->polynomial_order_ = s;
  }


  // boundaries
  // 

  const boundaries::boundary_sequence& boundaries::
  boundary () const
  {
    return this->boundary_;
  }

  boundaries::boundary_sequence& boundaries::
  boundary ()
  {
    return this->boundary_;
  }

  void boundaries::
  boundary (const boundary_sequence& s)
  {
    this->boundary_ = s;
  }


  // materials
  // 

  const materials::material_sequence& materials::
  material () const
  {
    return this->material_;
  }

  materials::material_sequence& materials::
  material ()
  {
    return this->material_;
  }

  void materials::
  material (const material_sequence& s)
  {
    this->material_ = s;
  }


  // field_config
  // 

  const field_config::field_item_sequence& field_config::
  field_item () const
  {
    return this->field_item_;
  }

  field_config::field_item_sequence& field_config::
  field_item ()
  {
    return this->field_item_;
  }

  void field_config::
  field_item (const field_item_sequence& s)
  {
    this->field_item_ = s;
  }


  // refinement_edge
  // 

  const refinement_edge::refinement_edge_id_type& refinement_edge::
  refinement_edge_id () const
  {
    return this->refinement_edge_id_.get ();
  }

  refinement_edge::refinement_edge_id_type& refinement_edge::
  refinement_edge_id ()
  {
    return this->refinement_edge_id_.get ();
  }

  void refinement_edge::
  refinement_edge_id (const refinement_edge_id_type& x)
  {
    this->refinement_edge_id_.set (x);
  }

  const refinement_edge::refinement_edge_number_type& refinement_edge::
  refinement_edge_number () const
  {
    return this->refinement_edge_number_.get ();
  }

  refinement_edge::refinement_edge_number_type& refinement_edge::
  refinement_edge_number ()
  {
    return this->refinement_edge_number_.get ();
  }

  void refinement_edge::
  refinement_edge_number (const refinement_edge_number_type& x)
  {
    this->refinement_edge_number_.set (x);
  }


  // refinement_label
  // 

  const refinement_label::refinement_label_id_type& refinement_label::
  refinement_label_id () const
  {
    return this->refinement_label_id_.get ();
  }

  refinement_label::refinement_label_id_type& refinement_label::
  refinement_label_id ()
  {
    return this->refinement_label_id_.get ();
  }

  void refinement_label::
  refinement_label_id (const refinement_label_id_type& x)
  {
    this->refinement_label_id_.set (x);
  }

  const refinement_label::refinement_label_number_type& refinement_label::
  refinement_label_number () const
  {
    return this->refinement_label_number_.get ();
  }

  refinement_label::refinement_label_number_type& refinement_label::
  refinement_label_number ()
  {
    return this->refinement_label_number_.get ();
  }

  void refinement_label::
  refinement_label_number (const refinement_label_number_type& x)
  {
    this->refinement_label_number_.set (x);
  }


  // polynomial_order
  // 

  const polynomial_order::polynomial_order_id_type& polynomial_order::
  polynomial_order_id () const
  {
    return this->polynomial_order_id_.get ();
  }

  polynomial_order::polynomial_order_id_type& polynomial_order::
  polynomial_order_id ()
  {
    return this->polynomial_order_id_.get ();
  }

  void polynomial_order::
  polynomial_order_id (const polynomial_order_id_type& x)
  {
    this->polynomial_order_id_.set (x);
  }

  const polynomial_order::polynomial_order_number_type& polynomial_order::
  polynomial_order_number () const
  {
    return this->polynomial_order_number_.get ();
  }

  polynomial_order::polynomial_order_number_type& polynomial_order::
  polynomial_order_number ()
  {
    return this->polynomial_order_number_.get ();
  }

  void polynomial_order::
  polynomial_order_number (const polynomial_order_number_type& x)
  {
    this->polynomial_order_number_.set (x);
  }


  // boundary
  // 

  const boundary::boundary_edges_type& boundary::
  boundary_edges () const
  {
    return this->boundary_edges_.get ();
  }

  boundary::boundary_edges_type& boundary::
  boundary_edges ()
  {
    return this->boundary_edges_.get ();
  }

  void boundary::
  boundary_edges (const boundary_edges_type& x)
  {
    this->boundary_edges_.set (x);
  }

  void boundary::
  boundary_edges (::std::auto_ptr< boundary_edges_type > x)
  {
    this->boundary_edges_.set (x);
  }

  const boundary::boundary_types_type& boundary::
  boundary_types () const
  {
    return this->boundary_types_.get ();
  }

  boundary::boundary_types_type& boundary::
  boundary_types ()
  {
    return this->boundary_types_.get ();
  }

  void boundary::
  boundary_types (const boundary_types_type& x)
  {
    this->boundary_types_.set (x);
  }

  void boundary::
  boundary_types (::std::auto_ptr< boundary_types_type > x)
  {
    this->boundary_types_.set (x);
  }

  const boundary::type_type& boundary::
  type () const
  {
    return this->type_.get ();
  }

  boundary::type_type& boundary::
  type ()
  {
    return this->type_.get ();
  }

  void boundary::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void boundary::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const boundary::id_type& boundary::
  id () const
  {
    return this->id_.get ();
  }

  boundary::id_type& boundary::
  id ()
  {
    return this->id_.get ();
  }

  void boundary::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  const boundary::name_type& boundary::
  name () const
  {
    return this->name_.get ();
  }

  boundary::name_type& boundary::
  name ()
  {
    return this->name_.get ();
  }

  void boundary::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void boundary::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // material
  // 

  const material::material_labels_type& material::
  material_labels () const
  {
    return this->material_labels_.get ();
  }

  material::material_labels_type& material::
  material_labels ()
  {
    return this->material_labels_.get ();
  }

  void material::
  material_labels (const material_labels_type& x)
  {
    this->material_labels_.set (x);
  }

  void material::
  material_labels (::std::auto_ptr< material_labels_type > x)
  {
    this->material_labels_.set (x);
  }

  const material::material_types_type& material::
  material_types () const
  {
    return this->material_types_.get ();
  }

  material::material_types_type& material::
  material_types ()
  {
    return this->material_types_.get ();
  }

  void material::
  material_types (const material_types_type& x)
  {
    this->material_types_.set (x);
  }

  void material::
  material_types (::std::auto_ptr< material_types_type > x)
  {
    this->material_types_.set (x);
  }

  const material::id_type& material::
  id () const
  {
    return this->id_.get ();
  }

  material::id_type& material::
  id ()
  {
    return this->id_.get ();
  }

  void material::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  const material::name_type& material::
  name () const
  {
    return this->name_.get ();
  }

  material::name_type& material::
  name ()
  {
    return this->name_.get ();
  }

  void material::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void material::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // field_item
  // 

  const field_item::field_key_type& field_item::
  field_key () const
  {
    return this->field_key_.get ();
  }

  field_item::field_key_type& field_item::
  field_key ()
  {
    return this->field_key_.get ();
  }

  void field_item::
  field_key (const field_key_type& x)
  {
    this->field_key_.set (x);
  }

  void field_item::
  field_key (::std::auto_ptr< field_key_type > x)
  {
    this->field_key_.set (x);
  }

  const field_item::field_value_type& field_item::
  field_value () const
  {
    return this->field_value_.get ();
  }

  field_item::field_value_type& field_item::
  field_value ()
  {
    return this->field_value_.get ();
  }

  void field_item::
  field_value (const field_value_type& x)
  {
    this->field_value_.set (x);
  }

  void field_item::
  field_value (::std::auto_ptr< field_value_type > x)
  {
    this->field_value_.set (x);
  }


  // boundary_edges
  // 

  const boundary_edges::boundary_edge_sequence& boundary_edges::
  boundary_edge () const
  {
    return this->boundary_edge_;
  }

  boundary_edges::boundary_edge_sequence& boundary_edges::
  boundary_edge ()
  {
    return this->boundary_edge_;
  }

  void boundary_edges::
  boundary_edge (const boundary_edge_sequence& s)
  {
    this->boundary_edge_ = s;
  }


  // boundary_types
  // 

  const boundary_types::boundary_type_sequence& boundary_types::
  boundary_type () const
  {
    return this->boundary_type_;
  }

  boundary_types::boundary_type_sequence& boundary_types::
  boundary_type ()
  {
    return this->boundary_type_;
  }

  void boundary_types::
  boundary_type (const boundary_type_sequence& s)
  {
    this->boundary_type_ = s;
  }


  // material_labels
  // 

  const material_labels::material_label_sequence& material_labels::
  material_label () const
  {
    return this->material_label_;
  }

  material_labels::material_label_sequence& material_labels::
  material_label ()
  {
    return this->material_label_;
  }

  void material_labels::
  material_label (const material_label_sequence& s)
  {
    this->material_label_ = s;
  }


  // material_types
  // 

  const material_types::material_type_sequence& material_types::
  material_type () const
  {
    return this->material_type_;
  }

  material_types::material_type_sequence& material_types::
  material_type ()
  {
    return this->material_type_;
  }

  void material_types::
  material_type (const material_type_sequence& s)
  {
    this->material_type_ = s;
  }


  // boundary_edge
  // 

  const boundary_edge::id_type& boundary_edge::
  id () const
  {
    return this->id_.get ();
  }

  boundary_edge::id_type& boundary_edge::
  id ()
  {
    return this->id_.get ();
  }

  void boundary_edge::
  id (const id_type& x)
  {
    this->id_.set (x);
  }


  // boundary_type
  // 

  const boundary_type::key_type& boundary_type::
  key () const
  {
    return this->key_.get ();
  }

  boundary_type::key_type& boundary_type::
  key ()
  {
    return this->key_.get ();
  }

  void boundary_type::
  key (const key_type& x)
  {
    this->key_.set (x);
  }

  void boundary_type::
  key (::std::auto_ptr< key_type > x)
  {
    this->key_.set (x);
  }

  const boundary_type::value_type& boundary_type::
  value () const
  {
    return this->value_.get ();
  }

  boundary_type::value_type& boundary_type::
  value ()
  {
    return this->value_.get ();
  }

  void boundary_type::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void boundary_type::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // material_label
  // 

  const material_label::id_type& material_label::
  id () const
  {
    return this->id_.get ();
  }

  material_label::id_type& material_label::
  id ()
  {
    return this->id_.get ();
  }

  void material_label::
  id (const id_type& x)
  {
    this->id_.set (x);
  }


  // material_type
  // 

  const material_type::key_type& material_type::
  key () const
  {
    return this->key_.get ();
  }

  material_type::key_type& material_type::
  key ()
  {
    return this->key_.get ();
  }

  void material_type::
  key (const key_type& x)
  {
    this->key_.set (x);
  }

  void material_type::
  key (::std::auto_ptr< key_type > x)
  {
    this->key_.set (x);
  }

  const material_type::value_type& material_type::
  value () const
  {
    return this->value_.get ();
  }

  material_type::value_type& material_type::
  value ()
  {
    return this->value_.get ();
  }

  void material_type::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void material_type::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace XMLProblem
{
  // document
  //

  document::
  document (const geometry_type& geometry,
            const problem_type& problem,
            const config_type& config,
            const version_type& version)
  : ::xml_schema::type (),
    geometry_ (geometry, ::xml_schema::flags (), this),
    problem_ (problem, ::xml_schema::flags (), this),
    config_ (config, ::xml_schema::flags (), this),
    version_ (version, ::xml_schema::flags (), this)
  {
  }

  document::
  document (::std::auto_ptr< geometry_type >& geometry,
            ::std::auto_ptr< problem_type >& problem,
            ::std::auto_ptr< config_type >& config,
            const version_type& version)
  : ::xml_schema::type (),
    geometry_ (geometry, ::xml_schema::flags (), this),
    problem_ (problem, ::xml_schema::flags (), this),
    config_ (config, ::xml_schema::flags (), this),
    version_ (version, ::xml_schema::flags (), this)
  {
  }

  document::
  document (const document& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    geometry_ (x.geometry_, f, this),
    problem_ (x.problem_, f, this),
    config_ (x.config_, f, this),
    version_ (x.version_, f, this)
  {
  }

  document::
  document (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    geometry_ (f, this),
    problem_ (f, this),
    config_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void document::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // geometry
      //
      if (n.name () == "geometry" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< geometry_type > r (
          geometry_traits::create (i, f, this));

        if (!geometry_.present ())
        {
          this->geometry_.set (r);
          continue;
        }
      }

      // problem
      //
      if (n.name () == "problem" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< problem_type > r (
          problem_traits::create (i, f, this));

        if (!problem_.present ())
        {
          this->problem_.set (r);
          continue;
        }
      }

      // config
      //
      if (n.name () == "config" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< config_type > r (
          config_traits::create (i, f, this));

        if (!config_.present ())
        {
          this->config_.set (r);
          continue;
        }
      }

      break;
    }

    if (!geometry_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "geometry",
        "");
    }

    if (!problem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "problem",
        "");
    }

    if (!config_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "config",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  document* document::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class document (*this, f, c);
  }

  document::
  ~document ()
  {
  }

  // geometry
  //

  geometry::
  geometry (const nodes_type& nodes,
            const edges_type& edges,
            const labels_type& labels)
  : ::xml_schema::type (),
    nodes_ (nodes, ::xml_schema::flags (), this),
    edges_ (edges, ::xml_schema::flags (), this),
    labels_ (labels, ::xml_schema::flags (), this)
  {
  }

  geometry::
  geometry (::std::auto_ptr< nodes_type >& nodes,
            ::std::auto_ptr< edges_type >& edges,
            ::std::auto_ptr< labels_type >& labels)
  : ::xml_schema::type (),
    nodes_ (nodes, ::xml_schema::flags (), this),
    edges_ (edges, ::xml_schema::flags (), this),
    labels_ (labels, ::xml_schema::flags (), this)
  {
  }

  geometry::
  geometry (const geometry& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    nodes_ (x.nodes_, f, this),
    edges_ (x.edges_, f, this),
    labels_ (x.labels_, f, this)
  {
  }

  geometry::
  geometry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    nodes_ (f, this),
    edges_ (f, this),
    labels_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void geometry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nodes
      //
      if (n.name () == "nodes" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< nodes_type > r (
          nodes_traits::create (i, f, this));

        if (!nodes_.present ())
        {
          this->nodes_.set (r);
          continue;
        }
      }

      // edges
      //
      if (n.name () == "edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< edges_type > r (
          edges_traits::create (i, f, this));

        if (!edges_.present ())
        {
          this->edges_.set (r);
          continue;
        }
      }

      // labels
      //
      if (n.name () == "labels" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< labels_type > r (
          labels_traits::create (i, f, this));

        if (!labels_.present ())
        {
          this->labels_.set (r);
          continue;
        }
      }

      break;
    }

    if (!nodes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodes",
        "");
    }

    if (!edges_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "edges",
        "");
    }

    if (!labels_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "labels",
        "");
    }
  }

  geometry* geometry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class geometry (*this, f, c);
  }

  geometry::
  ~geometry ()
  {
  }

  // problem
  //

  problem::
  problem (const fields_type& fields,
           const couplings_type& couplings,
           const problem_config_type& problem_config,
           const coordinate_type_type& coordinate_type,
           const mesh_type_type& mesh_type,
           const matrix_solver_type& matrix_solver)
  : ::xml_schema::type (),
    fields_ (fields, ::xml_schema::flags (), this),
    couplings_ (couplings, ::xml_schema::flags (), this),
    problem_config_ (problem_config, ::xml_schema::flags (), this),
    coordinate_type_ (coordinate_type, ::xml_schema::flags (), this),
    mesh_type_ (mesh_type, ::xml_schema::flags (), this),
    matrix_solver_ (matrix_solver, ::xml_schema::flags (), this)
  {
  }

  problem::
  problem (::std::auto_ptr< fields_type >& fields,
           ::std::auto_ptr< couplings_type >& couplings,
           ::std::auto_ptr< problem_config_type >& problem_config,
           const coordinate_type_type& coordinate_type,
           const mesh_type_type& mesh_type,
           const matrix_solver_type& matrix_solver)
  : ::xml_schema::type (),
    fields_ (fields, ::xml_schema::flags (), this),
    couplings_ (couplings, ::xml_schema::flags (), this),
    problem_config_ (problem_config, ::xml_schema::flags (), this),
    coordinate_type_ (coordinate_type, ::xml_schema::flags (), this),
    mesh_type_ (mesh_type, ::xml_schema::flags (), this),
    matrix_solver_ (matrix_solver, ::xml_schema::flags (), this)
  {
  }

  problem::
  problem (const problem& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fields_ (x.fields_, f, this),
    couplings_ (x.couplings_, f, this),
    problem_config_ (x.problem_config_, f, this),
    coordinate_type_ (x.coordinate_type_, f, this),
    mesh_type_ (x.mesh_type_, f, this),
    matrix_solver_ (x.matrix_solver_, f, this)
  {
  }

  problem::
  problem (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fields_ (f, this),
    couplings_ (f, this),
    problem_config_ (f, this),
    coordinate_type_ (f, this),
    mesh_type_ (f, this),
    matrix_solver_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void problem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // fields
      //
      if (n.name () == "fields" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< fields_type > r (
          fields_traits::create (i, f, this));

        if (!fields_.present ())
        {
          this->fields_.set (r);
          continue;
        }
      }

      // couplings
      //
      if (n.name () == "couplings" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< couplings_type > r (
          couplings_traits::create (i, f, this));

        if (!couplings_.present ())
        {
          this->couplings_.set (r);
          continue;
        }
      }

      // problem_config
      //
      if (n.name () == "problem_config" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< problem_config_type > r (
          problem_config_traits::create (i, f, this));

        if (!problem_config_.present ())
        {
          this->problem_config_.set (r);
          continue;
        }
      }

      break;
    }

    if (!fields_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "fields",
        "");
    }

    if (!couplings_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "couplings",
        "");
    }

    if (!problem_config_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "problem_config",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "coordinate_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< coordinate_type_type > r (
          coordinate_type_traits::create (i, f, this));

        this->coordinate_type_.set (r);
        continue;
      }

      if (n.name () == "mesh_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< mesh_type_type > r (
          mesh_type_traits::create (i, f, this));

        this->mesh_type_.set (r);
        continue;
      }

      if (n.name () == "matrix_solver" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< matrix_solver_type > r (
          matrix_solver_traits::create (i, f, this));

        this->matrix_solver_.set (r);
        continue;
      }
    }

    if (!coordinate_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "coordinate_type",
        "");
    }

    if (!mesh_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mesh_type",
        "");
    }

    if (!matrix_solver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "matrix_solver",
        "");
    }
  }

  problem* problem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class problem (*this, f, c);
  }

  problem::
  ~problem ()
  {
  }

  // config
  //

  config::
  config ()
  : ::xml_schema::type (),
    item_ (::xml_schema::flags (), this)
  {
  }

  config::
  config (const config& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    item_ (x.item_, f, this)
  {
  }

  config::
  config (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    item_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // item
      //
      if (n.name () == "item" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< item_type > r (
          item_traits::create (i, f, this));

        this->item_.push_back (r);
        continue;
      }

      break;
    }
  }

  config* config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class config (*this, f, c);
  }

  config::
  ~config ()
  {
  }

  // nodes
  //

  nodes::
  nodes ()
  : ::xml_schema::type (),
    node_ (::xml_schema::flags (), this)
  {
  }

  nodes::
  nodes (const nodes& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    node_ (x.node_, f, this)
  {
  }

  nodes::
  nodes (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    node_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void nodes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // node
      //
      if (n.name () == "node" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< node_type > r (
          node_traits::create (i, f, this));

        this->node_.push_back (r);
        continue;
      }

      break;
    }
  }

  nodes* nodes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nodes (*this, f, c);
  }

  nodes::
  ~nodes ()
  {
  }

  // edges
  //

  edges::
  edges ()
  : ::xml_schema::type (),
    edge_ (::xml_schema::flags (), this)
  {
  }

  edges::
  edges (const edges& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    edge_ (x.edge_, f, this)
  {
  }

  edges::
  edges (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    edge_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void edges::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // edge
      //
      if (n.name () == "edge" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< edge_type > r (
          edge_traits::create (i, f, this));

        this->edge_.push_back (r);
        continue;
      }

      break;
    }
  }

  edges* edges::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class edges (*this, f, c);
  }

  edges::
  ~edges ()
  {
  }

  // labels
  //

  labels::
  labels ()
  : ::xml_schema::type (),
    label_ (::xml_schema::flags (), this)
  {
  }

  labels::
  labels (const labels& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    label_ (x.label_, f, this)
  {
  }

  labels::
  labels (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    label_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void labels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // label
      //
      if (n.name () == "label" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< label_type > r (
          label_traits::create (i, f, this));

        this->label_.push_back (r);
        continue;
      }

      break;
    }
  }

  labels* labels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class labels (*this, f, c);
  }

  labels::
  ~labels ()
  {
  }

  // fields
  //

  fields::
  fields ()
  : ::xml_schema::type (),
    field_ (::xml_schema::flags (), this)
  {
  }

  fields::
  fields (const fields& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_ (x.field_, f, this)
  {
  }

  fields::
  fields (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void fields::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field
      //
      if (n.name () == "field" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_type > r (
          field_traits::create (i, f, this));

        this->field_.push_back (r);
        continue;
      }

      break;
    }
  }

  fields* fields::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fields (*this, f, c);
  }

  fields::
  ~fields ()
  {
  }

  // couplings
  //

  couplings::
  couplings ()
  : ::xml_schema::type (),
    coupling_ (::xml_schema::flags (), this)
  {
  }

  couplings::
  couplings (const couplings& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    coupling_ (x.coupling_, f, this)
  {
  }

  couplings::
  couplings (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    coupling_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void couplings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // coupling
      //
      if (n.name () == "coupling" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< coupling_type > r (
          coupling_traits::create (i, f, this));

        this->coupling_.push_back (r);
        continue;
      }

      break;
    }
  }

  couplings* couplings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class couplings (*this, f, c);
  }

  couplings::
  ~couplings ()
  {
  }

  // problem_config
  //

  problem_config::
  problem_config ()
  : ::xml_schema::type (),
    problem_item_ (::xml_schema::flags (), this)
  {
  }

  problem_config::
  problem_config (const problem_config& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    problem_item_ (x.problem_item_, f, this)
  {
  }

  problem_config::
  problem_config (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    problem_item_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void problem_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // problem_item
      //
      if (n.name () == "problem_item" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< problem_item_type > r (
          problem_item_traits::create (i, f, this));

        this->problem_item_.push_back (r);
        continue;
      }

      break;
    }
  }

  problem_config* problem_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class problem_config (*this, f, c);
  }

  problem_config::
  ~problem_config ()
  {
  }

  // item
  //

  item::
  item (const key_type& key,
        const value_type& value)
  : ::xml_schema::type (),
    key_ (key, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  item::
  item (const item& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    key_ (x.key_, f, this),
    value_ (x.value_, f, this)
  {
  }

  item::
  item (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    key_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< key_type > r (
          key_traits::create (i, f, this));

        this->key_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  item* item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class item (*this, f, c);
  }

  item::
  ~item ()
  {
  }

  // node
  //

  node::
  node (const id_type& id,
        const x_type& x,
        const y_type& y)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this)
  {
  }

  node::
  node (const node& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  node::
  node (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }
  }

  node* node::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class node (*this, f, c);
  }

  node::
  ~node ()
  {
  }

  // edge
  //

  edge::
  edge (const id_type& id,
        const start_type& start,
        const end_type& end,
        const angle_type& angle)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    start_ (start, ::xml_schema::flags (), this),
    end_ (end, ::xml_schema::flags (), this),
    angle_ (angle, ::xml_schema::flags (), this)
  {
  }

  edge::
  edge (const edge& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this),
    angle_ (x.angle_, f, this)
  {
  }

  edge::
  edge (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    start_ (f, this),
    end_ (f, this),
    angle_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void edge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start" && n.namespace_ ().empty ())
      {
        this->start_.set (start_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "end" && n.namespace_ ().empty ())
      {
        this->end_.set (end_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "angle" && n.namespace_ ().empty ())
      {
        this->angle_.set (angle_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!start_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "start",
        "");
    }

    if (!end_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "end",
        "");
    }

    if (!angle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "angle",
        "");
    }
  }

  edge* edge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class edge (*this, f, c);
  }

  edge::
  ~edge ()
  {
  }

  // label
  //

  label::
  label (const id_type& id,
         const x_type& x,
         const y_type& y,
         const area_type& area)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    area_ (area, ::xml_schema::flags (), this)
  {
  }

  label::
  label (const label& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    area_ (x.area_, f, this)
  {
  }

  label::
  label (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    x_ (f, this),
    y_ (f, this),
    area_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void label::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "area" && n.namespace_ ().empty ())
      {
        this->area_.set (area_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }

    if (!area_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "area",
        "");
    }
  }

  label* label::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class label (*this, f, c);
  }

  label::
  ~label ()
  {
  }

  // field
  //

  field::
  field (const refinement_edges_type& refinement_edges,
         const refinement_labels_type& refinement_labels,
         const polynomial_orders_type& polynomial_orders,
         const boundaries_type& boundaries,
         const materials_type& materials,
         const field_config_type& field_config,
         const field_id_type& field_id,
         const analysis_type_type& analysis_type,
         const adaptivity_type_type& adaptivity_type,
         const linearity_type_type& linearity_type)
  : ::xml_schema::type (),
    refinement_edges_ (refinement_edges, ::xml_schema::flags (), this),
    refinement_labels_ (refinement_labels, ::xml_schema::flags (), this),
    polynomial_orders_ (polynomial_orders, ::xml_schema::flags (), this),
    boundaries_ (boundaries, ::xml_schema::flags (), this),
    materials_ (materials, ::xml_schema::flags (), this),
    field_config_ (field_config, ::xml_schema::flags (), this),
    field_id_ (field_id, ::xml_schema::flags (), this),
    analysis_type_ (analysis_type, ::xml_schema::flags (), this),
    adaptivity_type_ (adaptivity_type, ::xml_schema::flags (), this),
    linearity_type_ (linearity_type, ::xml_schema::flags (), this)
  {
  }

  field::
  field (::std::auto_ptr< refinement_edges_type >& refinement_edges,
         ::std::auto_ptr< refinement_labels_type >& refinement_labels,
         ::std::auto_ptr< polynomial_orders_type >& polynomial_orders,
         ::std::auto_ptr< boundaries_type >& boundaries,
         ::std::auto_ptr< materials_type >& materials,
         ::std::auto_ptr< field_config_type >& field_config,
         const field_id_type& field_id,
         const analysis_type_type& analysis_type,
         const adaptivity_type_type& adaptivity_type,
         const linearity_type_type& linearity_type)
  : ::xml_schema::type (),
    refinement_edges_ (refinement_edges, ::xml_schema::flags (), this),
    refinement_labels_ (refinement_labels, ::xml_schema::flags (), this),
    polynomial_orders_ (polynomial_orders, ::xml_schema::flags (), this),
    boundaries_ (boundaries, ::xml_schema::flags (), this),
    materials_ (materials, ::xml_schema::flags (), this),
    field_config_ (field_config, ::xml_schema::flags (), this),
    field_id_ (field_id, ::xml_schema::flags (), this),
    analysis_type_ (analysis_type, ::xml_schema::flags (), this),
    adaptivity_type_ (adaptivity_type, ::xml_schema::flags (), this),
    linearity_type_ (linearity_type, ::xml_schema::flags (), this)
  {
  }

  field::
  field (const field& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refinement_edges_ (x.refinement_edges_, f, this),
    refinement_labels_ (x.refinement_labels_, f, this),
    polynomial_orders_ (x.polynomial_orders_, f, this),
    boundaries_ (x.boundaries_, f, this),
    materials_ (x.materials_, f, this),
    field_config_ (x.field_config_, f, this),
    field_id_ (x.field_id_, f, this),
    analysis_type_ (x.analysis_type_, f, this),
    adaptivity_type_ (x.adaptivity_type_, f, this),
    linearity_type_ (x.linearity_type_, f, this)
  {
  }

  field::
  field (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refinement_edges_ (f, this),
    refinement_labels_ (f, this),
    polynomial_orders_ (f, this),
    boundaries_ (f, this),
    materials_ (f, this),
    field_config_ (f, this),
    field_id_ (f, this),
    analysis_type_ (f, this),
    adaptivity_type_ (f, this),
    linearity_type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void field::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // refinement_edges
      //
      if (n.name () == "refinement_edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinement_edges_type > r (
          refinement_edges_traits::create (i, f, this));

        if (!refinement_edges_.present ())
        {
          this->refinement_edges_.set (r);
          continue;
        }
      }

      // refinement_labels
      //
      if (n.name () == "refinement_labels" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinement_labels_type > r (
          refinement_labels_traits::create (i, f, this));

        if (!refinement_labels_.present ())
        {
          this->refinement_labels_.set (r);
          continue;
        }
      }

      // polynomial_orders
      //
      if (n.name () == "polynomial_orders" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< polynomial_orders_type > r (
          polynomial_orders_traits::create (i, f, this));

        if (!polynomial_orders_.present ())
        {
          this->polynomial_orders_.set (r);
          continue;
        }
      }

      // boundaries
      //
      if (n.name () == "boundaries" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundaries_type > r (
          boundaries_traits::create (i, f, this));

        if (!boundaries_.present ())
        {
          this->boundaries_.set (r);
          continue;
        }
      }

      // materials
      //
      if (n.name () == "materials" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< materials_type > r (
          materials_traits::create (i, f, this));

        if (!materials_.present ())
        {
          this->materials_.set (r);
          continue;
        }
      }

      // field_config
      //
      if (n.name () == "field_config" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_config_type > r (
          field_config_traits::create (i, f, this));

        if (!field_config_.present ())
        {
          this->field_config_.set (r);
          continue;
        }
      }

      break;
    }

    if (!refinement_edges_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "refinement_edges",
        "");
    }

    if (!refinement_labels_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "refinement_labels",
        "");
    }

    if (!polynomial_orders_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "polynomial_orders",
        "");
    }

    if (!boundaries_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boundaries",
        "");
    }

    if (!materials_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "materials",
        "");
    }

    if (!field_config_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "field_config",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "field_id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_id_type > r (
          field_id_traits::create (i, f, this));

        this->field_id_.set (r);
        continue;
      }

      if (n.name () == "analysis_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< analysis_type_type > r (
          analysis_type_traits::create (i, f, this));

        this->analysis_type_.set (r);
        continue;
      }

      if (n.name () == "adaptivity_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< adaptivity_type_type > r (
          adaptivity_type_traits::create (i, f, this));

        this->adaptivity_type_.set (r);
        continue;
      }

      if (n.name () == "linearity_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< linearity_type_type > r (
          linearity_type_traits::create (i, f, this));

        this->linearity_type_.set (r);
        continue;
      }
    }

    if (!field_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_id",
        "");
    }

    if (!analysis_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysis_type",
        "");
    }

    if (!adaptivity_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "adaptivity_type",
        "");
    }

    if (!linearity_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "linearity_type",
        "");
    }
  }

  field* field::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field (*this, f, c);
  }

  field::
  ~field ()
  {
  }

  // coupling
  //

  coupling::
  coupling (const id_type& id,
            const type_type& type,
            const source_fieldid_type& source_fieldid,
            const target_fieldid_type& target_fieldid)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    source_fieldid_ (source_fieldid, ::xml_schema::flags (), this),
    target_fieldid_ (target_fieldid, ::xml_schema::flags (), this)
  {
  }

  coupling::
  coupling (const coupling& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    type_ (x.type_, f, this),
    source_fieldid_ (x.source_fieldid_, f, this),
    target_fieldid_ (x.target_fieldid_, f, this)
  {
  }

  coupling::
  coupling (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    type_ (f, this),
    source_fieldid_ (f, this),
    target_fieldid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void coupling::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "source_fieldid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< source_fieldid_type > r (
          source_fieldid_traits::create (i, f, this));

        this->source_fieldid_.set (r);
        continue;
      }

      if (n.name () == "target_fieldid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< target_fieldid_type > r (
          target_fieldid_traits::create (i, f, this));

        this->target_fieldid_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!source_fieldid_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source_fieldid",
        "");
    }

    if (!target_fieldid_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target_fieldid",
        "");
    }
  }

  coupling* coupling::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coupling (*this, f, c);
  }

  coupling::
  ~coupling ()
  {
  }

  // problem_item
  //

  problem_item::
  problem_item (const problem_key_type& problem_key,
                const problem_value_type& problem_value)
  : ::xml_schema::type (),
    problem_key_ (problem_key, ::xml_schema::flags (), this),
    problem_value_ (problem_value, ::xml_schema::flags (), this)
  {
  }

  problem_item::
  problem_item (const problem_item& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    problem_key_ (x.problem_key_, f, this),
    problem_value_ (x.problem_value_, f, this)
  {
  }

  problem_item::
  problem_item (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    problem_key_ (f, this),
    problem_value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void problem_item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "problem_key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< problem_key_type > r (
          problem_key_traits::create (i, f, this));

        this->problem_key_.set (r);
        continue;
      }

      if (n.name () == "problem_value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< problem_value_type > r (
          problem_value_traits::create (i, f, this));

        this->problem_value_.set (r);
        continue;
      }
    }

    if (!problem_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "problem_key",
        "");
    }

    if (!problem_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "problem_value",
        "");
    }
  }

  problem_item* problem_item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class problem_item (*this, f, c);
  }

  problem_item::
  ~problem_item ()
  {
  }

  // refinement_edges
  //

  refinement_edges::
  refinement_edges ()
  : ::xml_schema::type (),
    refinement_edge_ (::xml_schema::flags (), this)
  {
  }

  refinement_edges::
  refinement_edges (const refinement_edges& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refinement_edge_ (x.refinement_edge_, f, this)
  {
  }

  refinement_edges::
  refinement_edges (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refinement_edge_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void refinement_edges::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // refinement_edge
      //
      if (n.name () == "refinement_edge" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinement_edge_type > r (
          refinement_edge_traits::create (i, f, this));

        this->refinement_edge_.push_back (r);
        continue;
      }

      break;
    }
  }

  refinement_edges* refinement_edges::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class refinement_edges (*this, f, c);
  }

  refinement_edges::
  ~refinement_edges ()
  {
  }

  // refinement_labels
  //

  refinement_labels::
  refinement_labels ()
  : ::xml_schema::type (),
    refinement_label_ (::xml_schema::flags (), this)
  {
  }

  refinement_labels::
  refinement_labels (const refinement_labels& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refinement_label_ (x.refinement_label_, f, this)
  {
  }

  refinement_labels::
  refinement_labels (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refinement_label_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void refinement_labels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // refinement_label
      //
      if (n.name () == "refinement_label" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinement_label_type > r (
          refinement_label_traits::create (i, f, this));

        this->refinement_label_.push_back (r);
        continue;
      }

      break;
    }
  }

  refinement_labels* refinement_labels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class refinement_labels (*this, f, c);
  }

  refinement_labels::
  ~refinement_labels ()
  {
  }

  // polynomial_orders
  //

  polynomial_orders::
  polynomial_orders ()
  : ::xml_schema::type (),
    polynomial_order_ (::xml_schema::flags (), this)
  {
  }

  polynomial_orders::
  polynomial_orders (const polynomial_orders& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    polynomial_order_ (x.polynomial_order_, f, this)
  {
  }

  polynomial_orders::
  polynomial_orders (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    polynomial_order_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void polynomial_orders::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // polynomial_order
      //
      if (n.name () == "polynomial_order" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< polynomial_order_type > r (
          polynomial_order_traits::create (i, f, this));

        this->polynomial_order_.push_back (r);
        continue;
      }

      break;
    }
  }

  polynomial_orders* polynomial_orders::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class polynomial_orders (*this, f, c);
  }

  polynomial_orders::
  ~polynomial_orders ()
  {
  }

  // boundaries
  //

  boundaries::
  boundaries ()
  : ::xml_schema::type (),
    boundary_ (::xml_schema::flags (), this)
  {
  }

  boundaries::
  boundaries (const boundaries& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boundary_ (x.boundary_, f, this)
  {
  }

  boundaries::
  boundaries (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boundary_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void boundaries::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundary
      //
      if (n.name () == "boundary" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_type > r (
          boundary_traits::create (i, f, this));

        this->boundary_.push_back (r);
        continue;
      }

      break;
    }
  }

  boundaries* boundaries::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundaries (*this, f, c);
  }

  boundaries::
  ~boundaries ()
  {
  }

  // materials
  //

  materials::
  materials ()
  : ::xml_schema::type (),
    material_ (::xml_schema::flags (), this)
  {
  }

  materials::
  materials (const materials& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    material_ (x.material_, f, this)
  {
  }

  materials::
  materials (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    material_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void materials::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // material
      //
      if (n.name () == "material" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< material_type > r (
          material_traits::create (i, f, this));

        this->material_.push_back (r);
        continue;
      }

      break;
    }
  }

  materials* materials::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class materials (*this, f, c);
  }

  materials::
  ~materials ()
  {
  }

  // field_config
  //

  field_config::
  field_config ()
  : ::xml_schema::type (),
    field_item_ (::xml_schema::flags (), this)
  {
  }

  field_config::
  field_config (const field_config& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_item_ (x.field_item_, f, this)
  {
  }

  field_config::
  field_config (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_item_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void field_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field_item
      //
      if (n.name () == "field_item" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_item_type > r (
          field_item_traits::create (i, f, this));

        this->field_item_.push_back (r);
        continue;
      }

      break;
    }
  }

  field_config* field_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field_config (*this, f, c);
  }

  field_config::
  ~field_config ()
  {
  }

  // refinement_edge
  //

  refinement_edge::
  refinement_edge (const refinement_edge_id_type& refinement_edge_id,
                   const refinement_edge_number_type& refinement_edge_number)
  : ::xml_schema::type (),
    refinement_edge_id_ (refinement_edge_id, ::xml_schema::flags (), this),
    refinement_edge_number_ (refinement_edge_number, ::xml_schema::flags (), this)
  {
  }

  refinement_edge::
  refinement_edge (const refinement_edge& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refinement_edge_id_ (x.refinement_edge_id_, f, this),
    refinement_edge_number_ (x.refinement_edge_number_, f, this)
  {
  }

  refinement_edge::
  refinement_edge (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refinement_edge_id_ (f, this),
    refinement_edge_number_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void refinement_edge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "refinement_edge_id" && n.namespace_ ().empty ())
      {
        this->refinement_edge_id_.set (refinement_edge_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "refinement_edge_number" && n.namespace_ ().empty ())
      {
        this->refinement_edge_number_.set (refinement_edge_number_traits::create (i, f, this));
        continue;
      }
    }

    if (!refinement_edge_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refinement_edge_id",
        "");
    }

    if (!refinement_edge_number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refinement_edge_number",
        "");
    }
  }

  refinement_edge* refinement_edge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class refinement_edge (*this, f, c);
  }

  refinement_edge::
  ~refinement_edge ()
  {
  }

  // refinement_label
  //

  refinement_label::
  refinement_label (const refinement_label_id_type& refinement_label_id,
                    const refinement_label_number_type& refinement_label_number)
  : ::xml_schema::type (),
    refinement_label_id_ (refinement_label_id, ::xml_schema::flags (), this),
    refinement_label_number_ (refinement_label_number, ::xml_schema::flags (), this)
  {
  }

  refinement_label::
  refinement_label (const refinement_label& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refinement_label_id_ (x.refinement_label_id_, f, this),
    refinement_label_number_ (x.refinement_label_number_, f, this)
  {
  }

  refinement_label::
  refinement_label (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refinement_label_id_ (f, this),
    refinement_label_number_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void refinement_label::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "refinement_label_id" && n.namespace_ ().empty ())
      {
        this->refinement_label_id_.set (refinement_label_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "refinement_label_number" && n.namespace_ ().empty ())
      {
        this->refinement_label_number_.set (refinement_label_number_traits::create (i, f, this));
        continue;
      }
    }

    if (!refinement_label_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refinement_label_id",
        "");
    }

    if (!refinement_label_number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refinement_label_number",
        "");
    }
  }

  refinement_label* refinement_label::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class refinement_label (*this, f, c);
  }

  refinement_label::
  ~refinement_label ()
  {
  }

  // polynomial_order
  //

  polynomial_order::
  polynomial_order (const polynomial_order_id_type& polynomial_order_id,
                    const polynomial_order_number_type& polynomial_order_number)
  : ::xml_schema::type (),
    polynomial_order_id_ (polynomial_order_id, ::xml_schema::flags (), this),
    polynomial_order_number_ (polynomial_order_number, ::xml_schema::flags (), this)
  {
  }

  polynomial_order::
  polynomial_order (const polynomial_order& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    polynomial_order_id_ (x.polynomial_order_id_, f, this),
    polynomial_order_number_ (x.polynomial_order_number_, f, this)
  {
  }

  polynomial_order::
  polynomial_order (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    polynomial_order_id_ (f, this),
    polynomial_order_number_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void polynomial_order::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "polynomial_order_id" && n.namespace_ ().empty ())
      {
        this->polynomial_order_id_.set (polynomial_order_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "polynomial_order_number" && n.namespace_ ().empty ())
      {
        this->polynomial_order_number_.set (polynomial_order_number_traits::create (i, f, this));
        continue;
      }
    }

    if (!polynomial_order_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "polynomial_order_id",
        "");
    }

    if (!polynomial_order_number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "polynomial_order_number",
        "");
    }
  }

  polynomial_order* polynomial_order::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class polynomial_order (*this, f, c);
  }

  polynomial_order::
  ~polynomial_order ()
  {
  }

  // boundary
  //

  boundary::
  boundary (const boundary_edges_type& boundary_edges,
            const boundary_types_type& boundary_types,
            const type_type& type,
            const id_type& id,
            const name_type& name)
  : ::xml_schema::type (),
    boundary_edges_ (boundary_edges, ::xml_schema::flags (), this),
    boundary_types_ (boundary_types, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  boundary::
  boundary (::std::auto_ptr< boundary_edges_type >& boundary_edges,
            ::std::auto_ptr< boundary_types_type >& boundary_types,
            const type_type& type,
            const id_type& id,
            const name_type& name)
  : ::xml_schema::type (),
    boundary_edges_ (boundary_edges, ::xml_schema::flags (), this),
    boundary_types_ (boundary_types, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  boundary::
  boundary (const boundary& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boundary_edges_ (x.boundary_edges_, f, this),
    boundary_types_ (x.boundary_types_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  boundary::
  boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boundary_edges_ (f, this),
    boundary_types_ (f, this),
    type_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void boundary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundary_edges
      //
      if (n.name () == "boundary_edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_edges_type > r (
          boundary_edges_traits::create (i, f, this));

        if (!boundary_edges_.present ())
        {
          this->boundary_edges_.set (r);
          continue;
        }
      }

      // boundary_types
      //
      if (n.name () == "boundary_types" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_types_type > r (
          boundary_types_traits::create (i, f, this));

        if (!boundary_types_.present ())
        {
          this->boundary_types_.set (r);
          continue;
        }
      }

      break;
    }

    if (!boundary_edges_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boundary_edges",
        "");
    }

    if (!boundary_types_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boundary_types",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  boundary* boundary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary (*this, f, c);
  }

  boundary::
  ~boundary ()
  {
  }

  // material
  //

  material::
  material (const material_labels_type& material_labels,
            const material_types_type& material_types,
            const id_type& id,
            const name_type& name)
  : ::xml_schema::type (),
    material_labels_ (material_labels, ::xml_schema::flags (), this),
    material_types_ (material_types, ::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  material::
  material (::std::auto_ptr< material_labels_type >& material_labels,
            ::std::auto_ptr< material_types_type >& material_types,
            const id_type& id,
            const name_type& name)
  : ::xml_schema::type (),
    material_labels_ (material_labels, ::xml_schema::flags (), this),
    material_types_ (material_types, ::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  material::
  material (const material& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    material_labels_ (x.material_labels_, f, this),
    material_types_ (x.material_types_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  material::
  material (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    material_labels_ (f, this),
    material_types_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void material::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // material_labels
      //
      if (n.name () == "material_labels" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< material_labels_type > r (
          material_labels_traits::create (i, f, this));

        if (!material_labels_.present ())
        {
          this->material_labels_.set (r);
          continue;
        }
      }

      // material_types
      //
      if (n.name () == "material_types" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< material_types_type > r (
          material_types_traits::create (i, f, this));

        if (!material_types_.present ())
        {
          this->material_types_.set (r);
          continue;
        }
      }

      break;
    }

    if (!material_labels_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "material_labels",
        "");
    }

    if (!material_types_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "material_types",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  material* material::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class material (*this, f, c);
  }

  material::
  ~material ()
  {
  }

  // field_item
  //

  field_item::
  field_item (const field_key_type& field_key,
              const field_value_type& field_value)
  : ::xml_schema::type (),
    field_key_ (field_key, ::xml_schema::flags (), this),
    field_value_ (field_value, ::xml_schema::flags (), this)
  {
  }

  field_item::
  field_item (const field_item& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_key_ (x.field_key_, f, this),
    field_value_ (x.field_value_, f, this)
  {
  }

  field_item::
  field_item (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_key_ (f, this),
    field_value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void field_item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "field_key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_key_type > r (
          field_key_traits::create (i, f, this));

        this->field_key_.set (r);
        continue;
      }

      if (n.name () == "field_value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_value_type > r (
          field_value_traits::create (i, f, this));

        this->field_value_.set (r);
        continue;
      }
    }

    if (!field_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_key",
        "");
    }

    if (!field_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_value",
        "");
    }
  }

  field_item* field_item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field_item (*this, f, c);
  }

  field_item::
  ~field_item ()
  {
  }

  // boundary_edges
  //

  boundary_edges::
  boundary_edges ()
  : ::xml_schema::type (),
    boundary_edge_ (::xml_schema::flags (), this)
  {
  }

  boundary_edges::
  boundary_edges (const boundary_edges& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boundary_edge_ (x.boundary_edge_, f, this)
  {
  }

  boundary_edges::
  boundary_edges (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boundary_edge_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void boundary_edges::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundary_edge
      //
      if (n.name () == "boundary_edge" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_edge_type > r (
          boundary_edge_traits::create (i, f, this));

        this->boundary_edge_.push_back (r);
        continue;
      }

      break;
    }
  }

  boundary_edges* boundary_edges::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_edges (*this, f, c);
  }

  boundary_edges::
  ~boundary_edges ()
  {
  }

  // boundary_types
  //

  boundary_types::
  boundary_types ()
  : ::xml_schema::type (),
    boundary_type_ (::xml_schema::flags (), this)
  {
  }

  boundary_types::
  boundary_types (const boundary_types& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boundary_type_ (x.boundary_type_, f, this)
  {
  }

  boundary_types::
  boundary_types (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boundary_type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void boundary_types::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundary_type
      //
      if (n.name () == "boundary_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_type_type > r (
          boundary_type_traits::create (i, f, this));

        this->boundary_type_.push_back (r);
        continue;
      }

      break;
    }
  }

  boundary_types* boundary_types::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_types (*this, f, c);
  }

  boundary_types::
  ~boundary_types ()
  {
  }

  // material_labels
  //

  material_labels::
  material_labels ()
  : ::xml_schema::type (),
    material_label_ (::xml_schema::flags (), this)
  {
  }

  material_labels::
  material_labels (const material_labels& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    material_label_ (x.material_label_, f, this)
  {
  }

  material_labels::
  material_labels (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    material_label_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void material_labels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // material_label
      //
      if (n.name () == "material_label" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< material_label_type > r (
          material_label_traits::create (i, f, this));

        this->material_label_.push_back (r);
        continue;
      }

      break;
    }
  }

  material_labels* material_labels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class material_labels (*this, f, c);
  }

  material_labels::
  ~material_labels ()
  {
  }

  // material_types
  //

  material_types::
  material_types ()
  : ::xml_schema::type (),
    material_type_ (::xml_schema::flags (), this)
  {
  }

  material_types::
  material_types (const material_types& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    material_type_ (x.material_type_, f, this)
  {
  }

  material_types::
  material_types (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    material_type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void material_types::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // material_type
      //
      if (n.name () == "material_type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< material_type_type > r (
          material_type_traits::create (i, f, this));

        this->material_type_.push_back (r);
        continue;
      }

      break;
    }
  }

  material_types* material_types::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class material_types (*this, f, c);
  }

  material_types::
  ~material_types ()
  {
  }

  // boundary_edge
  //

  boundary_edge::
  boundary_edge (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this)
  {
  }

  boundary_edge::
  boundary_edge (const boundary_edge& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  boundary_edge::
  boundary_edge (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void boundary_edge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  boundary_edge* boundary_edge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_edge (*this, f, c);
  }

  boundary_edge::
  ~boundary_edge ()
  {
  }

  // boundary_type
  //

  boundary_type::
  boundary_type (const key_type& key,
                 const value_type& value)
  : ::xml_schema::type (),
    key_ (key, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  boundary_type::
  boundary_type (const boundary_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    key_ (x.key_, f, this),
    value_ (x.value_, f, this)
  {
  }

  boundary_type::
  boundary_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    key_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void boundary_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< key_type > r (
          key_traits::create (i, f, this));

        this->key_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  boundary_type* boundary_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_type (*this, f, c);
  }

  boundary_type::
  ~boundary_type ()
  {
  }

  // material_label
  //

  material_label::
  material_label (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this)
  {
  }

  material_label::
  material_label (const material_label& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  material_label::
  material_label (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void material_label::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  material_label* material_label::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class material_label (*this, f, c);
  }

  material_label::
  ~material_label ()
  {
  }

  // material_type
  //

  material_type::
  material_type (const key_type& key,
                 const value_type& value)
  : ::xml_schema::type (),
    key_ (key, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  material_type::
  material_type (const material_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    key_ (x.key_, f, this),
    value_ (x.value_, f, this)
  {
  }

  material_type::
  material_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    key_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void material_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< key_type > r (
          key_traits::create (i, f, this));

        this->key_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  material_type* material_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class material_type (*this, f, c);
  }

  material_type::
  ~material_type ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace XMLProblem
{
  ::std::ostream&
  operator<< (::std::ostream& o, const document& i)
  {
    o << ::std::endl << "geometry: " << i.geometry ();
    o << ::std::endl << "problem: " << i.problem ();
    o << ::std::endl << "config: " << i.config ();
    o << ::std::endl << "version: " << i.version ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const geometry& i)
  {
    o << ::std::endl << "nodes: " << i.nodes ();
    o << ::std::endl << "edges: " << i.edges ();
    o << ::std::endl << "labels: " << i.labels ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const problem& i)
  {
    o << ::std::endl << "fields: " << i.fields ();
    o << ::std::endl << "couplings: " << i.couplings ();
    o << ::std::endl << "problem_config: " << i.problem_config ();
    o << ::std::endl << "coordinate_type: " << i.coordinate_type ();
    o << ::std::endl << "mesh_type: " << i.mesh_type ();
    o << ::std::endl << "matrix_solver: " << i.matrix_solver ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const config& i)
  {
    for (config::item_const_iterator
         b (i.item ().begin ()), e (i.item ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "item: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const nodes& i)
  {
    for (nodes::node_const_iterator
         b (i.node ().begin ()), e (i.node ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "node: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const edges& i)
  {
    for (edges::edge_const_iterator
         b (i.edge ().begin ()), e (i.edge ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "edge: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const labels& i)
  {
    for (labels::label_const_iterator
         b (i.label ().begin ()), e (i.label ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "label: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const fields& i)
  {
    for (fields::field_const_iterator
         b (i.field ().begin ()), e (i.field ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "field: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const couplings& i)
  {
    for (couplings::coupling_const_iterator
         b (i.coupling ().begin ()), e (i.coupling ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "coupling: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const problem_config& i)
  {
    for (problem_config::problem_item_const_iterator
         b (i.problem_item ().begin ()), e (i.problem_item ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "problem_item: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const item& i)
  {
    o << ::std::endl << "key: " << i.key ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const node& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "x: " << i.x ();
    o << ::std::endl << "y: " << i.y ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const edge& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "start: " << i.start ();
    o << ::std::endl << "end: " << i.end ();
    o << ::std::endl << "angle: " << i.angle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const label& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "x: " << i.x ();
    o << ::std::endl << "y: " << i.y ();
    o << ::std::endl << "area: " << i.area ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field& i)
  {
    o << ::std::endl << "refinement_edges: " << i.refinement_edges ();
    o << ::std::endl << "refinement_labels: " << i.refinement_labels ();
    o << ::std::endl << "polynomial_orders: " << i.polynomial_orders ();
    o << ::std::endl << "boundaries: " << i.boundaries ();
    o << ::std::endl << "materials: " << i.materials ();
    o << ::std::endl << "field_config: " << i.field_config ();
    o << ::std::endl << "field_id: " << i.field_id ();
    o << ::std::endl << "analysis_type: " << i.analysis_type ();
    o << ::std::endl << "adaptivity_type: " << i.adaptivity_type ();
    o << ::std::endl << "linearity_type: " << i.linearity_type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const coupling& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "source_fieldid: " << i.source_fieldid ();
    o << ::std::endl << "target_fieldid: " << i.target_fieldid ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const problem_item& i)
  {
    o << ::std::endl << "problem_key: " << i.problem_key ();
    o << ::std::endl << "problem_value: " << i.problem_value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const refinement_edges& i)
  {
    for (refinement_edges::refinement_edge_const_iterator
         b (i.refinement_edge ().begin ()), e (i.refinement_edge ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "refinement_edge: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const refinement_labels& i)
  {
    for (refinement_labels::refinement_label_const_iterator
         b (i.refinement_label ().begin ()), e (i.refinement_label ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "refinement_label: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const polynomial_orders& i)
  {
    for (polynomial_orders::polynomial_order_const_iterator
         b (i.polynomial_order ().begin ()), e (i.polynomial_order ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "polynomial_order: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundaries& i)
  {
    for (boundaries::boundary_const_iterator
         b (i.boundary ().begin ()), e (i.boundary ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "boundary: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const materials& i)
  {
    for (materials::material_const_iterator
         b (i.material ().begin ()), e (i.material ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "material: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field_config& i)
  {
    for (field_config::field_item_const_iterator
         b (i.field_item ().begin ()), e (i.field_item ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "field_item: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const refinement_edge& i)
  {
    o << ::std::endl << "refinement_edge_id: " << i.refinement_edge_id ();
    o << ::std::endl << "refinement_edge_number: " << i.refinement_edge_number ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const refinement_label& i)
  {
    o << ::std::endl << "refinement_label_id: " << i.refinement_label_id ();
    o << ::std::endl << "refinement_label_number: " << i.refinement_label_number ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const polynomial_order& i)
  {
    o << ::std::endl << "polynomial_order_id: " << i.polynomial_order_id ();
    o << ::std::endl << "polynomial_order_number: " << i.polynomial_order_number ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary& i)
  {
    o << ::std::endl << "boundary_edges: " << i.boundary_edges ();
    o << ::std::endl << "boundary_types: " << i.boundary_types ();
    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const material& i)
  {
    o << ::std::endl << "material_labels: " << i.material_labels ();
    o << ::std::endl << "material_types: " << i.material_types ();
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field_item& i)
  {
    o << ::std::endl << "field_key: " << i.field_key ();
    o << ::std::endl << "field_value: " << i.field_value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary_edges& i)
  {
    for (boundary_edges::boundary_edge_const_iterator
         b (i.boundary_edge ().begin ()), e (i.boundary_edge ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "boundary_edge: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary_types& i)
  {
    for (boundary_types::boundary_type_const_iterator
         b (i.boundary_type ().begin ()), e (i.boundary_type ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "boundary_type: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const material_labels& i)
  {
    for (material_labels::material_label_const_iterator
         b (i.material_label ().begin ()), e (i.material_label ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "material_label: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const material_types& i)
  {
    for (material_types::material_type_const_iterator
         b (i.material_type ().begin ()), e (i.material_type ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "material_type: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary_edge& i)
  {
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary_type& i)
  {
    o << ::std::endl << "key: " << i.key ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const material_label& i)
  {
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const material_type& i)
  {
    o << ::std::endl << "key: " << i.key ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLProblem
{
  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLProblem::document > r (
      ::XMLProblem::document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLProblem::document > r (
      ::XMLProblem::document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLProblem::document > r (
      ::XMLProblem::document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLProblem::document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLProblem::document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLProblem::document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLProblem::document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLProblem::document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLProblem::document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLProblem::document > r (
      ::XMLProblem::document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLProblem::document > r (
      ::XMLProblem::document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLProblem::document > r (
      ::XMLProblem::document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::XMLProblem::document > r (
        ::XMLProblem::document_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "document" &&
        n.namespace_ () == "XMLProblem")
    {
      ::std::auto_ptr< ::XMLProblem::document > r (
        ::xsd::cxx::tree::traits< ::XMLProblem::document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "document",
      "XMLProblem");
  }

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "document" &&
        n.namespace_ () == "XMLProblem")
    {
      ::std::auto_ptr< ::XMLProblem::document > r (
        ::xsd::cxx::tree::traits< ::XMLProblem::document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "document",
      "XMLProblem");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace XMLProblem
{
  void
  document_ (::std::ostream& o,
             const ::XMLProblem::document& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLProblem::document_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  document_ (::std::ostream& o,
             const ::XMLProblem::document& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLProblem::document_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  document_ (::std::ostream& o,
             const ::XMLProblem::document& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLProblem::document_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  document_ (::xercesc::XMLFormatTarget& t,
             const ::XMLProblem::document& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLProblem::document_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  document_ (::xercesc::XMLFormatTarget& t,
             const ::XMLProblem::document& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLProblem::document_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  document_ (::xercesc::XMLFormatTarget& t,
             const ::XMLProblem::document& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLProblem::document_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  document_ (::xercesc::DOMDocument& d,
             const ::XMLProblem::document& s,
             ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "document" &&
        n.namespace_ () == "XMLProblem")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "document",
        "XMLProblem");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  document_ (const ::XMLProblem::document& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "document",
        "XMLProblem",
        m, f));

    ::XMLProblem::document_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const document& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // geometry
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "geometry",
          e));

      s << i.geometry ();
    }

    // problem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "problem",
          e));

      s << i.problem ();
    }

    // config
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "config",
          e));

      s << i.config ();
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const geometry& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // nodes
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodes",
          e));

      s << i.nodes ();
    }

    // edges
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edges",
          e));

      s << i.edges ();
    }

    // labels
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "labels",
          e));

      s << i.labels ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const problem& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // fields
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fields",
          e));

      s << i.fields ();
    }

    // couplings
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "couplings",
          e));

      s << i.couplings ();
    }

    // problem_config
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "problem_config",
          e));

      s << i.problem_config ();
    }

    // coordinate_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "coordinate_type",
          e));

      a << i.coordinate_type ();
    }

    // mesh_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mesh_type",
          e));

      a << i.mesh_type ();
    }

    // matrix_solver
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "matrix_solver",
          e));

      a << i.matrix_solver ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // item
    //
    for (config::item_const_iterator
         b (i.item ().begin ()), n (i.item ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "item",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const nodes& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // node
    //
    for (nodes::node_const_iterator
         b (i.node ().begin ()), n (i.node ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const edges& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // edge
    //
    for (edges::edge_const_iterator
         b (i.edge ().begin ()), n (i.edge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edge",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const labels& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // label
    //
    for (labels::label_const_iterator
         b (i.label ().begin ()), n (i.label ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "label",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const fields& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field
    //
    for (fields::field_const_iterator
         b (i.field ().begin ()), n (i.field ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const couplings& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // coupling
    //
    for (couplings::coupling_const_iterator
         b (i.coupling ().begin ()), n (i.coupling ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coupling",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const problem_config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // problem_item
    //
    for (problem_config::problem_item_const_iterator
         b (i.problem_item ().begin ()), n (i.problem_item ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "problem_item",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const item& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key",
          e));

      a << i.key ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const node& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const edge& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // start
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "start",
          e));

      a << i.start ();
    }

    // end
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "end",
          e));

      a << i.end ();
    }

    // angle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "angle",
          e));

      a << i.angle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const label& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << i.y ();
    }

    // area
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "area",
          e));

      a << i.area ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // refinement_edges
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinement_edges",
          e));

      s << i.refinement_edges ();
    }

    // refinement_labels
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinement_labels",
          e));

      s << i.refinement_labels ();
    }

    // polynomial_orders
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "polynomial_orders",
          e));

      s << i.polynomial_orders ();
    }

    // boundaries
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundaries",
          e));

      s << i.boundaries ();
    }

    // materials
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "materials",
          e));

      s << i.materials ();
    }

    // field_config
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field_config",
          e));

      s << i.field_config ();
    }

    // field_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_id",
          e));

      a << i.field_id ();
    }

    // analysis_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysis_type",
          e));

      a << i.analysis_type ();
    }

    // adaptivity_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "adaptivity_type",
          e));

      a << i.adaptivity_type ();
    }

    // linearity_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "linearity_type",
          e));

      a << i.linearity_type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coupling& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // source_fieldid
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "source_fieldid",
          e));

      a << i.source_fieldid ();
    }

    // target_fieldid
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "target_fieldid",
          e));

      a << i.target_fieldid ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const problem_item& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // problem_key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "problem_key",
          e));

      a << i.problem_key ();
    }

    // problem_value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "problem_value",
          e));

      a << i.problem_value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const refinement_edges& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // refinement_edge
    //
    for (refinement_edges::refinement_edge_const_iterator
         b (i.refinement_edge ().begin ()), n (i.refinement_edge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinement_edge",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const refinement_labels& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // refinement_label
    //
    for (refinement_labels::refinement_label_const_iterator
         b (i.refinement_label ().begin ()), n (i.refinement_label ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinement_label",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const polynomial_orders& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // polynomial_order
    //
    for (polynomial_orders::polynomial_order_const_iterator
         b (i.polynomial_order ().begin ()), n (i.polynomial_order ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "polynomial_order",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundaries& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boundary
    //
    for (boundaries::boundary_const_iterator
         b (i.boundary ().begin ()), n (i.boundary ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const materials& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // material
    //
    for (materials::material_const_iterator
         b (i.material ().begin ()), n (i.material ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "material",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field_config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_item
    //
    for (field_config::field_item_const_iterator
         b (i.field_item ().begin ()), n (i.field_item ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field_item",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const refinement_edge& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // refinement_edge_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refinement_edge_id",
          e));

      a << i.refinement_edge_id ();
    }

    // refinement_edge_number
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refinement_edge_number",
          e));

      a << i.refinement_edge_number ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const refinement_label& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // refinement_label_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refinement_label_id",
          e));

      a << i.refinement_label_id ();
    }

    // refinement_label_number
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refinement_label_number",
          e));

      a << i.refinement_label_number ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const polynomial_order& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // polynomial_order_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "polynomial_order_id",
          e));

      a << i.polynomial_order_id ();
    }

    // polynomial_order_number
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "polynomial_order_number",
          e));

      a << i.polynomial_order_number ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boundary_edges
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary_edges",
          e));

      s << i.boundary_edges ();
    }

    // boundary_types
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary_types",
          e));

      s << i.boundary_types ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const material& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // material_labels
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "material_labels",
          e));

      s << i.material_labels ();
    }

    // material_types
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "material_types",
          e));

      s << i.material_types ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field_item& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_key",
          e));

      a << i.field_key ();
    }

    // field_value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_value",
          e));

      a << i.field_value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary_edges& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boundary_edge
    //
    for (boundary_edges::boundary_edge_const_iterator
         b (i.boundary_edge ().begin ()), n (i.boundary_edge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary_edge",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary_types& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boundary_type
    //
    for (boundary_types::boundary_type_const_iterator
         b (i.boundary_type ().begin ()), n (i.boundary_type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary_type",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const material_labels& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // material_label
    //
    for (material_labels::material_label_const_iterator
         b (i.material_label ().begin ()), n (i.material_label ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "material_label",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const material_types& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // material_type
    //
    for (material_types::material_type_const_iterator
         b (i.material_type ().begin ()), n (i.material_type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "material_type",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary_edge& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key",
          e));

      a << i.key ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const material_label& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const material_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key",
          e));

      a << i.key ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

