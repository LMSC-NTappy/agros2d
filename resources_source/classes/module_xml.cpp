// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "module_xml.h"

namespace XMLModule
{
  // module
  // 

  const module::general_type& module::
  general () const
  {
    return this->general_.get ();
  }

  module::general_type& module::
  general ()
  {
    return this->general_.get ();
  }

  void module::
  general (const general_type& x)
  {
    this->general_.set (x);
  }

  void module::
  general (::std::auto_ptr< general_type > x)
  {
    this->general_.set (x);
  }

  const module::constants_type& module::
  constants () const
  {
    return this->constants_.get ();
  }

  module::constants_type& module::
  constants ()
  {
    return this->constants_.get ();
  }

  void module::
  constants (const constants_type& x)
  {
    this->constants_.set (x);
  }

  void module::
  constants (::std::auto_ptr< constants_type > x)
  {
    this->constants_.set (x);
  }

  const module::spaces_type& module::
  spaces () const
  {
    return this->spaces_.get ();
  }

  module::spaces_type& module::
  spaces ()
  {
    return this->spaces_.get ();
  }

  void module::
  spaces (const spaces_type& x)
  {
    this->spaces_.set (x);
  }

  void module::
  spaces (::std::auto_ptr< spaces_type > x)
  {
    this->spaces_.set (x);
  }

  const module::volume_type& module::
  volume () const
  {
    return this->volume_.get ();
  }

  module::volume_type& module::
  volume ()
  {
    return this->volume_.get ();
  }

  void module::
  volume (const volume_type& x)
  {
    this->volume_.set (x);
  }

  void module::
  volume (::std::auto_ptr< volume_type > x)
  {
    this->volume_.set (x);
  }

  const module::surface_type& module::
  surface () const
  {
    return this->surface_.get ();
  }

  module::surface_type& module::
  surface ()
  {
    return this->surface_.get ();
  }

  void module::
  surface (const surface_type& x)
  {
    this->surface_.set (x);
  }

  void module::
  surface (::std::auto_ptr< surface_type > x)
  {
    this->surface_.set (x);
  }

  const module::preprocessor_type& module::
  preprocessor () const
  {
    return this->preprocessor_.get ();
  }

  module::preprocessor_type& module::
  preprocessor ()
  {
    return this->preprocessor_.get ();
  }

  void module::
  preprocessor (const preprocessor_type& x)
  {
    this->preprocessor_.set (x);
  }

  void module::
  preprocessor (::std::auto_ptr< preprocessor_type > x)
  {
    this->preprocessor_.set (x);
  }

  const module::postprocessor_type& module::
  postprocessor () const
  {
    return this->postprocessor_.get ();
  }

  module::postprocessor_type& module::
  postprocessor ()
  {
    return this->postprocessor_.get ();
  }

  void module::
  postprocessor (const postprocessor_type& x)
  {
    this->postprocessor_.set (x);
  }

  void module::
  postprocessor (::std::auto_ptr< postprocessor_type > x)
  {
    this->postprocessor_.set (x);
  }


  // general
  // 

  const general::description_type& general::
  description () const
  {
    return this->description_.get ();
  }

  general::description_type& general::
  description ()
  {
    return this->description_.get ();
  }

  void general::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void general::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const general::analyses_type& general::
  analyses () const
  {
    return this->analyses_.get ();
  }

  general::analyses_type& general::
  analyses ()
  {
    return this->analyses_.get ();
  }

  void general::
  analyses (const analyses_type& x)
  {
    this->analyses_.set (x);
  }

  void general::
  analyses (::std::auto_ptr< analyses_type > x)
  {
    this->analyses_.set (x);
  }

  const general::deformed_shape_optional& general::
  deformed_shape () const
  {
    return this->deformed_shape_;
  }

  general::deformed_shape_optional& general::
  deformed_shape ()
  {
    return this->deformed_shape_;
  }

  void general::
  deformed_shape (const deformed_shape_type& x)
  {
    this->deformed_shape_.set (x);
  }

  void general::
  deformed_shape (const deformed_shape_optional& x)
  {
    this->deformed_shape_ = x;
  }

  const general::id_type& general::
  id () const
  {
    return this->id_.get ();
  }

  general::id_type& general::
  id ()
  {
    return this->id_.get ();
  }

  void general::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void general::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const general::name_type& general::
  name () const
  {
    return this->name_.get ();
  }

  general::name_type& general::
  name ()
  {
    return this->name_.get ();
  }

  void general::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void general::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // analyses
  // 

  const analyses::analysis_sequence& analyses::
  analysis () const
  {
    return this->analysis_;
  }

  analyses::analysis_sequence& analyses::
  analysis ()
  {
    return this->analysis_;
  }

  void analyses::
  analysis (const analysis_sequence& s)
  {
    this->analysis_ = s;
  }


  // analysis
  // 

  const analysis::field_config_optional& analysis::
  field_config () const
  {
    return this->field_config_;
  }

  analysis::field_config_optional& analysis::
  field_config ()
  {
    return this->field_config_;
  }

  void analysis::
  field_config (const field_config_type& x)
  {
    this->field_config_.set (x);
  }

  void analysis::
  field_config (const field_config_optional& x)
  {
    this->field_config_ = x;
  }

  void analysis::
  field_config (::std::auto_ptr< field_config_type > x)
  {
    this->field_config_.set (x);
  }

  const analysis::id_type& analysis::
  id () const
  {
    return this->id_.get ();
  }

  analysis::id_type& analysis::
  id ()
  {
    return this->id_.get ();
  }

  void analysis::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void analysis::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const analysis::name_type& analysis::
  name () const
  {
    return this->name_.get ();
  }

  analysis::name_type& analysis::
  name ()
  {
    return this->name_.get ();
  }

  void analysis::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void analysis::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const analysis::solutions_type& analysis::
  solutions () const
  {
    return this->solutions_.get ();
  }

  analysis::solutions_type& analysis::
  solutions ()
  {
    return this->solutions_.get ();
  }

  void analysis::
  solutions (const solutions_type& x)
  {
    this->solutions_.set (x);
  }

  const analysis::type_type& analysis::
  type () const
  {
    return this->type_.get ();
  }

  analysis::type_type& analysis::
  type ()
  {
    return this->type_.get ();
  }

  void analysis::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void analysis::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // field_config
  // 

  const field_config::field_item_sequence& field_config::
  field_item () const
  {
    return this->field_item_;
  }

  field_config::field_item_sequence& field_config::
  field_item ()
  {
    return this->field_item_;
  }

  void field_config::
  field_item (const field_item_sequence& s)
  {
    this->field_item_ = s;
  }


  // constants
  // 

  const constants::constant_sequence& constants::
  constant () const
  {
    return this->constant_;
  }

  constants::constant_sequence& constants::
  constant ()
  {
    return this->constant_;
  }

  void constants::
  constant (const constant_sequence& s)
  {
    this->constant_ = s;
  }


  // constant
  // 

  const constant::id_type& constant::
  id () const
  {
    return this->id_.get ();
  }

  constant::id_type& constant::
  id ()
  {
    return this->id_.get ();
  }

  void constant::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void constant::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const constant::value_type& constant::
  value () const
  {
    return this->value_.get ();
  }

  constant::value_type& constant::
  value ()
  {
    return this->value_.get ();
  }

  void constant::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // macros
  // 

  const macros::macro_type& macros::
  macro () const
  {
    return this->macro_.get ();
  }

  macros::macro_type& macros::
  macro ()
  {
    return this->macro_.get ();
  }

  void macros::
  macro (const macro_type& x)
  {
    this->macro_.set (x);
  }

  void macros::
  macro (::std::auto_ptr< macro_type > x)
  {
    this->macro_.set (x);
  }


  // macro
  // 

  const macro::expression_optional& macro::
  expression () const
  {
    return this->expression_;
  }

  macro::expression_optional& macro::
  expression ()
  {
    return this->expression_;
  }

  void macro::
  expression (const expression_type& x)
  {
    this->expression_.set (x);
  }

  void macro::
  expression (const expression_optional& x)
  {
    this->expression_ = x;
  }

  void macro::
  expression (::std::auto_ptr< expression_type > x)
  {
    this->expression_.set (x);
  }

  const macro::id_type& macro::
  id () const
  {
    return this->id_.get ();
  }

  macro::id_type& macro::
  id ()
  {
    return this->id_.get ();
  }

  void macro::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void macro::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }


  // spaces
  // 

  const spaces::space_sequence& spaces::
  space () const
  {
    return this->space_;
  }

  spaces::space_sequence& spaces::
  space ()
  {
    return this->space_;
  }

  void spaces::
  space (const space_sequence& s)
  {
    this->space_ = s;
  }


  // space
  // 

  const space::space_config_sequence& space::
  space_config () const
  {
    return this->space_config_;
  }

  space::space_config_sequence& space::
  space_config ()
  {
    return this->space_config_;
  }

  void space::
  space_config (const space_config_sequence& s)
  {
    this->space_config_ = s;
  }

  const space::analysistype_type& space::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  space::analysistype_type& space::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void space::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void space::
  analysistype (::std::auto_ptr< analysistype_type > x)
  {
    this->analysistype_.set (x);
  }


  // space_config
  // 

  const space_config::i_type& space_config::
  i () const
  {
    return this->i_.get ();
  }

  space_config::i_type& space_config::
  i ()
  {
    return this->i_.get ();
  }

  void space_config::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  const space_config::type_type& space_config::
  type () const
  {
    return this->type_.get ();
  }

  space_config::type_type& space_config::
  type ()
  {
    return this->type_.get ();
  }

  void space_config::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void space_config::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const space_config::orderadjust_type& space_config::
  orderadjust () const
  {
    return this->orderadjust_.get ();
  }

  space_config::orderadjust_type& space_config::
  orderadjust ()
  {
    return this->orderadjust_.get ();
  }

  void space_config::
  orderadjust (const orderadjust_type& x)
  {
    this->orderadjust_.set (x);
  }


  // preprocessor
  // 

  const preprocessor::gui_sequence& preprocessor::
  gui () const
  {
    return this->gui_;
  }

  preprocessor::gui_sequence& preprocessor::
  gui ()
  {
    return this->gui_;
  }

  void preprocessor::
  gui (const gui_sequence& s)
  {
    this->gui_ = s;
  }


  // gui
  // 

  const gui::group_sequence& gui::
  group () const
  {
    return this->group_;
  }

  gui::group_sequence& gui::
  group ()
  {
    return this->group_;
  }

  void gui::
  group (const group_sequence& s)
  {
    this->group_ = s;
  }

  const gui::type_type& gui::
  type () const
  {
    return this->type_.get ();
  }

  gui::type_type& gui::
  type ()
  {
    return this->type_.get ();
  }

  void gui::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void gui::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // postprocessor
  // 

  const postprocessor::localvariables_type& postprocessor::
  localvariables () const
  {
    return this->localvariables_.get ();
  }

  postprocessor::localvariables_type& postprocessor::
  localvariables ()
  {
    return this->localvariables_.get ();
  }

  void postprocessor::
  localvariables (const localvariables_type& x)
  {
    this->localvariables_.set (x);
  }

  void postprocessor::
  localvariables (::std::auto_ptr< localvariables_type > x)
  {
    this->localvariables_.set (x);
  }

  const postprocessor::view_type& postprocessor::
  view () const
  {
    return this->view_.get ();
  }

  postprocessor::view_type& postprocessor::
  view ()
  {
    return this->view_.get ();
  }

  void postprocessor::
  view (const view_type& x)
  {
    this->view_.set (x);
  }

  void postprocessor::
  view (::std::auto_ptr< view_type > x)
  {
    this->view_.set (x);
  }

  const postprocessor::volumeintegrals_type& postprocessor::
  volumeintegrals () const
  {
    return this->volumeintegrals_.get ();
  }

  postprocessor::volumeintegrals_type& postprocessor::
  volumeintegrals ()
  {
    return this->volumeintegrals_.get ();
  }

  void postprocessor::
  volumeintegrals (const volumeintegrals_type& x)
  {
    this->volumeintegrals_.set (x);
  }

  void postprocessor::
  volumeintegrals (::std::auto_ptr< volumeintegrals_type > x)
  {
    this->volumeintegrals_.set (x);
  }

  const postprocessor::surfaceintegrals_type& postprocessor::
  surfaceintegrals () const
  {
    return this->surfaceintegrals_.get ();
  }

  postprocessor::surfaceintegrals_type& postprocessor::
  surfaceintegrals ()
  {
    return this->surfaceintegrals_.get ();
  }

  void postprocessor::
  surfaceintegrals (const surfaceintegrals_type& x)
  {
    this->surfaceintegrals_.set (x);
  }

  void postprocessor::
  surfaceintegrals (::std::auto_ptr< surfaceintegrals_type > x)
  {
    this->surfaceintegrals_.set (x);
  }

  const postprocessor::force_type& postprocessor::
  force () const
  {
    return this->force_.get ();
  }

  postprocessor::force_type& postprocessor::
  force ()
  {
    return this->force_.get ();
  }

  void postprocessor::
  force (const force_type& x)
  {
    this->force_.set (x);
  }

  void postprocessor::
  force (::std::auto_ptr< force_type > x)
  {
    this->force_.set (x);
  }


  // localvariables
  // 

  const localvariables::localvariable_sequence& localvariables::
  localvariable () const
  {
    return this->localvariable_;
  }

  localvariables::localvariable_sequence& localvariables::
  localvariable ()
  {
    return this->localvariable_;
  }

  void localvariables::
  localvariable (const localvariable_sequence& s)
  {
    this->localvariable_ = s;
  }


  // localvariable
  // 

  const localvariable::expression_sequence& localvariable::
  expression () const
  {
    return this->expression_;
  }

  localvariable::expression_sequence& localvariable::
  expression ()
  {
    return this->expression_;
  }

  void localvariable::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const localvariable::format_optional& localvariable::
  format () const
  {
    return this->format_;
  }

  localvariable::format_optional& localvariable::
  format ()
  {
    return this->format_;
  }

  void localvariable::
  format (const format_type& x)
  {
    this->format_.set (x);
  }

  void localvariable::
  format (const format_optional& x)
  {
    this->format_ = x;
  }

  void localvariable::
  format (::std::auto_ptr< format_type > x)
  {
    this->format_.set (x);
  }

  const localvariable::id_type& localvariable::
  id () const
  {
    return this->id_.get ();
  }

  localvariable::id_type& localvariable::
  id ()
  {
    return this->id_.get ();
  }

  void localvariable::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void localvariable::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const localvariable::name_type& localvariable::
  name () const
  {
    return this->name_.get ();
  }

  localvariable::name_type& localvariable::
  name ()
  {
    return this->name_.get ();
  }

  void localvariable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void localvariable::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const localvariable::shortname_type& localvariable::
  shortname () const
  {
    return this->shortname_.get ();
  }

  localvariable::shortname_type& localvariable::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void localvariable::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void localvariable::
  shortname (::std::auto_ptr< shortname_type > x)
  {
    this->shortname_.set (x);
  }

  const localvariable::shortname_html_optional& localvariable::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  localvariable::shortname_html_optional& localvariable::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void localvariable::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void localvariable::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void localvariable::
  shortname_html (::std::auto_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (x);
  }

  const localvariable::shortname_latex_optional& localvariable::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  localvariable::shortname_latex_optional& localvariable::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void localvariable::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void localvariable::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void localvariable::
  shortname_latex (::std::auto_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (x);
  }

  const localvariable::type_type& localvariable::
  type () const
  {
    return this->type_.get ();
  }

  localvariable::type_type& localvariable::
  type ()
  {
    return this->type_.get ();
  }

  void localvariable::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void localvariable::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const localvariable::unit_type& localvariable::
  unit () const
  {
    return this->unit_.get ();
  }

  localvariable::unit_type& localvariable::
  unit ()
  {
    return this->unit_.get ();
  }

  void localvariable::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void localvariable::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const localvariable::unit_html_optional& localvariable::
  unit_html () const
  {
    return this->unit_html_;
  }

  localvariable::unit_html_optional& localvariable::
  unit_html ()
  {
    return this->unit_html_;
  }

  void localvariable::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void localvariable::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void localvariable::
  unit_html (::std::auto_ptr< unit_html_type > x)
  {
    this->unit_html_.set (x);
  }

  const localvariable::unit_latex_optional& localvariable::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  localvariable::unit_latex_optional& localvariable::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void localvariable::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void localvariable::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void localvariable::
  unit_latex (::std::auto_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (x);
  }


  // view
  // 

  const view::scalar_view_type& view::
  scalar_view () const
  {
    return this->scalar_view_.get ();
  }

  view::scalar_view_type& view::
  scalar_view ()
  {
    return this->scalar_view_.get ();
  }

  void view::
  scalar_view (const scalar_view_type& x)
  {
    this->scalar_view_.set (x);
  }

  void view::
  scalar_view (::std::auto_ptr< scalar_view_type > x)
  {
    this->scalar_view_.set (x);
  }

  const view::vector_view_type& view::
  vector_view () const
  {
    return this->vector_view_.get ();
  }

  view::vector_view_type& view::
  vector_view ()
  {
    return this->vector_view_.get ();
  }

  void view::
  vector_view (const vector_view_type& x)
  {
    this->vector_view_.set (x);
  }

  void view::
  vector_view (::std::auto_ptr< vector_view_type > x)
  {
    this->vector_view_.set (x);
  }


  // scalar_view
  // 

  const scalar_view::default_sequence& scalar_view::
  default_ () const
  {
    return this->default__;
  }

  scalar_view::default_sequence& scalar_view::
  default_ ()
  {
    return this->default__;
  }

  void scalar_view::
  default_ (const default_sequence& s)
  {
    this->default__ = s;
  }


  // vector_view
  // 

  const vector_view::default_sequence& vector_view::
  default_ () const
  {
    return this->default__;
  }

  vector_view::default_sequence& vector_view::
  default_ ()
  {
    return this->default__;
  }

  void vector_view::
  default_ (const default_sequence& s)
  {
    this->default__ = s;
  }


  // volumeintegrals
  // 

  const volumeintegrals::volumeintegral_sequence& volumeintegrals::
  volumeintegral () const
  {
    return this->volumeintegral_;
  }

  volumeintegrals::volumeintegral_sequence& volumeintegrals::
  volumeintegral ()
  {
    return this->volumeintegral_;
  }

  void volumeintegrals::
  volumeintegral (const volumeintegral_sequence& s)
  {
    this->volumeintegral_ = s;
  }


  // volumeintegral
  // 

  const volumeintegral::expression_sequence& volumeintegral::
  expression () const
  {
    return this->expression_;
  }

  volumeintegral::expression_sequence& volumeintegral::
  expression ()
  {
    return this->expression_;
  }

  void volumeintegral::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const volumeintegral::id_type& volumeintegral::
  id () const
  {
    return this->id_.get ();
  }

  volumeintegral::id_type& volumeintegral::
  id ()
  {
    return this->id_.get ();
  }

  void volumeintegral::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void volumeintegral::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const volumeintegral::name_type& volumeintegral::
  name () const
  {
    return this->name_.get ();
  }

  volumeintegral::name_type& volumeintegral::
  name ()
  {
    return this->name_.get ();
  }

  void volumeintegral::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void volumeintegral::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const volumeintegral::shortname_type& volumeintegral::
  shortname () const
  {
    return this->shortname_.get ();
  }

  volumeintegral::shortname_type& volumeintegral::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void volumeintegral::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void volumeintegral::
  shortname (::std::auto_ptr< shortname_type > x)
  {
    this->shortname_.set (x);
  }

  const volumeintegral::shortname_html_optional& volumeintegral::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  volumeintegral::shortname_html_optional& volumeintegral::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void volumeintegral::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void volumeintegral::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void volumeintegral::
  shortname_html (::std::auto_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (x);
  }

  const volumeintegral::shortname_latex_optional& volumeintegral::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  volumeintegral::shortname_latex_optional& volumeintegral::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void volumeintegral::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void volumeintegral::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void volumeintegral::
  shortname_latex (::std::auto_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (x);
  }

  const volumeintegral::unit_type& volumeintegral::
  unit () const
  {
    return this->unit_.get ();
  }

  volumeintegral::unit_type& volumeintegral::
  unit ()
  {
    return this->unit_.get ();
  }

  void volumeintegral::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void volumeintegral::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const volumeintegral::unit_html_optional& volumeintegral::
  unit_html () const
  {
    return this->unit_html_;
  }

  volumeintegral::unit_html_optional& volumeintegral::
  unit_html ()
  {
    return this->unit_html_;
  }

  void volumeintegral::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void volumeintegral::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void volumeintegral::
  unit_html (::std::auto_ptr< unit_html_type > x)
  {
    this->unit_html_.set (x);
  }

  const volumeintegral::unit_latex_optional& volumeintegral::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  volumeintegral::unit_latex_optional& volumeintegral::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void volumeintegral::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void volumeintegral::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void volumeintegral::
  unit_latex (::std::auto_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (x);
  }


  // surfaceintegrals
  // 

  const surfaceintegrals::surfaceintegral_sequence& surfaceintegrals::
  surfaceintegral () const
  {
    return this->surfaceintegral_;
  }

  surfaceintegrals::surfaceintegral_sequence& surfaceintegrals::
  surfaceintegral ()
  {
    return this->surfaceintegral_;
  }

  void surfaceintegrals::
  surfaceintegral (const surfaceintegral_sequence& s)
  {
    this->surfaceintegral_ = s;
  }


  // surfaceintegral
  // 

  const surfaceintegral::expression_sequence& surfaceintegral::
  expression () const
  {
    return this->expression_;
  }

  surfaceintegral::expression_sequence& surfaceintegral::
  expression ()
  {
    return this->expression_;
  }

  void surfaceintegral::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const surfaceintegral::id_type& surfaceintegral::
  id () const
  {
    return this->id_.get ();
  }

  surfaceintegral::id_type& surfaceintegral::
  id ()
  {
    return this->id_.get ();
  }

  void surfaceintegral::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void surfaceintegral::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const surfaceintegral::name_type& surfaceintegral::
  name () const
  {
    return this->name_.get ();
  }

  surfaceintegral::name_type& surfaceintegral::
  name ()
  {
    return this->name_.get ();
  }

  void surfaceintegral::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void surfaceintegral::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const surfaceintegral::shortname_type& surfaceintegral::
  shortname () const
  {
    return this->shortname_.get ();
  }

  surfaceintegral::shortname_type& surfaceintegral::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void surfaceintegral::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void surfaceintegral::
  shortname (::std::auto_ptr< shortname_type > x)
  {
    this->shortname_.set (x);
  }

  const surfaceintegral::shortname_html_optional& surfaceintegral::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  surfaceintegral::shortname_html_optional& surfaceintegral::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void surfaceintegral::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void surfaceintegral::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void surfaceintegral::
  shortname_html (::std::auto_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (x);
  }

  const surfaceintegral::shortname_latex_optional& surfaceintegral::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  surfaceintegral::shortname_latex_optional& surfaceintegral::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void surfaceintegral::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void surfaceintegral::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void surfaceintegral::
  shortname_latex (::std::auto_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (x);
  }

  const surfaceintegral::unit_type& surfaceintegral::
  unit () const
  {
    return this->unit_.get ();
  }

  surfaceintegral::unit_type& surfaceintegral::
  unit ()
  {
    return this->unit_.get ();
  }

  void surfaceintegral::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void surfaceintegral::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const surfaceintegral::unit_html_optional& surfaceintegral::
  unit_html () const
  {
    return this->unit_html_;
  }

  surfaceintegral::unit_html_optional& surfaceintegral::
  unit_html ()
  {
    return this->unit_html_;
  }

  void surfaceintegral::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void surfaceintegral::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void surfaceintegral::
  unit_html (::std::auto_ptr< unit_html_type > x)
  {
    this->unit_html_.set (x);
  }

  const surfaceintegral::unit_latex_optional& surfaceintegral::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  surfaceintegral::unit_latex_optional& surfaceintegral::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void surfaceintegral::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void surfaceintegral::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void surfaceintegral::
  unit_latex (::std::auto_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (x);
  }


  // force
  // 

  const force::expression_sequence& force::
  expression () const
  {
    return this->expression_;
  }

  force::expression_sequence& force::
  expression ()
  {
    return this->expression_;
  }

  void force::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }


  // volume
  // 

  const volume::quantity_sequence& volume::
  quantity () const
  {
    return this->quantity_;
  }

  volume::quantity_sequence& volume::
  quantity ()
  {
    return this->quantity_;
  }

  void volume::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const volume::weakforms_volume_type& volume::
  weakforms_volume () const
  {
    return this->weakforms_volume_.get ();
  }

  volume::weakforms_volume_type& volume::
  weakforms_volume ()
  {
    return this->weakforms_volume_.get ();
  }

  void volume::
  weakforms_volume (const weakforms_volume_type& x)
  {
    this->weakforms_volume_.set (x);
  }

  void volume::
  weakforms_volume (::std::auto_ptr< weakforms_volume_type > x)
  {
    this->weakforms_volume_.set (x);
  }


  // surface
  // 

  const surface::quantity_sequence& surface::
  quantity () const
  {
    return this->quantity_;
  }

  surface::quantity_sequence& surface::
  quantity ()
  {
    return this->quantity_;
  }

  void surface::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const surface::weakforms_surface_type& surface::
  weakforms_surface () const
  {
    return this->weakforms_surface_.get ();
  }

  surface::weakforms_surface_type& surface::
  weakforms_surface ()
  {
    return this->weakforms_surface_.get ();
  }

  void surface::
  weakforms_surface (const weakforms_surface_type& x)
  {
    this->weakforms_surface_.set (x);
  }

  void surface::
  weakforms_surface (::std::auto_ptr< weakforms_surface_type > x)
  {
    this->weakforms_surface_.set (x);
  }


  // weakforms_surface
  // 

  const weakforms_surface::group_optional& weakforms_surface::
  group () const
  {
    return this->group_;
  }

  weakforms_surface::group_optional& weakforms_surface::
  group ()
  {
    return this->group_;
  }

  void weakforms_surface::
  group (const group_type& x)
  {
    this->group_.set (x);
  }

  void weakforms_surface::
  group (const group_optional& x)
  {
    this->group_ = x;
  }

  void weakforms_surface::
  group (::std::auto_ptr< group_type > x)
  {
    this->group_.set (x);
  }

  const weakforms_surface::weakform_surface_sequence& weakforms_surface::
  weakform_surface () const
  {
    return this->weakform_surface_;
  }

  weakforms_surface::weakform_surface_sequence& weakforms_surface::
  weakform_surface ()
  {
    return this->weakform_surface_;
  }

  void weakforms_surface::
  weakform_surface (const weakform_surface_sequence& s)
  {
    this->weakform_surface_ = s;
  }


  // weakform_surface
  // 

  const weakform_surface::boundary_sequence& weakform_surface::
  boundary () const
  {
    return this->boundary_;
  }

  weakform_surface::boundary_sequence& weakform_surface::
  boundary ()
  {
    return this->boundary_;
  }

  void weakform_surface::
  boundary (const boundary_sequence& s)
  {
    this->boundary_ = s;
  }

  const weakform_surface::quantity_sequence& weakform_surface::
  quantity () const
  {
    return this->quantity_;
  }

  weakform_surface::quantity_sequence& weakform_surface::
  quantity ()
  {
    return this->quantity_;
  }

  void weakform_surface::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const weakform_surface::matrix_form_sequence& weakform_surface::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  weakform_surface::matrix_form_sequence& weakform_surface::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void weakform_surface::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const weakform_surface::vector_form_sequence& weakform_surface::
  vector_form () const
  {
    return this->vector_form_;
  }

  weakform_surface::vector_form_sequence& weakform_surface::
  vector_form ()
  {
    return this->vector_form_;
  }

  void weakform_surface::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const weakform_surface::analysistype_type& weakform_surface::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  weakform_surface::analysistype_type& weakform_surface::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void weakform_surface::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void weakform_surface::
  analysistype (::std::auto_ptr< analysistype_type > x)
  {
    this->analysistype_.set (x);
  }

  const weakform_surface::default_optional& weakform_surface::
  default_ () const
  {
    return this->default__;
  }

  weakform_surface::default_optional& weakform_surface::
  default_ ()
  {
    return this->default__;
  }

  void weakform_surface::
  default_ (const default_type& x)
  {
    this->default__.set (x);
  }

  void weakform_surface::
  default_ (const default_optional& x)
  {
    this->default__ = x;
  }

  void weakform_surface::
  default_ (::std::auto_ptr< default_type > x)
  {
    this->default__.set (x);
  }


  // expression
  // 

  const expression::analysistype_type& expression::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  expression::analysistype_type& expression::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void expression::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void expression::
  analysistype (::std::auto_ptr< analysistype_type > x)
  {
    this->analysistype_.set (x);
  }

  const expression::axi_optional& expression::
  axi () const
  {
    return this->axi_;
  }

  expression::axi_optional& expression::
  axi ()
  {
    return this->axi_;
  }

  void expression::
  axi (const axi_type& x)
  {
    this->axi_.set (x);
  }

  void expression::
  axi (const axi_optional& x)
  {
    this->axi_ = x;
  }

  void expression::
  axi (::std::auto_ptr< axi_type > x)
  {
    this->axi_.set (x);
  }

  const expression::axi_r_optional& expression::
  axi_r () const
  {
    return this->axi_r_;
  }

  expression::axi_r_optional& expression::
  axi_r ()
  {
    return this->axi_r_;
  }

  void expression::
  axi_r (const axi_r_type& x)
  {
    this->axi_r_.set (x);
  }

  void expression::
  axi_r (const axi_r_optional& x)
  {
    this->axi_r_ = x;
  }

  void expression::
  axi_r (::std::auto_ptr< axi_r_type > x)
  {
    this->axi_r_.set (x);
  }

  const expression::axi_z_optional& expression::
  axi_z () const
  {
    return this->axi_z_;
  }

  expression::axi_z_optional& expression::
  axi_z ()
  {
    return this->axi_z_;
  }

  void expression::
  axi_z (const axi_z_type& x)
  {
    this->axi_z_.set (x);
  }

  void expression::
  axi_z (const axi_z_optional& x)
  {
    this->axi_z_ = x;
  }

  void expression::
  axi_z (::std::auto_ptr< axi_z_type > x)
  {
    this->axi_z_.set (x);
  }

  const expression::axi_phi_optional& expression::
  axi_phi () const
  {
    return this->axi_phi_;
  }

  expression::axi_phi_optional& expression::
  axi_phi ()
  {
    return this->axi_phi_;
  }

  void expression::
  axi_phi (const axi_phi_type& x)
  {
    this->axi_phi_.set (x);
  }

  void expression::
  axi_phi (const axi_phi_optional& x)
  {
    this->axi_phi_ = x;
  }

  void expression::
  axi_phi (::std::auto_ptr< axi_phi_type > x)
  {
    this->axi_phi_.set (x);
  }

  const expression::planar_optional& expression::
  planar () const
  {
    return this->planar_;
  }

  expression::planar_optional& expression::
  planar ()
  {
    return this->planar_;
  }

  void expression::
  planar (const planar_type& x)
  {
    this->planar_.set (x);
  }

  void expression::
  planar (const planar_optional& x)
  {
    this->planar_ = x;
  }

  void expression::
  planar (::std::auto_ptr< planar_type > x)
  {
    this->planar_.set (x);
  }

  const expression::planar_x_optional& expression::
  planar_x () const
  {
    return this->planar_x_;
  }

  expression::planar_x_optional& expression::
  planar_x ()
  {
    return this->planar_x_;
  }

  void expression::
  planar_x (const planar_x_type& x)
  {
    this->planar_x_.set (x);
  }

  void expression::
  planar_x (const planar_x_optional& x)
  {
    this->planar_x_ = x;
  }

  void expression::
  planar_x (::std::auto_ptr< planar_x_type > x)
  {
    this->planar_x_.set (x);
  }

  const expression::planar_y_optional& expression::
  planar_y () const
  {
    return this->planar_y_;
  }

  expression::planar_y_optional& expression::
  planar_y ()
  {
    return this->planar_y_;
  }

  void expression::
  planar_y (const planar_y_type& x)
  {
    this->planar_y_.set (x);
  }

  void expression::
  planar_y (const planar_y_optional& x)
  {
    this->planar_y_ = x;
  }

  void expression::
  planar_y (::std::auto_ptr< planar_y_type > x)
  {
    this->planar_y_.set (x);
  }

  const expression::planar_z_optional& expression::
  planar_z () const
  {
    return this->planar_z_;
  }

  expression::planar_z_optional& expression::
  planar_z ()
  {
    return this->planar_z_;
  }

  void expression::
  planar_z (const planar_z_type& x)
  {
    this->planar_z_.set (x);
  }

  void expression::
  planar_z (const planar_z_optional& x)
  {
    this->planar_z_ = x;
  }

  void expression::
  planar_z (::std::auto_ptr< planar_z_type > x)
  {
    this->planar_z_.set (x);
  }


  // default_
  // 

  const default_::analysistype_type& default_::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  default_::analysistype_type& default_::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void default_::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void default_::
  analysistype (::std::auto_ptr< analysistype_type > x)
  {
    this->analysistype_.set (x);
  }

  const default_::id_type& default_::
  id () const
  {
    return this->id_.get ();
  }

  default_::id_type& default_::
  id ()
  {
    return this->id_.get ();
  }

  void default_::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void default_::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }


  // quantity
  // 

  const quantity::id_type& quantity::
  id () const
  {
    return this->id_.get ();
  }

  quantity::id_type& quantity::
  id ()
  {
    return this->id_.get ();
  }

  void quantity::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void quantity::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const quantity::condition_optional& quantity::
  condition () const
  {
    return this->condition_;
  }

  quantity::condition_optional& quantity::
  condition ()
  {
    return this->condition_;
  }

  void quantity::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void quantity::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void quantity::
  condition (::std::auto_ptr< condition_type > x)
  {
    this->condition_.set (x);
  }

  const quantity::default_optional& quantity::
  default_ () const
  {
    return this->default__;
  }

  quantity::default_optional& quantity::
  default_ ()
  {
    return this->default__;
  }

  void quantity::
  default_ (const default_type& x)
  {
    this->default__.set (x);
  }

  void quantity::
  default_ (const default_optional& x)
  {
    this->default__ = x;
  }

  const quantity::nonlinearity_planar_optional& quantity::
  nonlinearity_planar () const
  {
    return this->nonlinearity_planar_;
  }

  quantity::nonlinearity_planar_optional& quantity::
  nonlinearity_planar ()
  {
    return this->nonlinearity_planar_;
  }

  void quantity::
  nonlinearity_planar (const nonlinearity_planar_type& x)
  {
    this->nonlinearity_planar_.set (x);
  }

  void quantity::
  nonlinearity_planar (const nonlinearity_planar_optional& x)
  {
    this->nonlinearity_planar_ = x;
  }

  void quantity::
  nonlinearity_planar (::std::auto_ptr< nonlinearity_planar_type > x)
  {
    this->nonlinearity_planar_.set (x);
  }

  const quantity::nonlinearity_axi_optional& quantity::
  nonlinearity_axi () const
  {
    return this->nonlinearity_axi_;
  }

  quantity::nonlinearity_axi_optional& quantity::
  nonlinearity_axi ()
  {
    return this->nonlinearity_axi_;
  }

  void quantity::
  nonlinearity_axi (const nonlinearity_axi_type& x)
  {
    this->nonlinearity_axi_.set (x);
  }

  void quantity::
  nonlinearity_axi (const nonlinearity_axi_optional& x)
  {
    this->nonlinearity_axi_ = x;
  }

  void quantity::
  nonlinearity_axi (::std::auto_ptr< nonlinearity_axi_type > x)
  {
    this->nonlinearity_axi_.set (x);
  }

  const quantity::dependence_optional& quantity::
  dependence () const
  {
    return this->dependence_;
  }

  quantity::dependence_optional& quantity::
  dependence ()
  {
    return this->dependence_;
  }

  void quantity::
  dependence (const dependence_type& x)
  {
    this->dependence_.set (x);
  }

  void quantity::
  dependence (const dependence_optional& x)
  {
    this->dependence_ = x;
  }

  void quantity::
  dependence (::std::auto_ptr< dependence_type > x)
  {
    this->dependence_.set (x);
  }

  const quantity::name_optional& quantity::
  name () const
  {
    return this->name_;
  }

  quantity::name_optional& quantity::
  name ()
  {
    return this->name_;
  }

  void quantity::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void quantity::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void quantity::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const quantity::shortname_optional& quantity::
  shortname () const
  {
    return this->shortname_;
  }

  quantity::shortname_optional& quantity::
  shortname ()
  {
    return this->shortname_;
  }

  void quantity::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void quantity::
  shortname (const shortname_optional& x)
  {
    this->shortname_ = x;
  }

  void quantity::
  shortname (::std::auto_ptr< shortname_type > x)
  {
    this->shortname_.set (x);
  }

  const quantity::shortname_html_optional& quantity::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  quantity::shortname_html_optional& quantity::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void quantity::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void quantity::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void quantity::
  shortname_html (::std::auto_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (x);
  }

  const quantity::shortname_latex_optional& quantity::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  quantity::shortname_latex_optional& quantity::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void quantity::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void quantity::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void quantity::
  shortname_latex (::std::auto_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (x);
  }

  const quantity::shortname_dependence_optional& quantity::
  shortname_dependence () const
  {
    return this->shortname_dependence_;
  }

  quantity::shortname_dependence_optional& quantity::
  shortname_dependence ()
  {
    return this->shortname_dependence_;
  }

  void quantity::
  shortname_dependence (const shortname_dependence_type& x)
  {
    this->shortname_dependence_.set (x);
  }

  void quantity::
  shortname_dependence (const shortname_dependence_optional& x)
  {
    this->shortname_dependence_ = x;
  }

  void quantity::
  shortname_dependence (::std::auto_ptr< shortname_dependence_type > x)
  {
    this->shortname_dependence_.set (x);
  }

  const quantity::shortname_dependence_html_optional& quantity::
  shortname_dependence_html () const
  {
    return this->shortname_dependence_html_;
  }

  quantity::shortname_dependence_html_optional& quantity::
  shortname_dependence_html ()
  {
    return this->shortname_dependence_html_;
  }

  void quantity::
  shortname_dependence_html (const shortname_dependence_html_type& x)
  {
    this->shortname_dependence_html_.set (x);
  }

  void quantity::
  shortname_dependence_html (const shortname_dependence_html_optional& x)
  {
    this->shortname_dependence_html_ = x;
  }

  void quantity::
  shortname_dependence_html (::std::auto_ptr< shortname_dependence_html_type > x)
  {
    this->shortname_dependence_html_.set (x);
  }

  const quantity::unit_optional& quantity::
  unit () const
  {
    return this->unit_;
  }

  quantity::unit_optional& quantity::
  unit ()
  {
    return this->unit_;
  }

  void quantity::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void quantity::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void quantity::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const quantity::unit_html_optional& quantity::
  unit_html () const
  {
    return this->unit_html_;
  }

  quantity::unit_html_optional& quantity::
  unit_html ()
  {
    return this->unit_html_;
  }

  void quantity::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void quantity::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void quantity::
  unit_html (::std::auto_ptr< unit_html_type > x)
  {
    this->unit_html_.set (x);
  }

  const quantity::unit_latex_optional& quantity::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  quantity::unit_latex_optional& quantity::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void quantity::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void quantity::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void quantity::
  unit_latex (::std::auto_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (x);
  }


  // weakforms_volume
  // 

  const weakforms_volume::weakform_volume_sequence& weakforms_volume::
  weakform_volume () const
  {
    return this->weakform_volume_;
  }

  weakforms_volume::weakform_volume_sequence& weakforms_volume::
  weakform_volume ()
  {
    return this->weakform_volume_;
  }

  void weakforms_volume::
  weakform_volume (const weakform_volume_sequence& s)
  {
    this->weakform_volume_ = s;
  }


  // weakform_volume
  // 

  const weakform_volume::quantity_sequence& weakform_volume::
  quantity () const
  {
    return this->quantity_;
  }

  weakform_volume::quantity_sequence& weakform_volume::
  quantity ()
  {
    return this->quantity_;
  }

  void weakform_volume::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const weakform_volume::matrix_form_sequence& weakform_volume::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  weakform_volume::matrix_form_sequence& weakform_volume::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void weakform_volume::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const weakform_volume::vector_form_sequence& weakform_volume::
  vector_form () const
  {
    return this->vector_form_;
  }

  weakform_volume::vector_form_sequence& weakform_volume::
  vector_form ()
  {
    return this->vector_form_;
  }

  void weakform_volume::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const weakform_volume::analysistype_type& weakform_volume::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  weakform_volume::analysistype_type& weakform_volume::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void weakform_volume::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void weakform_volume::
  analysistype (::std::auto_ptr< analysistype_type > x)
  {
    this->analysistype_.set (x);
  }

  const weakform_volume::equation_type& weakform_volume::
  equation () const
  {
    return this->equation_.get ();
  }

  weakform_volume::equation_type& weakform_volume::
  equation ()
  {
    return this->equation_.get ();
  }

  void weakform_volume::
  equation (const equation_type& x)
  {
    this->equation_.set (x);
  }

  void weakform_volume::
  equation (::std::auto_ptr< equation_type > x)
  {
    this->equation_.set (x);
  }


  // group
  // 

  const group::quantity_sequence& group::
  quantity () const
  {
    return this->quantity_;
  }

  group::quantity_sequence& group::
  quantity ()
  {
    return this->quantity_;
  }

  void group::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const group::name_optional& group::
  name () const
  {
    return this->name_;
  }

  group::name_optional& group::
  name ()
  {
    return this->name_;
  }

  void group::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void group::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void group::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // matrix_form
  // 

  const matrix_form::id_type& matrix_form::
  id () const
  {
    return this->id_.get ();
  }

  matrix_form::id_type& matrix_form::
  id ()
  {
    return this->id_.get ();
  }

  void matrix_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void matrix_form::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const matrix_form::i_type& matrix_form::
  i () const
  {
    return this->i_.get ();
  }

  matrix_form::i_type& matrix_form::
  i ()
  {
    return this->i_.get ();
  }

  void matrix_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  const matrix_form::j_type& matrix_form::
  j () const
  {
    return this->j_.get ();
  }

  matrix_form::j_type& matrix_form::
  j ()
  {
    return this->j_.get ();
  }

  void matrix_form::
  j (const j_type& x)
  {
    this->j_.set (x);
  }

  const matrix_form::planar_linear_type& matrix_form::
  planar_linear () const
  {
    return this->planar_linear_.get ();
  }

  matrix_form::planar_linear_type& matrix_form::
  planar_linear ()
  {
    return this->planar_linear_.get ();
  }

  void matrix_form::
  planar_linear (const planar_linear_type& x)
  {
    this->planar_linear_.set (x);
  }

  void matrix_form::
  planar_linear (::std::auto_ptr< planar_linear_type > x)
  {
    this->planar_linear_.set (x);
  }

  const matrix_form::axi_linear_type& matrix_form::
  axi_linear () const
  {
    return this->axi_linear_.get ();
  }

  matrix_form::axi_linear_type& matrix_form::
  axi_linear ()
  {
    return this->axi_linear_.get ();
  }

  void matrix_form::
  axi_linear (const axi_linear_type& x)
  {
    this->axi_linear_.set (x);
  }

  void matrix_form::
  axi_linear (::std::auto_ptr< axi_linear_type > x)
  {
    this->axi_linear_.set (x);
  }

  const matrix_form::planar_newton_type& matrix_form::
  planar_newton () const
  {
    return this->planar_newton_.get ();
  }

  matrix_form::planar_newton_type& matrix_form::
  planar_newton ()
  {
    return this->planar_newton_.get ();
  }

  void matrix_form::
  planar_newton (const planar_newton_type& x)
  {
    this->planar_newton_.set (x);
  }

  void matrix_form::
  planar_newton (::std::auto_ptr< planar_newton_type > x)
  {
    this->planar_newton_.set (x);
  }

  const matrix_form::axi_newton_type& matrix_form::
  axi_newton () const
  {
    return this->axi_newton_.get ();
  }

  matrix_form::axi_newton_type& matrix_form::
  axi_newton ()
  {
    return this->axi_newton_.get ();
  }

  void matrix_form::
  axi_newton (const axi_newton_type& x)
  {
    this->axi_newton_.set (x);
  }

  void matrix_form::
  axi_newton (::std::auto_ptr< axi_newton_type > x)
  {
    this->axi_newton_.set (x);
  }

  const matrix_form::symmetric_optional& matrix_form::
  symmetric () const
  {
    return this->symmetric_;
  }

  matrix_form::symmetric_optional& matrix_form::
  symmetric ()
  {
    return this->symmetric_;
  }

  void matrix_form::
  symmetric (const symmetric_type& x)
  {
    this->symmetric_.set (x);
  }

  void matrix_form::
  symmetric (const symmetric_optional& x)
  {
    this->symmetric_ = x;
  }


  // vector_form
  // 

  const vector_form::id_type& vector_form::
  id () const
  {
    return this->id_.get ();
  }

  vector_form::id_type& vector_form::
  id ()
  {
    return this->id_.get ();
  }

  void vector_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void vector_form::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const vector_form::i_type& vector_form::
  i () const
  {
    return this->i_.get ();
  }

  vector_form::i_type& vector_form::
  i ()
  {
    return this->i_.get ();
  }

  void vector_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  const vector_form::j_type& vector_form::
  j () const
  {
    return this->j_.get ();
  }

  vector_form::j_type& vector_form::
  j ()
  {
    return this->j_.get ();
  }

  void vector_form::
  j (const j_type& x)
  {
    this->j_.set (x);
  }

  const vector_form::planar_linear_type& vector_form::
  planar_linear () const
  {
    return this->planar_linear_.get ();
  }

  vector_form::planar_linear_type& vector_form::
  planar_linear ()
  {
    return this->planar_linear_.get ();
  }

  void vector_form::
  planar_linear (const planar_linear_type& x)
  {
    this->planar_linear_.set (x);
  }

  void vector_form::
  planar_linear (::std::auto_ptr< planar_linear_type > x)
  {
    this->planar_linear_.set (x);
  }

  const vector_form::axi_linear_type& vector_form::
  axi_linear () const
  {
    return this->axi_linear_.get ();
  }

  vector_form::axi_linear_type& vector_form::
  axi_linear ()
  {
    return this->axi_linear_.get ();
  }

  void vector_form::
  axi_linear (const axi_linear_type& x)
  {
    this->axi_linear_.set (x);
  }

  void vector_form::
  axi_linear (::std::auto_ptr< axi_linear_type > x)
  {
    this->axi_linear_.set (x);
  }

  const vector_form::planar_newton_type& vector_form::
  planar_newton () const
  {
    return this->planar_newton_.get ();
  }

  vector_form::planar_newton_type& vector_form::
  planar_newton ()
  {
    return this->planar_newton_.get ();
  }

  void vector_form::
  planar_newton (const planar_newton_type& x)
  {
    this->planar_newton_.set (x);
  }

  void vector_form::
  planar_newton (::std::auto_ptr< planar_newton_type > x)
  {
    this->planar_newton_.set (x);
  }

  const vector_form::axi_newton_type& vector_form::
  axi_newton () const
  {
    return this->axi_newton_.get ();
  }

  vector_form::axi_newton_type& vector_form::
  axi_newton ()
  {
    return this->axi_newton_.get ();
  }

  void vector_form::
  axi_newton (const axi_newton_type& x)
  {
    this->axi_newton_.set (x);
  }

  void vector_form::
  axi_newton (::std::auto_ptr< axi_newton_type > x)
  {
    this->axi_newton_.set (x);
  }


  // essential_form
  // 

  const essential_form::id_type& essential_form::
  id () const
  {
    return this->id_.get ();
  }

  essential_form::id_type& essential_form::
  id ()
  {
    return this->id_.get ();
  }

  void essential_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void essential_form::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const essential_form::i_type& essential_form::
  i () const
  {
    return this->i_.get ();
  }

  essential_form::i_type& essential_form::
  i ()
  {
    return this->i_.get ();
  }

  void essential_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  const essential_form::axi_linear_type& essential_form::
  axi_linear () const
  {
    return this->axi_linear_.get ();
  }

  essential_form::axi_linear_type& essential_form::
  axi_linear ()
  {
    return this->axi_linear_.get ();
  }

  void essential_form::
  axi_linear (const axi_linear_type& x)
  {
    this->axi_linear_.set (x);
  }

  void essential_form::
  axi_linear (::std::auto_ptr< axi_linear_type > x)
  {
    this->axi_linear_.set (x);
  }

  const essential_form::planar_linear_type& essential_form::
  planar_linear () const
  {
    return this->planar_linear_.get ();
  }

  essential_form::planar_linear_type& essential_form::
  planar_linear ()
  {
    return this->planar_linear_.get ();
  }

  void essential_form::
  planar_linear (const planar_linear_type& x)
  {
    this->planar_linear_.set (x);
  }

  void essential_form::
  planar_linear (::std::auto_ptr< planar_linear_type > x)
  {
    this->planar_linear_.set (x);
  }

  const essential_form::axi_newton_type& essential_form::
  axi_newton () const
  {
    return this->axi_newton_.get ();
  }

  essential_form::axi_newton_type& essential_form::
  axi_newton ()
  {
    return this->axi_newton_.get ();
  }

  void essential_form::
  axi_newton (const axi_newton_type& x)
  {
    this->axi_newton_.set (x);
  }

  void essential_form::
  axi_newton (::std::auto_ptr< axi_newton_type > x)
  {
    this->axi_newton_.set (x);
  }

  const essential_form::planar_newton_type& essential_form::
  planar_newton () const
  {
    return this->planar_newton_.get ();
  }

  essential_form::planar_newton_type& essential_form::
  planar_newton ()
  {
    return this->planar_newton_.get ();
  }

  void essential_form::
  planar_newton (const planar_newton_type& x)
  {
    this->planar_newton_.set (x);
  }

  void essential_form::
  planar_newton (::std::auto_ptr< planar_newton_type > x)
  {
    this->planar_newton_.set (x);
  }


  // boundary
  // 

  const boundary::quantity_sequence& boundary::
  quantity () const
  {
    return this->quantity_;
  }

  boundary::quantity_sequence& boundary::
  quantity ()
  {
    return this->quantity_;
  }

  void boundary::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const boundary::vector_form_sequence& boundary::
  vector_form () const
  {
    return this->vector_form_;
  }

  boundary::vector_form_sequence& boundary::
  vector_form ()
  {
    return this->vector_form_;
  }

  void boundary::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const boundary::matrix_form_sequence& boundary::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  boundary::matrix_form_sequence& boundary::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void boundary::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const boundary::essential_form_sequence& boundary::
  essential_form () const
  {
    return this->essential_form_;
  }

  boundary::essential_form_sequence& boundary::
  essential_form ()
  {
    return this->essential_form_;
  }

  void boundary::
  essential_form (const essential_form_sequence& s)
  {
    this->essential_form_ = s;
  }

  const boundary::id_type& boundary::
  id () const
  {
    return this->id_.get ();
  }

  boundary::id_type& boundary::
  id ()
  {
    return this->id_.get ();
  }

  void boundary::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void boundary::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const boundary::name_type& boundary::
  name () const
  {
    return this->name_.get ();
  }

  boundary::name_type& boundary::
  name ()
  {
    return this->name_.get ();
  }

  void boundary::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void boundary::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const boundary::equation_type& boundary::
  equation () const
  {
    return this->equation_.get ();
  }

  boundary::equation_type& boundary::
  equation ()
  {
    return this->equation_.get ();
  }

  void boundary::
  equation (const equation_type& x)
  {
    this->equation_.set (x);
  }

  void boundary::
  equation (::std::auto_ptr< equation_type > x)
  {
    this->equation_.set (x);
  }


  // field_item
  // 

  const field_item::field_key_type& field_item::
  field_key () const
  {
    return this->field_key_.get ();
  }

  field_item::field_key_type& field_item::
  field_key ()
  {
    return this->field_key_.get ();
  }

  void field_item::
  field_key (const field_key_type& x)
  {
    this->field_key_.set (x);
  }

  void field_item::
  field_key (::std::auto_ptr< field_key_type > x)
  {
    this->field_key_.set (x);
  }

  const field_item::field_value_type& field_item::
  field_value () const
  {
    return this->field_value_.get ();
  }

  field_item::field_value_type& field_item::
  field_value ()
  {
    return this->field_value_.get ();
  }

  void field_item::
  field_value (const field_value_type& x)
  {
    this->field_value_.set (x);
  }

  void field_item::
  field_value (::std::auto_ptr< field_value_type > x)
  {
    this->field_value_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace XMLModule
{
  // module
  //

  module::
  module (const general_type& general,
          const constants_type& constants,
          const spaces_type& spaces,
          const volume_type& volume,
          const surface_type& surface,
          const preprocessor_type& preprocessor,
          const postprocessor_type& postprocessor)
  : ::xml_schema::type (),
    general_ (general, ::xml_schema::flags (), this),
    constants_ (constants, ::xml_schema::flags (), this),
    spaces_ (spaces, ::xml_schema::flags (), this),
    volume_ (volume, ::xml_schema::flags (), this),
    surface_ (surface, ::xml_schema::flags (), this),
    preprocessor_ (preprocessor, ::xml_schema::flags (), this),
    postprocessor_ (postprocessor, ::xml_schema::flags (), this)
  {
  }

  module::
  module (::std::auto_ptr< general_type >& general,
          ::std::auto_ptr< constants_type >& constants,
          ::std::auto_ptr< spaces_type >& spaces,
          ::std::auto_ptr< volume_type >& volume,
          ::std::auto_ptr< surface_type >& surface,
          ::std::auto_ptr< preprocessor_type >& preprocessor,
          ::std::auto_ptr< postprocessor_type >& postprocessor)
  : ::xml_schema::type (),
    general_ (general, ::xml_schema::flags (), this),
    constants_ (constants, ::xml_schema::flags (), this),
    spaces_ (spaces, ::xml_schema::flags (), this),
    volume_ (volume, ::xml_schema::flags (), this),
    surface_ (surface, ::xml_schema::flags (), this),
    preprocessor_ (preprocessor, ::xml_schema::flags (), this),
    postprocessor_ (postprocessor, ::xml_schema::flags (), this)
  {
  }

  module::
  module (const module& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    general_ (x.general_, f, this),
    constants_ (x.constants_, f, this),
    spaces_ (x.spaces_, f, this),
    volume_ (x.volume_, f, this),
    surface_ (x.surface_, f, this),
    preprocessor_ (x.preprocessor_, f, this),
    postprocessor_ (x.postprocessor_, f, this)
  {
  }

  module::
  module (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    general_ (f, this),
    constants_ (f, this),
    spaces_ (f, this),
    volume_ (f, this),
    surface_ (f, this),
    preprocessor_ (f, this),
    postprocessor_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void module::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // general
      //
      if (n.name () == "general" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< general_type > r (
          general_traits::create (i, f, this));

        if (!general_.present ())
        {
          this->general_.set (r);
          continue;
        }
      }

      // constants
      //
      if (n.name () == "constants" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< constants_type > r (
          constants_traits::create (i, f, this));

        if (!constants_.present ())
        {
          this->constants_.set (r);
          continue;
        }
      }

      // spaces
      //
      if (n.name () == "spaces" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< spaces_type > r (
          spaces_traits::create (i, f, this));

        if (!spaces_.present ())
        {
          this->spaces_.set (r);
          continue;
        }
      }

      // volume
      //
      if (n.name () == "volume" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< volume_type > r (
          volume_traits::create (i, f, this));

        if (!volume_.present ())
        {
          this->volume_.set (r);
          continue;
        }
      }

      // surface
      //
      if (n.name () == "surface" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< surface_type > r (
          surface_traits::create (i, f, this));

        if (!surface_.present ())
        {
          this->surface_.set (r);
          continue;
        }
      }

      // preprocessor
      //
      if (n.name () == "preprocessor" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< preprocessor_type > r (
          preprocessor_traits::create (i, f, this));

        if (!preprocessor_.present ())
        {
          this->preprocessor_.set (r);
          continue;
        }
      }

      // postprocessor
      //
      if (n.name () == "postprocessor" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< postprocessor_type > r (
          postprocessor_traits::create (i, f, this));

        if (!postprocessor_.present ())
        {
          this->postprocessor_.set (r);
          continue;
        }
      }

      break;
    }

    if (!general_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "general",
        "XMLModule");
    }

    if (!constants_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "constants",
        "XMLModule");
    }

    if (!spaces_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spaces",
        "XMLModule");
    }

    if (!volume_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "volume",
        "XMLModule");
    }

    if (!surface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surface",
        "XMLModule");
    }

    if (!preprocessor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "preprocessor",
        "XMLModule");
    }

    if (!postprocessor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "postprocessor",
        "XMLModule");
    }
  }

  module* module::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class module (*this, f, c);
  }

  module::
  ~module ()
  {
  }

  // general
  //

  general::
  general (const description_type& description,
           const analyses_type& analyses,
           const id_type& id,
           const name_type& name)
  : ::xml_schema::type (),
    description_ (description, ::xml_schema::flags (), this),
    analyses_ (analyses, ::xml_schema::flags (), this),
    deformed_shape_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  general::
  general (const description_type& description,
           ::std::auto_ptr< analyses_type >& analyses,
           const id_type& id,
           const name_type& name)
  : ::xml_schema::type (),
    description_ (description, ::xml_schema::flags (), this),
    analyses_ (analyses, ::xml_schema::flags (), this),
    deformed_shape_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  general::
  general (const general& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    analyses_ (x.analyses_, f, this),
    deformed_shape_ (x.deformed_shape_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  general::
  general (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (f, this),
    analyses_ (f, this),
    deformed_shape_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void general::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // analyses
      //
      if (n.name () == "analyses" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< analyses_type > r (
          analyses_traits::create (i, f, this));

        if (!analyses_.present ())
        {
          this->analyses_.set (r);
          continue;
        }
      }

      break;
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "XMLModule");
    }

    if (!analyses_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "analyses",
        "XMLModule");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "deformed_shape" && n.namespace_ ().empty ())
      {
        this->deformed_shape_.set (deformed_shape_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  general* general::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class general (*this, f, c);
  }

  general::
  ~general ()
  {
  }

  // analyses
  //

  analyses::
  analyses ()
  : ::xml_schema::type (),
    analysis_ (::xml_schema::flags (), this)
  {
  }

  analyses::
  analyses (const analyses& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysis_ (x.analysis_, f, this)
  {
  }

  analyses::
  analyses (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysis_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void analyses::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // analysis
      //
      if (n.name () == "analysis" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< analysis_type > r (
          analysis_traits::create (i, f, this));

        this->analysis_.push_back (r);
        continue;
      }

      break;
    }
  }

  analyses* analyses::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analyses (*this, f, c);
  }

  analyses::
  ~analyses ()
  {
  }

  // analysis
  //

  analysis::
  analysis (const id_type& id,
            const name_type& name,
            const solutions_type& solutions,
            const type_type& type)
  : ::xml_schema::type (),
    field_config_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    solutions_ (solutions, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  analysis::
  analysis (const analysis& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_config_ (x.field_config_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    solutions_ (x.solutions_, f, this),
    type_ (x.type_, f, this)
  {
  }

  analysis::
  analysis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_config_ (f, this),
    id_ (f, this),
    name_ (f, this),
    solutions_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void analysis::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field_config
      //
      if (n.name () == "field_config" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< field_config_type > r (
          field_config_traits::create (i, f, this));

        if (!this->field_config_)
        {
          this->field_config_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "solutions" && n.namespace_ ().empty ())
      {
        this->solutions_.set (solutions_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!solutions_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "solutions",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  analysis* analysis::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analysis (*this, f, c);
  }

  analysis::
  ~analysis ()
  {
  }

  // field_config
  //

  field_config::
  field_config ()
  : ::xml_schema::type (),
    field_item_ (::xml_schema::flags (), this)
  {
  }

  field_config::
  field_config (const field_config& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_item_ (x.field_item_, f, this)
  {
  }

  field_config::
  field_config (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_item_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void field_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field_item
      //
      if (n.name () == "field_item" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_item_type > r (
          field_item_traits::create (i, f, this));

        this->field_item_.push_back (r);
        continue;
      }

      break;
    }
  }

  field_config* field_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field_config (*this, f, c);
  }

  field_config::
  ~field_config ()
  {
  }

  // constants
  //

  constants::
  constants ()
  : ::xml_schema::type (),
    constant_ (::xml_schema::flags (), this)
  {
  }

  constants::
  constants (const constants& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    constant_ (x.constant_, f, this)
  {
  }

  constants::
  constants (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    constant_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void constants::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< constant_type > r (
          constant_traits::create (i, f, this));

        this->constant_.push_back (r);
        continue;
      }

      break;
    }
  }

  constants* constants::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class constants (*this, f, c);
  }

  constants::
  ~constants ()
  {
  }

  // constant
  //

  constant::
  constant (const id_type& id,
            const value_type& value)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  constant::
  constant (const constant& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    value_ (x.value_, f, this)
  {
  }

  constant::
  constant (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void constant::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  constant* constant::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class constant (*this, f, c);
  }

  constant::
  ~constant ()
  {
  }

  // macros
  //

  macros::
  macros (const macro_type& macro)
  : ::xml_schema::type (),
    macro_ (macro, ::xml_schema::flags (), this)
  {
  }

  macros::
  macros (::std::auto_ptr< macro_type >& macro)
  : ::xml_schema::type (),
    macro_ (macro, ::xml_schema::flags (), this)
  {
  }

  macros::
  macros (const macros& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    macro_ (x.macro_, f, this)
  {
  }

  macros::
  macros (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    macro_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void macros::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // macro
      //
      if (n.name () == "macro" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< macro_type > r (
          macro_traits::create (i, f, this));

        if (!macro_.present ())
        {
          this->macro_.set (r);
          continue;
        }
      }

      break;
    }

    if (!macro_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "macro",
        "XMLModule");
    }
  }

  macros* macros::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class macros (*this, f, c);
  }

  macros::
  ~macros ()
  {
  }

  // macro
  //

  macro::
  macro (const id_type& id)
  : ::xml_schema::type (),
    expression_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this)
  {
  }

  macro::
  macro (const macro& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this)
  {
  }

  macro::
  macro (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void macro::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "expression" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.set (r);
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  macro* macro::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class macro (*this, f, c);
  }

  macro::
  ~macro ()
  {
  }

  // spaces
  //

  spaces::
  spaces ()
  : ::xml_schema::type (),
    space_ (::xml_schema::flags (), this)
  {
  }

  spaces::
  spaces (const spaces& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    space_ (x.space_, f, this)
  {
  }

  spaces::
  spaces (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    space_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void spaces::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // space
      //
      if (n.name () == "space" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< space_type > r (
          space_traits::create (i, f, this));

        this->space_.push_back (r);
        continue;
      }

      break;
    }
  }

  spaces* spaces::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class spaces (*this, f, c);
  }

  spaces::
  ~spaces ()
  {
  }

  // space
  //

  space::
  space (const analysistype_type& analysistype)
  : ::xml_schema::type (),
    space_config_ (::xml_schema::flags (), this),
    analysistype_ (analysistype, ::xml_schema::flags (), this)
  {
  }

  space::
  space (const space& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    space_config_ (x.space_config_, f, this),
    analysistype_ (x.analysistype_, f, this)
  {
  }

  space::
  space (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    space_config_ (f, this),
    analysistype_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void space::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // space_config
      //
      if (n.name () == "space_config" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< space_config_type > r (
          space_config_traits::create (i, f, this));

        this->space_config_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< analysistype_type > r (
          analysistype_traits::create (i, f, this));

        this->analysistype_.set (r);
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }
  }

  space* space::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class space (*this, f, c);
  }

  space::
  ~space ()
  {
  }

  // space_config
  //

  space_config::
  space_config (const i_type& i,
                const type_type& type,
                const orderadjust_type& orderadjust)
  : ::xml_schema::type (),
    i_ (i, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    orderadjust_ (orderadjust, ::xml_schema::flags (), this)
  {
  }

  space_config::
  space_config (const space_config& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    i_ (x.i_, f, this),
    type_ (x.type_, f, this),
    orderadjust_ (x.orderadjust_, f, this)
  {
  }

  space_config::
  space_config (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    i_ (f, this),
    type_ (f, this),
    orderadjust_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void space_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "orderadjust" && n.namespace_ ().empty ())
      {
        this->orderadjust_.set (orderadjust_traits::create (i, f, this));
        continue;
      }
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!orderadjust_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "orderadjust",
        "");
    }
  }

  space_config* space_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class space_config (*this, f, c);
  }

  space_config::
  ~space_config ()
  {
  }

  // preprocessor
  //

  preprocessor::
  preprocessor ()
  : ::xml_schema::type (),
    gui_ (::xml_schema::flags (), this)
  {
  }

  preprocessor::
  preprocessor (const preprocessor& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    gui_ (x.gui_, f, this)
  {
  }

  preprocessor::
  preprocessor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    gui_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void preprocessor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // gui
      //
      if (n.name () == "gui" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< gui_type > r (
          gui_traits::create (i, f, this));

        this->gui_.push_back (r);
        continue;
      }

      break;
    }
  }

  preprocessor* preprocessor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class preprocessor (*this, f, c);
  }

  preprocessor::
  ~preprocessor ()
  {
  }

  // gui
  //

  gui::
  gui (const type_type& type)
  : ::xml_schema::type (),
    group_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  gui::
  gui (const gui& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    group_ (x.group_, f, this),
    type_ (x.type_, f, this)
  {
  }

  gui::
  gui (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    group_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void gui::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< group_type > r (
          group_traits::create (i, f, this));

        this->group_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  gui* gui::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class gui (*this, f, c);
  }

  gui::
  ~gui ()
  {
  }

  // postprocessor
  //

  postprocessor::
  postprocessor (const localvariables_type& localvariables,
                 const view_type& view,
                 const volumeintegrals_type& volumeintegrals,
                 const surfaceintegrals_type& surfaceintegrals,
                 const force_type& force)
  : ::xml_schema::type (),
    localvariables_ (localvariables, ::xml_schema::flags (), this),
    view_ (view, ::xml_schema::flags (), this),
    volumeintegrals_ (volumeintegrals, ::xml_schema::flags (), this),
    surfaceintegrals_ (surfaceintegrals, ::xml_schema::flags (), this),
    force_ (force, ::xml_schema::flags (), this)
  {
  }

  postprocessor::
  postprocessor (::std::auto_ptr< localvariables_type >& localvariables,
                 ::std::auto_ptr< view_type >& view,
                 ::std::auto_ptr< volumeintegrals_type >& volumeintegrals,
                 ::std::auto_ptr< surfaceintegrals_type >& surfaceintegrals,
                 ::std::auto_ptr< force_type >& force)
  : ::xml_schema::type (),
    localvariables_ (localvariables, ::xml_schema::flags (), this),
    view_ (view, ::xml_schema::flags (), this),
    volumeintegrals_ (volumeintegrals, ::xml_schema::flags (), this),
    surfaceintegrals_ (surfaceintegrals, ::xml_schema::flags (), this),
    force_ (force, ::xml_schema::flags (), this)
  {
  }

  postprocessor::
  postprocessor (const postprocessor& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    localvariables_ (x.localvariables_, f, this),
    view_ (x.view_, f, this),
    volumeintegrals_ (x.volumeintegrals_, f, this),
    surfaceintegrals_ (x.surfaceintegrals_, f, this),
    force_ (x.force_, f, this)
  {
  }

  postprocessor::
  postprocessor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    localvariables_ (f, this),
    view_ (f, this),
    volumeintegrals_ (f, this),
    surfaceintegrals_ (f, this),
    force_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void postprocessor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // localvariables
      //
      if (n.name () == "localvariables" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< localvariables_type > r (
          localvariables_traits::create (i, f, this));

        if (!localvariables_.present ())
        {
          this->localvariables_.set (r);
          continue;
        }
      }

      // view
      //
      if (n.name () == "view" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< view_type > r (
          view_traits::create (i, f, this));

        if (!view_.present ())
        {
          this->view_.set (r);
          continue;
        }
      }

      // volumeintegrals
      //
      if (n.name () == "volumeintegrals" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< volumeintegrals_type > r (
          volumeintegrals_traits::create (i, f, this));

        if (!volumeintegrals_.present ())
        {
          this->volumeintegrals_.set (r);
          continue;
        }
      }

      // surfaceintegrals
      //
      if (n.name () == "surfaceintegrals" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< surfaceintegrals_type > r (
          surfaceintegrals_traits::create (i, f, this));

        if (!surfaceintegrals_.present ())
        {
          this->surfaceintegrals_.set (r);
          continue;
        }
      }

      // force
      //
      if (n.name () == "force" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< force_type > r (
          force_traits::create (i, f, this));

        if (!force_.present ())
        {
          this->force_.set (r);
          continue;
        }
      }

      break;
    }

    if (!localvariables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "localvariables",
        "XMLModule");
    }

    if (!view_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "view",
        "XMLModule");
    }

    if (!volumeintegrals_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "volumeintegrals",
        "XMLModule");
    }

    if (!surfaceintegrals_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surfaceintegrals",
        "XMLModule");
    }

    if (!force_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "force",
        "XMLModule");
    }
  }

  postprocessor* postprocessor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class postprocessor (*this, f, c);
  }

  postprocessor::
  ~postprocessor ()
  {
  }

  // localvariables
  //

  localvariables::
  localvariables ()
  : ::xml_schema::type (),
    localvariable_ (::xml_schema::flags (), this)
  {
  }

  localvariables::
  localvariables (const localvariables& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    localvariable_ (x.localvariable_, f, this)
  {
  }

  localvariables::
  localvariables (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    localvariable_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void localvariables::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // localvariable
      //
      if (n.name () == "localvariable" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< localvariable_type > r (
          localvariable_traits::create (i, f, this));

        this->localvariable_.push_back (r);
        continue;
      }

      break;
    }
  }

  localvariables* localvariables::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class localvariables (*this, f, c);
  }

  localvariables::
  ~localvariables ()
  {
  }

  // localvariable
  //

  localvariable::
  localvariable (const id_type& id,
                 const name_type& name,
                 const shortname_type& shortname,
                 const type_type& type,
                 const unit_type& unit)
  : ::xml_schema::type (),
    expression_ (::xml_schema::flags (), this),
    format_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    shortname_ (shortname, ::xml_schema::flags (), this),
    shortname_html_ (::xml_schema::flags (), this),
    shortname_latex_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    unit_ (unit, ::xml_schema::flags (), this),
    unit_html_ (::xml_schema::flags (), this),
    unit_latex_ (::xml_schema::flags (), this)
  {
  }

  localvariable::
  localvariable (const localvariable& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    format_ (x.format_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    type_ (x.type_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this)
  {
  }

  localvariable::
  localvariable (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (f, this),
    format_ (f, this),
    id_ (f, this),
    name_ (f, this),
    shortname_ (f, this),
    shortname_html_ (f, this),
    shortname_latex_ (f, this),
    type_ (f, this),
    unit_ (f, this),
    unit_html_ (f, this),
    unit_latex_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void localvariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "format" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< format_type > r (
          format_traits::create (i, f, this));

        this->format_.set (r);
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_type > r (
          shortname_traits::create (i, f, this));

        this->shortname_.set (r);
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_html_type > r (
          shortname_html_traits::create (i, f, this));

        this->shortname_html_.set (r);
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_latex_type > r (
          shortname_latex_traits::create (i, f, this));

        this->shortname_latex_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_html_type > r (
          unit_html_traits::create (i, f, this));

        this->unit_html_.set (r);
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_latex_type > r (
          unit_latex_traits::create (i, f, this));

        this->unit_latex_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  localvariable* localvariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class localvariable (*this, f, c);
  }

  localvariable::
  ~localvariable ()
  {
  }

  // view
  //

  view::
  view (const scalar_view_type& scalar_view,
        const vector_view_type& vector_view)
  : ::xml_schema::type (),
    scalar_view_ (scalar_view, ::xml_schema::flags (), this),
    vector_view_ (vector_view, ::xml_schema::flags (), this)
  {
  }

  view::
  view (::std::auto_ptr< scalar_view_type >& scalar_view,
        ::std::auto_ptr< vector_view_type >& vector_view)
  : ::xml_schema::type (),
    scalar_view_ (scalar_view, ::xml_schema::flags (), this),
    vector_view_ (vector_view, ::xml_schema::flags (), this)
  {
  }

  view::
  view (const view& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    scalar_view_ (x.scalar_view_, f, this),
    vector_view_ (x.vector_view_, f, this)
  {
  }

  view::
  view (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    scalar_view_ (f, this),
    vector_view_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void view::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // scalar_view
      //
      if (n.name () == "scalar_view" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< scalar_view_type > r (
          scalar_view_traits::create (i, f, this));

        if (!scalar_view_.present ())
        {
          this->scalar_view_.set (r);
          continue;
        }
      }

      // vector_view
      //
      if (n.name () == "vector_view" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< vector_view_type > r (
          vector_view_traits::create (i, f, this));

        if (!vector_view_.present ())
        {
          this->vector_view_.set (r);
          continue;
        }
      }

      break;
    }

    if (!scalar_view_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scalar_view",
        "XMLModule");
    }

    if (!vector_view_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vector_view",
        "XMLModule");
    }
  }

  view* view::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class view (*this, f, c);
  }

  view::
  ~view ()
  {
  }

  // scalar_view
  //

  scalar_view::
  scalar_view ()
  : ::xml_schema::type (),
    default__ (::xml_schema::flags (), this)
  {
  }

  scalar_view::
  scalar_view (const scalar_view& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default__ (x.default__, f, this)
  {
  }

  scalar_view::
  scalar_view (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default__ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void scalar_view::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< default_type > r (
          default_traits::create (i, f, this));

        this->default__.push_back (r);
        continue;
      }

      break;
    }
  }

  scalar_view* scalar_view::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scalar_view (*this, f, c);
  }

  scalar_view::
  ~scalar_view ()
  {
  }

  // vector_view
  //

  vector_view::
  vector_view ()
  : ::xml_schema::type (),
    default__ (::xml_schema::flags (), this)
  {
  }

  vector_view::
  vector_view (const vector_view& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default__ (x.default__, f, this)
  {
  }

  vector_view::
  vector_view (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default__ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void vector_view::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< default_type > r (
          default_traits::create (i, f, this));

        this->default__.push_back (r);
        continue;
      }

      break;
    }
  }

  vector_view* vector_view::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vector_view (*this, f, c);
  }

  vector_view::
  ~vector_view ()
  {
  }

  // volumeintegrals
  //

  volumeintegrals::
  volumeintegrals ()
  : ::xml_schema::type (),
    volumeintegral_ (::xml_schema::flags (), this)
  {
  }

  volumeintegrals::
  volumeintegrals (const volumeintegrals& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    volumeintegral_ (x.volumeintegral_, f, this)
  {
  }

  volumeintegrals::
  volumeintegrals (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    volumeintegral_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void volumeintegrals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // volumeintegral
      //
      if (n.name () == "volumeintegral" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< volumeintegral_type > r (
          volumeintegral_traits::create (i, f, this));

        this->volumeintegral_.push_back (r);
        continue;
      }

      break;
    }
  }

  volumeintegrals* volumeintegrals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class volumeintegrals (*this, f, c);
  }

  volumeintegrals::
  ~volumeintegrals ()
  {
  }

  // volumeintegral
  //

  volumeintegral::
  volumeintegral (const id_type& id,
                  const name_type& name,
                  const shortname_type& shortname,
                  const unit_type& unit)
  : ::xml_schema::type (),
    expression_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    shortname_ (shortname, ::xml_schema::flags (), this),
    shortname_html_ (::xml_schema::flags (), this),
    shortname_latex_ (::xml_schema::flags (), this),
    unit_ (unit, ::xml_schema::flags (), this),
    unit_html_ (::xml_schema::flags (), this),
    unit_latex_ (::xml_schema::flags (), this)
  {
  }

  volumeintegral::
  volumeintegral (const volumeintegral& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this)
  {
  }

  volumeintegral::
  volumeintegral (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (f, this),
    id_ (f, this),
    name_ (f, this),
    shortname_ (f, this),
    shortname_html_ (f, this),
    shortname_latex_ (f, this),
    unit_ (f, this),
    unit_html_ (f, this),
    unit_latex_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void volumeintegral::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_type > r (
          shortname_traits::create (i, f, this));

        this->shortname_.set (r);
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_html_type > r (
          shortname_html_traits::create (i, f, this));

        this->shortname_html_.set (r);
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_latex_type > r (
          shortname_latex_traits::create (i, f, this));

        this->shortname_latex_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_html_type > r (
          unit_html_traits::create (i, f, this));

        this->unit_html_.set (r);
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_latex_type > r (
          unit_latex_traits::create (i, f, this));

        this->unit_latex_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  volumeintegral* volumeintegral::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class volumeintegral (*this, f, c);
  }

  volumeintegral::
  ~volumeintegral ()
  {
  }

  // surfaceintegrals
  //

  surfaceintegrals::
  surfaceintegrals ()
  : ::xml_schema::type (),
    surfaceintegral_ (::xml_schema::flags (), this)
  {
  }

  surfaceintegrals::
  surfaceintegrals (const surfaceintegrals& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    surfaceintegral_ (x.surfaceintegral_, f, this)
  {
  }

  surfaceintegrals::
  surfaceintegrals (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    surfaceintegral_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void surfaceintegrals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // surfaceintegral
      //
      if (n.name () == "surfaceintegral" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< surfaceintegral_type > r (
          surfaceintegral_traits::create (i, f, this));

        this->surfaceintegral_.push_back (r);
        continue;
      }

      break;
    }
  }

  surfaceintegrals* surfaceintegrals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class surfaceintegrals (*this, f, c);
  }

  surfaceintegrals::
  ~surfaceintegrals ()
  {
  }

  // surfaceintegral
  //

  surfaceintegral::
  surfaceintegral (const id_type& id,
                   const name_type& name,
                   const shortname_type& shortname,
                   const unit_type& unit)
  : ::xml_schema::type (),
    expression_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    shortname_ (shortname, ::xml_schema::flags (), this),
    shortname_html_ (::xml_schema::flags (), this),
    shortname_latex_ (::xml_schema::flags (), this),
    unit_ (unit, ::xml_schema::flags (), this),
    unit_html_ (::xml_schema::flags (), this),
    unit_latex_ (::xml_schema::flags (), this)
  {
  }

  surfaceintegral::
  surfaceintegral (const surfaceintegral& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this)
  {
  }

  surfaceintegral::
  surfaceintegral (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (f, this),
    id_ (f, this),
    name_ (f, this),
    shortname_ (f, this),
    shortname_html_ (f, this),
    shortname_latex_ (f, this),
    unit_ (f, this),
    unit_html_ (f, this),
    unit_latex_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void surfaceintegral::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_type > r (
          shortname_traits::create (i, f, this));

        this->shortname_.set (r);
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_html_type > r (
          shortname_html_traits::create (i, f, this));

        this->shortname_html_.set (r);
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_latex_type > r (
          shortname_latex_traits::create (i, f, this));

        this->shortname_latex_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_html_type > r (
          unit_html_traits::create (i, f, this));

        this->unit_html_.set (r);
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_latex_type > r (
          unit_latex_traits::create (i, f, this));

        this->unit_latex_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  surfaceintegral* surfaceintegral::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class surfaceintegral (*this, f, c);
  }

  surfaceintegral::
  ~surfaceintegral ()
  {
  }

  // force
  //

  force::
  force ()
  : ::xml_schema::type (),
    expression_ (::xml_schema::flags (), this)
  {
  }

  force::
  force (const force& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this)
  {
  }

  force::
  force (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void force::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (r);
        continue;
      }

      break;
    }
  }

  force* force::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class force (*this, f, c);
  }

  force::
  ~force ()
  {
  }

  // volume
  //

  volume::
  volume (const weakforms_volume_type& weakforms_volume)
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    weakforms_volume_ (weakforms_volume, ::xml_schema::flags (), this)
  {
  }

  volume::
  volume (::std::auto_ptr< weakforms_volume_type >& weakforms_volume)
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    weakforms_volume_ (weakforms_volume, ::xml_schema::flags (), this)
  {
  }

  volume::
  volume (const volume& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    weakforms_volume_ (x.weakforms_volume_, f, this)
  {
  }

  volume::
  volume (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (f, this),
    weakforms_volume_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void volume::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (r);
        continue;
      }

      // weakforms_volume
      //
      if (n.name () == "weakforms_volume" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< weakforms_volume_type > r (
          weakforms_volume_traits::create (i, f, this));

        if (!weakforms_volume_.present ())
        {
          this->weakforms_volume_.set (r);
          continue;
        }
      }

      break;
    }

    if (!weakforms_volume_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weakforms_volume",
        "XMLModule");
    }
  }

  volume* volume::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class volume (*this, f, c);
  }

  volume::
  ~volume ()
  {
  }

  // surface
  //

  surface::
  surface (const weakforms_surface_type& weakforms_surface)
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    weakforms_surface_ (weakforms_surface, ::xml_schema::flags (), this)
  {
  }

  surface::
  surface (::std::auto_ptr< weakforms_surface_type >& weakforms_surface)
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    weakforms_surface_ (weakforms_surface, ::xml_schema::flags (), this)
  {
  }

  surface::
  surface (const surface& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    weakforms_surface_ (x.weakforms_surface_, f, this)
  {
  }

  surface::
  surface (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (f, this),
    weakforms_surface_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void surface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (r);
        continue;
      }

      // weakforms_surface
      //
      if (n.name () == "weakforms_surface" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< weakforms_surface_type > r (
          weakforms_surface_traits::create (i, f, this));

        if (!weakforms_surface_.present ())
        {
          this->weakforms_surface_.set (r);
          continue;
        }
      }

      break;
    }

    if (!weakforms_surface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weakforms_surface",
        "XMLModule");
    }
  }

  surface* surface::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class surface (*this, f, c);
  }

  surface::
  ~surface ()
  {
  }

  // weakforms_surface
  //

  weakforms_surface::
  weakforms_surface ()
  : ::xml_schema::type (),
    group_ (::xml_schema::flags (), this),
    weakform_surface_ (::xml_schema::flags (), this)
  {
  }

  weakforms_surface::
  weakforms_surface (const weakforms_surface& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    group_ (x.group_, f, this),
    weakform_surface_ (x.weakform_surface_, f, this)
  {
  }

  weakforms_surface::
  weakforms_surface (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    group_ (f, this),
    weakform_surface_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void weakforms_surface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< group_type > r (
          group_traits::create (i, f, this));

        if (!this->group_)
        {
          this->group_.set (r);
          continue;
        }
      }

      // weakform_surface
      //
      if (n.name () == "weakform_surface" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< weakform_surface_type > r (
          weakform_surface_traits::create (i, f, this));

        this->weakform_surface_.push_back (r);
        continue;
      }

      break;
    }
  }

  weakforms_surface* weakforms_surface::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakforms_surface (*this, f, c);
  }

  weakforms_surface::
  ~weakforms_surface ()
  {
  }

  // weakform_surface
  //

  weakform_surface::
  weakform_surface (const analysistype_type& analysistype)
  : ::xml_schema::type (),
    boundary_ (::xml_schema::flags (), this),
    quantity_ (::xml_schema::flags (), this),
    matrix_form_ (::xml_schema::flags (), this),
    vector_form_ (::xml_schema::flags (), this),
    analysistype_ (analysistype, ::xml_schema::flags (), this),
    default__ (::xml_schema::flags (), this)
  {
  }

  weakform_surface::
  weakform_surface (const weakform_surface& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boundary_ (x.boundary_, f, this),
    quantity_ (x.quantity_, f, this),
    matrix_form_ (x.matrix_form_, f, this),
    vector_form_ (x.vector_form_, f, this),
    analysistype_ (x.analysistype_, f, this),
    default__ (x.default__, f, this)
  {
  }

  weakform_surface::
  weakform_surface (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boundary_ (f, this),
    quantity_ (f, this),
    matrix_form_ (f, this),
    vector_form_ (f, this),
    analysistype_ (f, this),
    default__ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void weakform_surface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundary
      //
      if (n.name () == "boundary" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< boundary_type > r (
          boundary_traits::create (i, f, this));

        this->boundary_.push_back (r);
        continue;
      }

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (r);
        continue;
      }

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (r);
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< analysistype_type > r (
          analysistype_traits::create (i, f, this));

        this->analysistype_.set (r);
        continue;
      }

      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< default_type > r (
          default_traits::create (i, f, this));

        this->default__.set (r);
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }
  }

  weakform_surface* weakform_surface::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakform_surface (*this, f, c);
  }

  weakform_surface::
  ~weakform_surface ()
  {
  }

  // expression
  //

  expression::
  expression (const analysistype_type& analysistype)
  : ::xml_schema::type (),
    analysistype_ (analysistype, ::xml_schema::flags (), this),
    axi_ (::xml_schema::flags (), this),
    axi_r_ (::xml_schema::flags (), this),
    axi_z_ (::xml_schema::flags (), this),
    axi_phi_ (::xml_schema::flags (), this),
    planar_ (::xml_schema::flags (), this),
    planar_x_ (::xml_schema::flags (), this),
    planar_y_ (::xml_schema::flags (), this),
    planar_z_ (::xml_schema::flags (), this)
  {
  }

  expression::
  expression (const expression& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysistype_ (x.analysistype_, f, this),
    axi_ (x.axi_, f, this),
    axi_r_ (x.axi_r_, f, this),
    axi_z_ (x.axi_z_, f, this),
    axi_phi_ (x.axi_phi_, f, this),
    planar_ (x.planar_, f, this),
    planar_x_ (x.planar_x_, f, this),
    planar_y_ (x.planar_y_, f, this),
    planar_z_ (x.planar_z_, f, this)
  {
  }

  expression::
  expression (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysistype_ (f, this),
    axi_ (f, this),
    axi_r_ (f, this),
    axi_z_ (f, this),
    axi_phi_ (f, this),
    planar_ (f, this),
    planar_x_ (f, this),
    planar_y_ (f, this),
    planar_z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void expression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< analysistype_type > r (
          analysistype_traits::create (i, f, this));

        this->analysistype_.set (r);
        continue;
      }

      if (n.name () == "axi" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_type > r (
          axi_traits::create (i, f, this));

        this->axi_.set (r);
        continue;
      }

      if (n.name () == "axi_r" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_r_type > r (
          axi_r_traits::create (i, f, this));

        this->axi_r_.set (r);
        continue;
      }

      if (n.name () == "axi_z" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_z_type > r (
          axi_z_traits::create (i, f, this));

        this->axi_z_.set (r);
        continue;
      }

      if (n.name () == "axi_phi" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_phi_type > r (
          axi_phi_traits::create (i, f, this));

        this->axi_phi_.set (r);
        continue;
      }

      if (n.name () == "planar" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_type > r (
          planar_traits::create (i, f, this));

        this->planar_.set (r);
        continue;
      }

      if (n.name () == "planar_x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_x_type > r (
          planar_x_traits::create (i, f, this));

        this->planar_x_.set (r);
        continue;
      }

      if (n.name () == "planar_y" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_y_type > r (
          planar_y_traits::create (i, f, this));

        this->planar_y_.set (r);
        continue;
      }

      if (n.name () == "planar_z" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_z_type > r (
          planar_z_traits::create (i, f, this));

        this->planar_z_.set (r);
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }
  }

  expression* expression::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class expression (*this, f, c);
  }

  expression::
  ~expression ()
  {
  }

  // default_
  //

  default_::
  default_ (const analysistype_type& analysistype,
            const id_type& id)
  : ::xml_schema::type (),
    analysistype_ (analysistype, ::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this)
  {
  }

  default_::
  default_ (const default_& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysistype_ (x.analysistype_, f, this),
    id_ (x.id_, f, this)
  {
  }

  default_::
  default_ (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysistype_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void default_::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< analysistype_type > r (
          analysistype_traits::create (i, f, this));

        this->analysistype_.set (r);
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  default_* default_::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class default_ (*this, f, c);
  }

  default_::
  ~default_ ()
  {
  }

  // quantity
  //

  quantity::
  quantity (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    condition_ (::xml_schema::flags (), this),
    default__ (::xml_schema::flags (), this),
    nonlinearity_planar_ (::xml_schema::flags (), this),
    nonlinearity_axi_ (::xml_schema::flags (), this),
    dependence_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    shortname_ (::xml_schema::flags (), this),
    shortname_html_ (::xml_schema::flags (), this),
    shortname_latex_ (::xml_schema::flags (), this),
    shortname_dependence_ (::xml_schema::flags (), this),
    shortname_dependence_html_ (::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    unit_html_ (::xml_schema::flags (), this),
    unit_latex_ (::xml_schema::flags (), this)
  {
  }

  quantity::
  quantity (const quantity& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    condition_ (x.condition_, f, this),
    default__ (x.default__, f, this),
    nonlinearity_planar_ (x.nonlinearity_planar_, f, this),
    nonlinearity_axi_ (x.nonlinearity_axi_, f, this),
    dependence_ (x.dependence_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    shortname_dependence_ (x.shortname_dependence_, f, this),
    shortname_dependence_html_ (x.shortname_dependence_html_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this)
  {
  }

  quantity::
  quantity (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    condition_ (f, this),
    default__ (f, this),
    nonlinearity_planar_ (f, this),
    nonlinearity_axi_ (f, this),
    dependence_ (f, this),
    name_ (f, this),
    shortname_ (f, this),
    shortname_html_ (f, this),
    shortname_latex_ (f, this),
    shortname_dependence_ (f, this),
    shortname_dependence_html_ (f, this),
    unit_ (f, this),
    unit_html_ (f, this),
    unit_latex_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void quantity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< condition_type > r (
          condition_traits::create (i, f, this));

        this->condition_.set (r);
        continue;
      }

      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        this->default__.set (default_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "nonlinearity_planar" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< nonlinearity_planar_type > r (
          nonlinearity_planar_traits::create (i, f, this));

        this->nonlinearity_planar_.set (r);
        continue;
      }

      if (n.name () == "nonlinearity_axi" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< nonlinearity_axi_type > r (
          nonlinearity_axi_traits::create (i, f, this));

        this->nonlinearity_axi_.set (r);
        continue;
      }

      if (n.name () == "dependence" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dependence_type > r (
          dependence_traits::create (i, f, this));

        this->dependence_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_type > r (
          shortname_traits::create (i, f, this));

        this->shortname_.set (r);
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_html_type > r (
          shortname_html_traits::create (i, f, this));

        this->shortname_html_.set (r);
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_latex_type > r (
          shortname_latex_traits::create (i, f, this));

        this->shortname_latex_.set (r);
        continue;
      }

      if (n.name () == "shortname_dependence" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_dependence_type > r (
          shortname_dependence_traits::create (i, f, this));

        this->shortname_dependence_.set (r);
        continue;
      }

      if (n.name () == "shortname_dependence_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< shortname_dependence_html_type > r (
          shortname_dependence_html_traits::create (i, f, this));

        this->shortname_dependence_html_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_html_type > r (
          unit_html_traits::create (i, f, this));

        this->unit_html_.set (r);
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_latex_type > r (
          unit_latex_traits::create (i, f, this));

        this->unit_latex_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  quantity* quantity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class quantity (*this, f, c);
  }

  quantity::
  ~quantity ()
  {
  }

  // weakforms_volume
  //

  weakforms_volume::
  weakforms_volume ()
  : ::xml_schema::type (),
    weakform_volume_ (::xml_schema::flags (), this)
  {
  }

  weakforms_volume::
  weakforms_volume (const weakforms_volume& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    weakform_volume_ (x.weakform_volume_, f, this)
  {
  }

  weakforms_volume::
  weakforms_volume (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    weakform_volume_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void weakforms_volume::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weakform_volume
      //
      if (n.name () == "weakform_volume" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< weakform_volume_type > r (
          weakform_volume_traits::create (i, f, this));

        this->weakform_volume_.push_back (r);
        continue;
      }

      break;
    }
  }

  weakforms_volume* weakforms_volume::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakforms_volume (*this, f, c);
  }

  weakforms_volume::
  ~weakforms_volume ()
  {
  }

  // weakform_volume
  //

  weakform_volume::
  weakform_volume (const analysistype_type& analysistype,
                   const equation_type& equation)
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    matrix_form_ (::xml_schema::flags (), this),
    vector_form_ (::xml_schema::flags (), this),
    analysistype_ (analysistype, ::xml_schema::flags (), this),
    equation_ (equation, ::xml_schema::flags (), this)
  {
  }

  weakform_volume::
  weakform_volume (const weakform_volume& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    matrix_form_ (x.matrix_form_, f, this),
    vector_form_ (x.vector_form_, f, this),
    analysistype_ (x.analysistype_, f, this),
    equation_ (x.equation_, f, this)
  {
  }

  weakform_volume::
  weakform_volume (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (f, this),
    matrix_form_ (f, this),
    vector_form_ (f, this),
    analysistype_ (f, this),
    equation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void weakform_volume::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (r);
        continue;
      }

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (r);
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< analysistype_type > r (
          analysistype_traits::create (i, f, this));

        this->analysistype_.set (r);
        continue;
      }

      if (n.name () == "equation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equation_type > r (
          equation_traits::create (i, f, this));

        this->equation_.set (r);
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }

    if (!equation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "equation",
        "");
    }
  }

  weakform_volume* weakform_volume::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakform_volume (*this, f, c);
  }

  weakform_volume::
  ~weakform_volume ()
  {
  }

  // group
  //

  group::
  group ()
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this)
  {
  }

  group::
  group (const group& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    name_ (x.name_, f, this)
  {
  }

  group::
  group (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void group::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }
  }

  group* group::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group (*this, f, c);
  }

  group::
  ~group ()
  {
  }

  // matrix_form
  //

  matrix_form::
  matrix_form (const id_type& id,
               const i_type& i,
               const j_type& j,
               const planar_linear_type& planar_linear,
               const axi_linear_type& axi_linear,
               const planar_newton_type& planar_newton,
               const axi_newton_type& axi_newton)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this),
    j_ (j, ::xml_schema::flags (), this),
    planar_linear_ (planar_linear, ::xml_schema::flags (), this),
    axi_linear_ (axi_linear, ::xml_schema::flags (), this),
    planar_newton_ (planar_newton, ::xml_schema::flags (), this),
    axi_newton_ (axi_newton, ::xml_schema::flags (), this),
    symmetric_ (::xml_schema::flags (), this)
  {
  }

  matrix_form::
  matrix_form (const matrix_form& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    j_ (x.j_, f, this),
    planar_linear_ (x.planar_linear_, f, this),
    axi_linear_ (x.axi_linear_, f, this),
    planar_newton_ (x.planar_newton_, f, this),
    axi_newton_ (x.axi_newton_, f, this),
    symmetric_ (x.symmetric_, f, this)
  {
  }

  matrix_form::
  matrix_form (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    i_ (f, this),
    j_ (f, this),
    planar_linear_ (f, this),
    axi_linear_ (f, this),
    planar_newton_ (f, this),
    axi_newton_ (f, this),
    symmetric_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void matrix_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "j" && n.namespace_ ().empty ())
      {
        this->j_.set (j_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar_linear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_linear_type > r (
          planar_linear_traits::create (i, f, this));

        this->planar_linear_.set (r);
        continue;
      }

      if (n.name () == "axi_linear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_linear_type > r (
          axi_linear_traits::create (i, f, this));

        this->axi_linear_.set (r);
        continue;
      }

      if (n.name () == "planar_newton" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_newton_type > r (
          planar_newton_traits::create (i, f, this));

        this->planar_newton_.set (r);
        continue;
      }

      if (n.name () == "axi_newton" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_newton_type > r (
          axi_newton_traits::create (i, f, this));

        this->axi_newton_.set (r);
        continue;
      }

      if (n.name () == "symmetric" && n.namespace_ ().empty ())
      {
        this->symmetric_.set (symmetric_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }

    if (!j_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "j",
        "");
    }

    if (!planar_linear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "planar_linear",
        "");
    }

    if (!axi_linear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axi_linear",
        "");
    }

    if (!planar_newton_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "planar_newton",
        "");
    }

    if (!axi_newton_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axi_newton",
        "");
    }
  }

  matrix_form* matrix_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class matrix_form (*this, f, c);
  }

  matrix_form::
  ~matrix_form ()
  {
  }

  // vector_form
  //

  vector_form::
  vector_form (const id_type& id,
               const i_type& i,
               const j_type& j,
               const planar_linear_type& planar_linear,
               const axi_linear_type& axi_linear,
               const planar_newton_type& planar_newton,
               const axi_newton_type& axi_newton)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this),
    j_ (j, ::xml_schema::flags (), this),
    planar_linear_ (planar_linear, ::xml_schema::flags (), this),
    axi_linear_ (axi_linear, ::xml_schema::flags (), this),
    planar_newton_ (planar_newton, ::xml_schema::flags (), this),
    axi_newton_ (axi_newton, ::xml_schema::flags (), this)
  {
  }

  vector_form::
  vector_form (const vector_form& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    j_ (x.j_, f, this),
    planar_linear_ (x.planar_linear_, f, this),
    axi_linear_ (x.axi_linear_, f, this),
    planar_newton_ (x.planar_newton_, f, this),
    axi_newton_ (x.axi_newton_, f, this)
  {
  }

  vector_form::
  vector_form (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    i_ (f, this),
    j_ (f, this),
    planar_linear_ (f, this),
    axi_linear_ (f, this),
    planar_newton_ (f, this),
    axi_newton_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void vector_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "j" && n.namespace_ ().empty ())
      {
        this->j_.set (j_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar_linear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_linear_type > r (
          planar_linear_traits::create (i, f, this));

        this->planar_linear_.set (r);
        continue;
      }

      if (n.name () == "axi_linear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_linear_type > r (
          axi_linear_traits::create (i, f, this));

        this->axi_linear_.set (r);
        continue;
      }

      if (n.name () == "planar_newton" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_newton_type > r (
          planar_newton_traits::create (i, f, this));

        this->planar_newton_.set (r);
        continue;
      }

      if (n.name () == "axi_newton" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_newton_type > r (
          axi_newton_traits::create (i, f, this));

        this->axi_newton_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }

    if (!j_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "j",
        "");
    }

    if (!planar_linear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "planar_linear",
        "");
    }

    if (!axi_linear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axi_linear",
        "");
    }

    if (!planar_newton_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "planar_newton",
        "");
    }

    if (!axi_newton_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axi_newton",
        "");
    }
  }

  vector_form* vector_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vector_form (*this, f, c);
  }

  vector_form::
  ~vector_form ()
  {
  }

  // essential_form
  //

  essential_form::
  essential_form (const id_type& id,
                  const i_type& i,
                  const axi_linear_type& axi_linear,
                  const planar_linear_type& planar_linear,
                  const axi_newton_type& axi_newton,
                  const planar_newton_type& planar_newton)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this),
    axi_linear_ (axi_linear, ::xml_schema::flags (), this),
    planar_linear_ (planar_linear, ::xml_schema::flags (), this),
    axi_newton_ (axi_newton, ::xml_schema::flags (), this),
    planar_newton_ (planar_newton, ::xml_schema::flags (), this)
  {
  }

  essential_form::
  essential_form (const essential_form& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    axi_linear_ (x.axi_linear_, f, this),
    planar_linear_ (x.planar_linear_, f, this),
    axi_newton_ (x.axi_newton_, f, this),
    planar_newton_ (x.planar_newton_, f, this)
  {
  }

  essential_form::
  essential_form (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    i_ (f, this),
    axi_linear_ (f, this),
    planar_linear_ (f, this),
    axi_newton_ (f, this),
    planar_newton_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void essential_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi_linear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_linear_type > r (
          axi_linear_traits::create (i, f, this));

        this->axi_linear_.set (r);
        continue;
      }

      if (n.name () == "planar_linear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_linear_type > r (
          planar_linear_traits::create (i, f, this));

        this->planar_linear_.set (r);
        continue;
      }

      if (n.name () == "axi_newton" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axi_newton_type > r (
          axi_newton_traits::create (i, f, this));

        this->axi_newton_.set (r);
        continue;
      }

      if (n.name () == "planar_newton" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< planar_newton_type > r (
          planar_newton_traits::create (i, f, this));

        this->planar_newton_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }

    if (!axi_linear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axi_linear",
        "");
    }

    if (!planar_linear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "planar_linear",
        "");
    }

    if (!axi_newton_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axi_newton",
        "");
    }

    if (!planar_newton_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "planar_newton",
        "");
    }
  }

  essential_form* essential_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class essential_form (*this, f, c);
  }

  essential_form::
  ~essential_form ()
  {
  }

  // boundary
  //

  boundary::
  boundary (const id_type& id,
            const name_type& name,
            const equation_type& equation)
  : ::xml_schema::type (),
    quantity_ (::xml_schema::flags (), this),
    vector_form_ (::xml_schema::flags (), this),
    matrix_form_ (::xml_schema::flags (), this),
    essential_form_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    equation_ (equation, ::xml_schema::flags (), this)
  {
  }

  boundary::
  boundary (const boundary& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    vector_form_ (x.vector_form_, f, this),
    matrix_form_ (x.matrix_form_, f, this),
    essential_form_ (x.essential_form_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    equation_ (x.equation_, f, this)
  {
  }

  boundary::
  boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (f, this),
    vector_form_ (f, this),
    matrix_form_ (f, this),
    essential_form_ (f, this),
    id_ (f, this),
    name_ (f, this),
    equation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void boundary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (r);
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (r);
        continue;
      }

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (r);
        continue;
      }

      // essential_form
      //
      if (n.name () == "essential_form" && n.namespace_ () == "XMLModule")
      {
        ::std::auto_ptr< essential_form_type > r (
          essential_form_traits::create (i, f, this));

        this->essential_form_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "equation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equation_type > r (
          equation_traits::create (i, f, this));

        this->equation_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!equation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "equation",
        "");
    }
  }

  boundary* boundary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary (*this, f, c);
  }

  boundary::
  ~boundary ()
  {
  }

  // field_item
  //

  field_item::
  field_item (const field_key_type& field_key,
              const field_value_type& field_value)
  : ::xml_schema::type (),
    field_key_ (field_key, ::xml_schema::flags (), this),
    field_value_ (field_value, ::xml_schema::flags (), this)
  {
  }

  field_item::
  field_item (const field_item& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_key_ (x.field_key_, f, this),
    field_value_ (x.field_value_, f, this)
  {
  }

  field_item::
  field_item (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_key_ (f, this),
    field_value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void field_item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "field_key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_key_type > r (
          field_key_traits::create (i, f, this));

        this->field_key_.set (r);
        continue;
      }

      if (n.name () == "field_value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< field_value_type > r (
          field_value_traits::create (i, f, this));

        this->field_value_.set (r);
        continue;
      }
    }

    if (!field_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_key",
        "");
    }

    if (!field_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_value",
        "");
    }
  }

  field_item* field_item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field_item (*this, f, c);
  }

  field_item::
  ~field_item ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace XMLModule
{
  ::std::ostream&
  operator<< (::std::ostream& o, const module& i)
  {
    o << ::std::endl << "general: " << i.general ();
    o << ::std::endl << "constants: " << i.constants ();
    o << ::std::endl << "spaces: " << i.spaces ();
    o << ::std::endl << "volume: " << i.volume ();
    o << ::std::endl << "surface: " << i.surface ();
    o << ::std::endl << "preprocessor: " << i.preprocessor ();
    o << ::std::endl << "postprocessor: " << i.postprocessor ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const general& i)
  {
    o << ::std::endl << "description: " << i.description ();
    o << ::std::endl << "analyses: " << i.analyses ();
    if (i.deformed_shape ())
    {
      o << ::std::endl << "deformed_shape: " << *i.deformed_shape ();
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const analyses& i)
  {
    for (analyses::analysis_const_iterator
         b (i.analysis ().begin ()), e (i.analysis ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "analysis: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const analysis& i)
  {
    if (i.field_config ())
    {
      o << ::std::endl << "field_config: " << *i.field_config ();
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "solutions: " << i.solutions ();
    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field_config& i)
  {
    for (field_config::field_item_const_iterator
         b (i.field_item ().begin ()), e (i.field_item ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "field_item: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const constants& i)
  {
    for (constants::constant_const_iterator
         b (i.constant ().begin ()), e (i.constant ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "constant: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const constant& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const macros& i)
  {
    o << ::std::endl << "macro: " << i.macro ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const macro& i)
  {
    if (i.expression ())
    {
      o << ::std::endl << "expression: " << *i.expression ();
    }

    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const spaces& i)
  {
    for (spaces::space_const_iterator
         b (i.space ().begin ()), e (i.space ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "space: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const space& i)
  {
    for (space::space_config_const_iterator
         b (i.space_config ().begin ()), e (i.space_config ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "space_config: " << *b;
    }

    o << ::std::endl << "analysistype: " << i.analysistype ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const space_config& i)
  {
    o << ::std::endl << "i: " << i.i ();
    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "orderadjust: " << i.orderadjust ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const preprocessor& i)
  {
    for (preprocessor::gui_const_iterator
         b (i.gui ().begin ()), e (i.gui ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gui: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const gui& i)
  {
    for (gui::group_const_iterator
         b (i.group ().begin ()), e (i.group ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "group: " << *b;
    }

    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const postprocessor& i)
  {
    o << ::std::endl << "localvariables: " << i.localvariables ();
    o << ::std::endl << "view: " << i.view ();
    o << ::std::endl << "volumeintegrals: " << i.volumeintegrals ();
    o << ::std::endl << "surfaceintegrals: " << i.surfaceintegrals ();
    o << ::std::endl << "force: " << i.force ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const localvariables& i)
  {
    for (localvariables::localvariable_const_iterator
         b (i.localvariable ().begin ()), e (i.localvariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "localvariable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const localvariable& i)
  {
    for (localvariable::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    if (i.format ())
    {
      o << ::std::endl << "format: " << *i.format ();
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "shortname: " << i.shortname ();
    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "unit: " << i.unit ();
    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const view& i)
  {
    o << ::std::endl << "scalar_view: " << i.scalar_view ();
    o << ::std::endl << "vector_view: " << i.vector_view ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const scalar_view& i)
  {
    for (scalar_view::default_const_iterator
         b (i.default_ ().begin ()), e (i.default_ ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "default: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vector_view& i)
  {
    for (vector_view::default_const_iterator
         b (i.default_ ().begin ()), e (i.default_ ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "default: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const volumeintegrals& i)
  {
    for (volumeintegrals::volumeintegral_const_iterator
         b (i.volumeintegral ().begin ()), e (i.volumeintegral ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "volumeintegral: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const volumeintegral& i)
  {
    for (volumeintegral::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "shortname: " << i.shortname ();
    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    o << ::std::endl << "unit: " << i.unit ();
    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const surfaceintegrals& i)
  {
    for (surfaceintegrals::surfaceintegral_const_iterator
         b (i.surfaceintegral ().begin ()), e (i.surfaceintegral ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "surfaceintegral: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const surfaceintegral& i)
  {
    for (surfaceintegral::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "shortname: " << i.shortname ();
    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    o << ::std::endl << "unit: " << i.unit ();
    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const force& i)
  {
    for (force::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const volume& i)
  {
    for (volume::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    o << ::std::endl << "weakforms_volume: " << i.weakforms_volume ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const surface& i)
  {
    for (surface::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    o << ::std::endl << "weakforms_surface: " << i.weakforms_surface ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakforms_surface& i)
  {
    if (i.group ())
    {
      o << ::std::endl << "group: " << *i.group ();
    }

    for (weakforms_surface::weakform_surface_const_iterator
         b (i.weakform_surface ().begin ()), e (i.weakform_surface ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "weakform_surface: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakform_surface& i)
  {
    for (weakform_surface::boundary_const_iterator
         b (i.boundary ().begin ()), e (i.boundary ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "boundary: " << *b;
    }

    for (weakform_surface::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (weakform_surface::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (weakform_surface::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    o << ::std::endl << "analysistype: " << i.analysistype ();
    if (i.default_ ())
    {
      o << ::std::endl << "default: " << *i.default_ ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const expression& i)
  {
    o << ::std::endl << "analysistype: " << i.analysistype ();
    if (i.axi ())
    {
      o << ::std::endl << "axi: " << *i.axi ();
    }

    if (i.axi_r ())
    {
      o << ::std::endl << "axi_r: " << *i.axi_r ();
    }

    if (i.axi_z ())
    {
      o << ::std::endl << "axi_z: " << *i.axi_z ();
    }

    if (i.axi_phi ())
    {
      o << ::std::endl << "axi_phi: " << *i.axi_phi ();
    }

    if (i.planar ())
    {
      o << ::std::endl << "planar: " << *i.planar ();
    }

    if (i.planar_x ())
    {
      o << ::std::endl << "planar_x: " << *i.planar_x ();
    }

    if (i.planar_y ())
    {
      o << ::std::endl << "planar_y: " << *i.planar_y ();
    }

    if (i.planar_z ())
    {
      o << ::std::endl << "planar_z: " << *i.planar_z ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const default_& i)
  {
    o << ::std::endl << "analysistype: " << i.analysistype ();
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const quantity& i)
  {
    o << ::std::endl << "id: " << i.id ();
    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    if (i.default_ ())
    {
      o << ::std::endl << "default: " << *i.default_ ();
    }

    if (i.nonlinearity_planar ())
    {
      o << ::std::endl << "nonlinearity_planar: " << *i.nonlinearity_planar ();
    }

    if (i.nonlinearity_axi ())
    {
      o << ::std::endl << "nonlinearity_axi: " << *i.nonlinearity_axi ();
    }

    if (i.dependence ())
    {
      o << ::std::endl << "dependence: " << *i.dependence ();
    }

    if (i.name ())
    {
      o << ::std::endl << "name: " << *i.name ();
    }

    if (i.shortname ())
    {
      o << ::std::endl << "shortname: " << *i.shortname ();
    }

    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    if (i.shortname_dependence ())
    {
      o << ::std::endl << "shortname_dependence: " << *i.shortname_dependence ();
    }

    if (i.shortname_dependence_html ())
    {
      o << ::std::endl << "shortname_dependence_html: " << *i.shortname_dependence_html ();
    }

    if (i.unit ())
    {
      o << ::std::endl << "unit: " << *i.unit ();
    }

    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakforms_volume& i)
  {
    for (weakforms_volume::weakform_volume_const_iterator
         b (i.weakform_volume ().begin ()), e (i.weakform_volume ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "weakform_volume: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakform_volume& i)
  {
    for (weakform_volume::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (weakform_volume::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (weakform_volume::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    o << ::std::endl << "analysistype: " << i.analysistype ();
    o << ::std::endl << "equation: " << i.equation ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const group& i)
  {
    for (group::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    if (i.name ())
    {
      o << ::std::endl << "name: " << *i.name ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const matrix_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "i: " << i.i ();
    o << ::std::endl << "j: " << i.j ();
    o << ::std::endl << "planar_linear: " << i.planar_linear ();
    o << ::std::endl << "axi_linear: " << i.axi_linear ();
    o << ::std::endl << "planar_newton: " << i.planar_newton ();
    o << ::std::endl << "axi_newton: " << i.axi_newton ();
    if (i.symmetric ())
    {
      o << ::std::endl << "symmetric: " << *i.symmetric ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vector_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "i: " << i.i ();
    o << ::std::endl << "j: " << i.j ();
    o << ::std::endl << "planar_linear: " << i.planar_linear ();
    o << ::std::endl << "axi_linear: " << i.axi_linear ();
    o << ::std::endl << "planar_newton: " << i.planar_newton ();
    o << ::std::endl << "axi_newton: " << i.axi_newton ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const essential_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "i: " << i.i ();
    o << ::std::endl << "axi_linear: " << i.axi_linear ();
    o << ::std::endl << "planar_linear: " << i.planar_linear ();
    o << ::std::endl << "axi_newton: " << i.axi_newton ();
    o << ::std::endl << "planar_newton: " << i.planar_newton ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary& i)
  {
    for (boundary::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (boundary::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    for (boundary::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (boundary::essential_form_const_iterator
         b (i.essential_form ().begin ()), e (i.essential_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "essential_form: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "equation: " << i.equation ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field_item& i)
  {
    o << ::std::endl << "field_key: " << i.field_key ();
    o << ::std::endl << "field_value: " << i.field_value ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLModule
{
  ::std::auto_ptr< ::XMLModule::module >
  module_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLModule::module > r (
      ::XMLModule::module_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLModule::module > r (
      ::XMLModule::module_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLModule::module > r (
      ::XMLModule::module_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLModule::module_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLModule::module_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLModule::module > r (
      ::XMLModule::module_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLModule::module > r (
      ::XMLModule::module_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLModule::module > r (
      ::XMLModule::module_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::XMLModule::module > r (
        ::XMLModule::module_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "module" &&
        n.namespace_ () == "XMLModule")
    {
      ::std::auto_ptr< ::XMLModule::module > r (
        ::xsd::cxx::tree::traits< ::XMLModule::module, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "module",
      "XMLModule");
  }

  ::std::auto_ptr< ::XMLModule::module >
  module_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "module" &&
        n.namespace_ () == "XMLModule")
    {
      ::std::auto_ptr< ::XMLModule::module > r (
        ::xsd::cxx::tree::traits< ::XMLModule::module, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "module",
      "XMLModule");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace XMLModule
{
  void
  module_ (::std::ostream& o,
           const ::XMLModule::module& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  module_ (::std::ostream& o,
           const ::XMLModule::module& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::std::ostream& o,
           const ::XMLModule::module& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::xercesc::XMLFormatTarget& t,
           const ::XMLModule::module& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  module_ (::xercesc::XMLFormatTarget& t,
           const ::XMLModule::module& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::xercesc::XMLFormatTarget& t,
           const ::XMLModule::module& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::xercesc::DOMDocument& d,
           const ::XMLModule::module& s,
           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "module" &&
        n.namespace_ () == "XMLModule")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "module",
        "XMLModule");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  module_ (const ::XMLModule::module& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "module",
        "XMLModule",
        m, f));

    ::XMLModule::module_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const module& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // general
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "general",
          "XMLModule",
          e));

      s << i.general ();
    }

    // constants
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constants",
          "XMLModule",
          e));

      s << i.constants ();
    }

    // spaces
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spaces",
          "XMLModule",
          e));

      s << i.spaces ();
    }

    // volume
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volume",
          "XMLModule",
          e));

      s << i.volume ();
    }

    // surface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surface",
          "XMLModule",
          e));

      s << i.surface ();
    }

    // preprocessor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "preprocessor",
          "XMLModule",
          e));

      s << i.preprocessor ();
    }

    // postprocessor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "postprocessor",
          "XMLModule",
          e));

      s << i.postprocessor ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const general& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // description
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "XMLModule",
          e));

      s << i.description ();
    }

    // analyses
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analyses",
          "XMLModule",
          e));

      s << i.analyses ();
    }

    // deformed_shape
    //
    if (i.deformed_shape ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "deformed_shape",
          e));

      a << *i.deformed_shape ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analyses& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysis
    //
    for (analyses::analysis_const_iterator
         b (i.analysis ().begin ()), n (i.analysis ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analysis",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analysis& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_config
    //
    if (i.field_config ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field_config",
          "XMLModule",
          e));

      s << *i.field_config ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // solutions
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "solutions",
          e));

      a << i.solutions ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field_config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_item
    //
    for (field_config::field_item_const_iterator
         b (i.field_item ().begin ()), n (i.field_item ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field_item",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const constants& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // constant
    //
    for (constants::constant_const_iterator
         b (i.constant ().begin ()), n (i.constant ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const constant& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_double(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const macros& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // macro
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "macro",
          "XMLModule",
          e));

      s << i.macro ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const macro& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    if (i.expression ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "expression",
          e));

      a << *i.expression ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const spaces& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // space
    //
    for (spaces::space_const_iterator
         b (i.space ().begin ()), n (i.space ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "space",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const space& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // space_config
    //
    for (space::space_config_const_iterator
         b (i.space_config ().begin ()), n (i.space_config ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "space_config",
          "XMLModule",
          e));

      s << *b;
    }

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const space_config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // orderadjust
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "orderadjust",
          e));

      a << i.orderadjust ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const preprocessor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // gui
    //
    for (preprocessor::gui_const_iterator
         b (i.gui ().begin ()), n (i.gui ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gui",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const gui& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // group
    //
    for (gui::group_const_iterator
         b (i.group ().begin ()), n (i.group ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "group",
          "XMLModule",
          e));

      s << *b;
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const postprocessor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // localvariables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "localvariables",
          "XMLModule",
          e));

      s << i.localvariables ();
    }

    // view
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "view",
          "XMLModule",
          e));

      s << i.view ();
    }

    // volumeintegrals
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volumeintegrals",
          "XMLModule",
          e));

      s << i.volumeintegrals ();
    }

    // surfaceintegrals
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceintegrals",
          "XMLModule",
          e));

      s << i.surfaceintegrals ();
    }

    // force
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "force",
          "XMLModule",
          e));

      s << i.force ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const localvariables& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // localvariable
    //
    for (localvariables::localvariable_const_iterator
         b (i.localvariable ().begin ()), n (i.localvariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "localvariable",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const localvariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (localvariable::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // format
    //
    if (i.format ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "format",
          e));

      a << *i.format ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // unit
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const view& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // scalar_view
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scalar_view",
          "XMLModule",
          e));

      s << i.scalar_view ();
    }

    // vector_view
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_view",
          "XMLModule",
          e));

      s << i.vector_view ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const scalar_view& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // default
    //
    for (scalar_view::default_const_iterator
         b (i.default_ ().begin ()), n (i.default_ ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vector_view& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // default
    //
    for (vector_view::default_const_iterator
         b (i.default_ ().begin ()), n (i.default_ ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const volumeintegrals& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // volumeintegral
    //
    for (volumeintegrals::volumeintegral_const_iterator
         b (i.volumeintegral ().begin ()), n (i.volumeintegral ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volumeintegral",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const volumeintegral& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (volumeintegral::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // unit
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const surfaceintegrals& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // surfaceintegral
    //
    for (surfaceintegrals::surfaceintegral_const_iterator
         b (i.surfaceintegral ().begin ()), n (i.surfaceintegral ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceintegral",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const surfaceintegral& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (surfaceintegral::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // unit
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const force& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (force::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const volume& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (volume::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // weakforms_volume
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakforms_volume",
          "XMLModule",
          e));

      s << i.weakforms_volume ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const surface& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (surface::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // weakforms_surface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakforms_surface",
          "XMLModule",
          e));

      s << i.weakforms_surface ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakforms_surface& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // group
    //
    if (i.group ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "group",
          "XMLModule",
          e));

      s << *i.group ();
    }

    // weakform_surface
    //
    for (weakforms_surface::weakform_surface_const_iterator
         b (i.weakform_surface ().begin ()), n (i.weakform_surface ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakform_surface",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakform_surface& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boundary
    //
    for (weakform_surface::boundary_const_iterator
         b (i.boundary ().begin ()), n (i.boundary ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary",
          "XMLModule",
          e));

      s << *b;
    }

    // quantity
    //
    for (weakform_surface::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_form
    //
    for (weakform_surface::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (weakform_surface::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // default
    //
    if (i.default_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "default",
          e));

      a << *i.default_ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const expression& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // axi
    //
    if (i.axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi",
          e));

      a << *i.axi ();
    }

    // axi_r
    //
    if (i.axi_r ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_r",
          e));

      a << *i.axi_r ();
    }

    // axi_z
    //
    if (i.axi_z ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_z",
          e));

      a << *i.axi_z ();
    }

    // axi_phi
    //
    if (i.axi_phi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_phi",
          e));

      a << *i.axi_phi ();
    }

    // planar
    //
    if (i.planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar",
          e));

      a << *i.planar ();
    }

    // planar_x
    //
    if (i.planar_x ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_x",
          e));

      a << *i.planar_x ();
    }

    // planar_y
    //
    if (i.planar_y ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_y",
          e));

      a << *i.planar_y ();
    }

    // planar_z
    //
    if (i.planar_z ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_z",
          e));

      a << *i.planar_z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const default_& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const quantity& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }

    // default
    //
    if (i.default_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "default",
          e));

      a << ::xml_schema::as_decimal(*i.default_ ());
    }

    // nonlinearity_planar
    //
    if (i.nonlinearity_planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nonlinearity_planar",
          e));

      a << *i.nonlinearity_planar ();
    }

    // nonlinearity_axi
    //
    if (i.nonlinearity_axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nonlinearity_axi",
          e));

      a << *i.nonlinearity_axi ();
    }

    // dependence
    //
    if (i.dependence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dependence",
          e));

      a << *i.dependence ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // shortname
    //
    if (i.shortname ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << *i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // shortname_dependence
    //
    if (i.shortname_dependence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_dependence",
          e));

      a << *i.shortname_dependence ();
    }

    // shortname_dependence_html
    //
    if (i.shortname_dependence_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_dependence_html",
          e));

      a << *i.shortname_dependence_html ();
    }

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakforms_volume& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // weakform_volume
    //
    for (weakforms_volume::weakform_volume_const_iterator
         b (i.weakform_volume ().begin ()), n (i.weakform_volume ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakform_volume",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakform_volume& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (weakform_volume::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_form
    //
    for (weakform_volume::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (weakform_volume::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // equation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "equation",
          e));

      a << i.equation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const group& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (group::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const matrix_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }

    // j
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "j",
          e));

      a << i.j ();
    }

    // planar_linear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_linear",
          e));

      a << i.planar_linear ();
    }

    // axi_linear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_linear",
          e));

      a << i.axi_linear ();
    }

    // planar_newton
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_newton",
          e));

      a << i.planar_newton ();
    }

    // axi_newton
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_newton",
          e));

      a << i.axi_newton ();
    }

    // symmetric
    //
    if (i.symmetric ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric",
          e));

      a << *i.symmetric ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vector_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }

    // j
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "j",
          e));

      a << i.j ();
    }

    // planar_linear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_linear",
          e));

      a << i.planar_linear ();
    }

    // axi_linear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_linear",
          e));

      a << i.axi_linear ();
    }

    // planar_newton
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_newton",
          e));

      a << i.planar_newton ();
    }

    // axi_newton
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_newton",
          e));

      a << i.axi_newton ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const essential_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }

    // axi_linear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_linear",
          e));

      a << i.axi_linear ();
    }

    // planar_linear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_linear",
          e));

      a << i.planar_linear ();
    }

    // axi_newton
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_newton",
          e));

      a << i.axi_newton ();
    }

    // planar_newton
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_newton",
          e));

      a << i.planar_newton ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (boundary::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (boundary::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_form
    //
    for (boundary::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // essential_form
    //
    for (boundary::essential_form_const_iterator
         b (i.essential_form ().begin ()), n (i.essential_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "essential_form",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // equation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "equation",
          e));

      a << i.equation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field_item& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_key",
          e));

      a << i.field_key ();
    }

    // field_value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_value",
          e));

      a << i.field_value ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

