// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX______RESOURCES_XSD_MODULE_XML_H
#define CXX______RESOURCES_XSD_MODULE_XML_H

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class module;
class general;
class analyses;
class analysis;
class constants;
class constant;
class macros;
class macro;
class preprocessor;
class postprocessor;
class localvariables;
class localvariable;
class view;
class scalar_view;
class vector_view;
class volumeintegrals;
class volumeintegral;
class surfaceintegrals;
class surfaceintegral;
class volume;
class surface;
class expression;
class default_;
class vector_form;
class quantity;
class weakforms;
class weakform;
class boundary;
class essential_form;
class group;
class matrix_form;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class module: public ::xml_schema::type
{
  public:
  // general
  // 
  typedef ::general general_type;
  typedef ::xsd::cxx::tree::traits< general_type, char > general_traits;

  const general_type&
  general () const;

  general_type&
  general ();

  void
  general (const general_type& x);

  void
  general (::std::auto_ptr< general_type > p);

  // constants
  // 
  typedef ::constants constants_type;
  typedef ::xsd::cxx::tree::traits< constants_type, char > constants_traits;

  const constants_type&
  constants () const;

  constants_type&
  constants ();

  void
  constants (const constants_type& x);

  void
  constants (::std::auto_ptr< constants_type > p);

  // macros
  // 
  typedef ::macros macros_type;
  typedef ::xsd::cxx::tree::traits< macros_type, char > macros_traits;

  const macros_type&
  macros () const;

  macros_type&
  macros ();

  void
  macros (const macros_type& x);

  void
  macros (::std::auto_ptr< macros_type > p);

  // volume
  // 
  typedef ::volume volume_type;
  typedef ::xsd::cxx::tree::traits< volume_type, char > volume_traits;

  const volume_type&
  volume () const;

  volume_type&
  volume ();

  void
  volume (const volume_type& x);

  void
  volume (::std::auto_ptr< volume_type > p);

  // surface
  // 
  typedef ::surface surface_type;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_type&
  surface () const;

  surface_type&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (::std::auto_ptr< surface_type > p);

  // preprocessor
  // 
  typedef ::preprocessor preprocessor_type;
  typedef ::xsd::cxx::tree::traits< preprocessor_type, char > preprocessor_traits;

  const preprocessor_type&
  preprocessor () const;

  preprocessor_type&
  preprocessor ();

  void
  preprocessor (const preprocessor_type& x);

  void
  preprocessor (::std::auto_ptr< preprocessor_type > p);

  // postprocessor
  // 
  typedef ::postprocessor postprocessor_type;
  typedef ::xsd::cxx::tree::traits< postprocessor_type, char > postprocessor_traits;

  const postprocessor_type&
  postprocessor () const;

  postprocessor_type&
  postprocessor ();

  void
  postprocessor (const postprocessor_type& x);

  void
  postprocessor (::std::auto_ptr< postprocessor_type > p);

  // Constructors.
  //
  module (const general_type&,
          const constants_type&,
          const macros_type&,
          const volume_type&,
          const surface_type&,
          const preprocessor_type&,
          const postprocessor_type&);

  module (::std::auto_ptr< general_type >&,
          ::std::auto_ptr< constants_type >&,
          ::std::auto_ptr< macros_type >&,
          ::std::auto_ptr< volume_type >&,
          ::std::auto_ptr< surface_type >&,
          ::std::auto_ptr< preprocessor_type >&,
          ::std::auto_ptr< postprocessor_type >&);

  module (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  module (const module& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual module*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~module ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< general_type > general_;
  ::xsd::cxx::tree::one< constants_type > constants_;
  ::xsd::cxx::tree::one< macros_type > macros_;
  ::xsd::cxx::tree::one< volume_type > volume_;
  ::xsd::cxx::tree::one< surface_type > surface_;
  ::xsd::cxx::tree::one< preprocessor_type > preprocessor_;
  ::xsd::cxx::tree::one< postprocessor_type > postprocessor_;
};

class general: public ::xml_schema::type
{
  public:
  // description
  // 
  typedef ::xml_schema::string description_type;
  typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

  const description_type&
  description () const;

  description_type&
  description ();

  void
  description (const description_type& x);

  void
  description (::std::auto_ptr< description_type > p);

  // analyses
  // 
  typedef ::analyses analyses_type;
  typedef ::xsd::cxx::tree::traits< analyses_type, char > analyses_traits;

  const analyses_type&
  analyses () const;

  analyses_type&
  analyses ();

  void
  analyses (const analyses_type& x);

  void
  analyses (::std::auto_ptr< analyses_type > p);

  // deformed_shape
  // 
  typedef ::xml_schema::integer deformed_shape_type;
  typedef ::xsd::cxx::tree::optional< deformed_shape_type > deformed_shape_optional;
  typedef ::xsd::cxx::tree::traits< deformed_shape_type, char > deformed_shape_traits;

  const deformed_shape_optional&
  deformed_shape () const;

  deformed_shape_optional&
  deformed_shape ();

  void
  deformed_shape (const deformed_shape_type& x);

  void
  deformed_shape (const deformed_shape_optional& x);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  general (const description_type&,
           const analyses_type&,
           const id_type&,
           const name_type&);

  general (const description_type&,
           ::std::auto_ptr< analyses_type >&,
           const id_type&,
           const name_type&);

  general (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  general (const general& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual general*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~general ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< description_type > description_;
  ::xsd::cxx::tree::one< analyses_type > analyses_;
  deformed_shape_optional deformed_shape_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class analyses: public ::xml_schema::type
{
  public:
  // analysis
  // 
  typedef ::analysis analysis_type;
  typedef ::xsd::cxx::tree::sequence< analysis_type > analysis_sequence;
  typedef analysis_sequence::iterator analysis_iterator;
  typedef analysis_sequence::const_iterator analysis_const_iterator;
  typedef ::xsd::cxx::tree::traits< analysis_type, char > analysis_traits;

  const analysis_sequence&
  analysis () const;

  analysis_sequence&
  analysis ();

  void
  analysis (const analysis_sequence& s);

  // Constructors.
  //
  analyses ();

  analyses (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  analyses (const analyses& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual analyses*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~analyses ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  analysis_sequence analysis_;
};

class analysis: public ::xml_schema::type
{
  public:
  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // solutions
  // 
  typedef ::xml_schema::integer solutions_type;
  typedef ::xsd::cxx::tree::traits< solutions_type, char > solutions_traits;

  const solutions_type&
  solutions () const;

  solutions_type&
  solutions ();

  void
  solutions (const solutions_type& x);

  // type
  // 
  typedef ::xml_schema::ncname type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  analysis (const id_type&,
            const name_type&,
            const solutions_type&,
            const type_type&);

  analysis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  analysis (const analysis& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual analysis*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~analysis ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< solutions_type > solutions_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class constants: public ::xml_schema::type
{
  public:
  // constant
  // 
  typedef ::constant constant_type;
  typedef ::xsd::cxx::tree::sequence< constant_type > constant_sequence;
  typedef constant_sequence::iterator constant_iterator;
  typedef constant_sequence::const_iterator constant_const_iterator;
  typedef ::xsd::cxx::tree::traits< constant_type, char > constant_traits;

  const constant_sequence&
  constant () const;

  constant_sequence&
  constant ();

  void
  constant (const constant_sequence& s);

  // Constructors.
  //
  constants ();

  constants (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  constants (const constants& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual constants*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~constants ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  constant_sequence constant_;
};

class constant: public ::xml_schema::type
{
  public:
  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // value
  // 
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  constant (const id_type&,
            const value_type&);

  constant (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  constant (const constant& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual constant*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~constant ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< value_type > value_;
};

class macros: public ::xml_schema::type
{
  public:
  // macro
  // 
  typedef ::macro macro_type;
  typedef ::xsd::cxx::tree::traits< macro_type, char > macro_traits;

  const macro_type&
  macro () const;

  macro_type&
  macro ();

  void
  macro (const macro_type& x);

  void
  macro (::std::auto_ptr< macro_type > p);

  // Constructors.
  //
  macros (const macro_type&);

  macros (::std::auto_ptr< macro_type >&);

  macros (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  macros (const macros& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual macros*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~macros ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< macro_type > macro_;
};

class macro: public ::xml_schema::type
{
  public:
  // expression
  // 
  typedef ::xml_schema::simple_type expression_type;
  typedef ::xsd::cxx::tree::traits< expression_type, char > expression_traits;

  const expression_type&
  expression () const;

  expression_type&
  expression ();

  void
  expression (const expression_type& x);

  void
  expression (::std::auto_ptr< expression_type > p);

  // id
  // 
  typedef ::xml_schema::simple_type id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  macro (const expression_type&,
         const id_type&);

  macro (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  macro (const macro& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual macro*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~macro ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< expression_type > expression_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class preprocessor: public ::xml_schema::type
{
  public:
  // volume
  // 
  typedef ::volume volume_type;
  typedef ::xsd::cxx::tree::traits< volume_type, char > volume_traits;

  const volume_type&
  volume () const;

  volume_type&
  volume ();

  void
  volume (const volume_type& x);

  void
  volume (::std::auto_ptr< volume_type > p);

  // surface
  // 
  typedef ::surface surface_type;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_type&
  surface () const;

  surface_type&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (::std::auto_ptr< surface_type > p);

  // Constructors.
  //
  preprocessor (const volume_type&,
                const surface_type&);

  preprocessor (::std::auto_ptr< volume_type >&,
                ::std::auto_ptr< surface_type >&);

  preprocessor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  preprocessor (const preprocessor& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual preprocessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~preprocessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< volume_type > volume_;
  ::xsd::cxx::tree::one< surface_type > surface_;
};

class postprocessor: public ::xml_schema::type
{
  public:
  // localvariables
  // 
  typedef ::localvariables localvariables_type;
  typedef ::xsd::cxx::tree::traits< localvariables_type, char > localvariables_traits;

  const localvariables_type&
  localvariables () const;

  localvariables_type&
  localvariables ();

  void
  localvariables (const localvariables_type& x);

  void
  localvariables (::std::auto_ptr< localvariables_type > p);

  // view
  // 
  typedef ::view view_type;
  typedef ::xsd::cxx::tree::traits< view_type, char > view_traits;

  const view_type&
  view () const;

  view_type&
  view ();

  void
  view (const view_type& x);

  void
  view (::std::auto_ptr< view_type > p);

  // volumeintegrals
  // 
  typedef ::volumeintegrals volumeintegrals_type;
  typedef ::xsd::cxx::tree::traits< volumeintegrals_type, char > volumeintegrals_traits;

  const volumeintegrals_type&
  volumeintegrals () const;

  volumeintegrals_type&
  volumeintegrals ();

  void
  volumeintegrals (const volumeintegrals_type& x);

  void
  volumeintegrals (::std::auto_ptr< volumeintegrals_type > p);

  // surfaceintegrals
  // 
  typedef ::surfaceintegrals surfaceintegrals_type;
  typedef ::xsd::cxx::tree::traits< surfaceintegrals_type, char > surfaceintegrals_traits;

  const surfaceintegrals_type&
  surfaceintegrals () const;

  surfaceintegrals_type&
  surfaceintegrals ();

  void
  surfaceintegrals (const surfaceintegrals_type& x);

  void
  surfaceintegrals (::std::auto_ptr< surfaceintegrals_type > p);

  // Constructors.
  //
  postprocessor (const localvariables_type&,
                 const view_type&,
                 const volumeintegrals_type&,
                 const surfaceintegrals_type&);

  postprocessor (::std::auto_ptr< localvariables_type >&,
                 ::std::auto_ptr< view_type >&,
                 ::std::auto_ptr< volumeintegrals_type >&,
                 ::std::auto_ptr< surfaceintegrals_type >&);

  postprocessor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  postprocessor (const postprocessor& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual postprocessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~postprocessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< localvariables_type > localvariables_;
  ::xsd::cxx::tree::one< view_type > view_;
  ::xsd::cxx::tree::one< volumeintegrals_type > volumeintegrals_;
  ::xsd::cxx::tree::one< surfaceintegrals_type > surfaceintegrals_;
};

class localvariables: public ::xml_schema::type
{
  public:
  // localvariable
  // 
  typedef ::localvariable localvariable_type;
  typedef ::xsd::cxx::tree::sequence< localvariable_type > localvariable_sequence;
  typedef localvariable_sequence::iterator localvariable_iterator;
  typedef localvariable_sequence::const_iterator localvariable_const_iterator;
  typedef ::xsd::cxx::tree::traits< localvariable_type, char > localvariable_traits;

  const localvariable_sequence&
  localvariable () const;

  localvariable_sequence&
  localvariable ();

  void
  localvariable (const localvariable_sequence& s);

  // Constructors.
  //
  localvariables ();

  localvariables (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  localvariables (const localvariables& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual localvariables*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~localvariables ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  localvariable_sequence localvariable_;
};

class localvariable: public ::xml_schema::type
{
  public:
  // expression
  // 
  typedef ::expression expression_type;
  typedef ::xsd::cxx::tree::sequence< expression_type > expression_sequence;
  typedef expression_sequence::iterator expression_iterator;
  typedef expression_sequence::const_iterator expression_const_iterator;
  typedef ::xsd::cxx::tree::traits< expression_type, char > expression_traits;

  const expression_sequence&
  expression () const;

  expression_sequence&
  expression ();

  void
  expression (const expression_sequence& s);

  // format
  // 
  typedef ::xml_schema::simple_type format_type;
  typedef ::xsd::cxx::tree::optional< format_type > format_optional;
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  const format_optional&
  format () const;

  format_optional&
  format ();

  void
  format (const format_type& x);

  void
  format (const format_optional& x);

  void
  format (::std::auto_ptr< format_type > p);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // shortname
  // 
  typedef ::xml_schema::ncname shortname_type;
  typedef ::xsd::cxx::tree::traits< shortname_type, char > shortname_traits;

  const shortname_type&
  shortname () const;

  shortname_type&
  shortname ();

  void
  shortname (const shortname_type& x);

  void
  shortname (::std::auto_ptr< shortname_type > p);

  // shortname_html
  // 
  typedef ::xml_schema::simple_type shortname_html_type;
  typedef ::xsd::cxx::tree::optional< shortname_html_type > shortname_html_optional;
  typedef ::xsd::cxx::tree::traits< shortname_html_type, char > shortname_html_traits;

  const shortname_html_optional&
  shortname_html () const;

  shortname_html_optional&
  shortname_html ();

  void
  shortname_html (const shortname_html_type& x);

  void
  shortname_html (const shortname_html_optional& x);

  void
  shortname_html (::std::auto_ptr< shortname_html_type > p);

  // shortname_latex
  // 
  typedef ::xml_schema::simple_type shortname_latex_type;
  typedef ::xsd::cxx::tree::optional< shortname_latex_type > shortname_latex_optional;
  typedef ::xsd::cxx::tree::traits< shortname_latex_type, char > shortname_latex_traits;

  const shortname_latex_optional&
  shortname_latex () const;

  shortname_latex_optional&
  shortname_latex ();

  void
  shortname_latex (const shortname_latex_type& x);

  void
  shortname_latex (const shortname_latex_optional& x);

  void
  shortname_latex (::std::auto_ptr< shortname_latex_type > p);

  // type
  // 
  typedef ::xml_schema::ncname type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // unit
  // 
  typedef ::xml_schema::simple_type unit_type;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_type&
  unit () const;

  unit_type&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (::std::auto_ptr< unit_type > p);

  // unit_html
  // 
  typedef ::xml_schema::simple_type unit_html_type;
  typedef ::xsd::cxx::tree::optional< unit_html_type > unit_html_optional;
  typedef ::xsd::cxx::tree::traits< unit_html_type, char > unit_html_traits;

  const unit_html_optional&
  unit_html () const;

  unit_html_optional&
  unit_html ();

  void
  unit_html (const unit_html_type& x);

  void
  unit_html (const unit_html_optional& x);

  void
  unit_html (::std::auto_ptr< unit_html_type > p);

  // unit_latex
  // 
  typedef ::xml_schema::simple_type unit_latex_type;
  typedef ::xsd::cxx::tree::optional< unit_latex_type > unit_latex_optional;
  typedef ::xsd::cxx::tree::traits< unit_latex_type, char > unit_latex_traits;

  const unit_latex_optional&
  unit_latex () const;

  unit_latex_optional&
  unit_latex ();

  void
  unit_latex (const unit_latex_type& x);

  void
  unit_latex (const unit_latex_optional& x);

  void
  unit_latex (::std::auto_ptr< unit_latex_type > p);

  // Constructors.
  //
  localvariable (const id_type&,
                 const name_type&,
                 const shortname_type&,
                 const type_type&,
                 const unit_type&);

  localvariable (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  localvariable (const localvariable& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual localvariable*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~localvariable ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  expression_sequence expression_;
  format_optional format_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< shortname_type > shortname_;
  shortname_html_optional shortname_html_;
  shortname_latex_optional shortname_latex_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< unit_type > unit_;
  unit_html_optional unit_html_;
  unit_latex_optional unit_latex_;
};

class view: public ::xml_schema::type
{
  public:
  // scalar_view
  // 
  typedef ::scalar_view scalar_view_type;
  typedef ::xsd::cxx::tree::traits< scalar_view_type, char > scalar_view_traits;

  const scalar_view_type&
  scalar_view () const;

  scalar_view_type&
  scalar_view ();

  void
  scalar_view (const scalar_view_type& x);

  void
  scalar_view (::std::auto_ptr< scalar_view_type > p);

  // vector_view
  // 
  typedef ::vector_view vector_view_type;
  typedef ::xsd::cxx::tree::traits< vector_view_type, char > vector_view_traits;

  const vector_view_type&
  vector_view () const;

  vector_view_type&
  vector_view ();

  void
  vector_view (const vector_view_type& x);

  void
  vector_view (::std::auto_ptr< vector_view_type > p);

  // Constructors.
  //
  view (const scalar_view_type&,
        const vector_view_type&);

  view (::std::auto_ptr< scalar_view_type >&,
        ::std::auto_ptr< vector_view_type >&);

  view (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  view (const view& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual view*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~view ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< scalar_view_type > scalar_view_;
  ::xsd::cxx::tree::one< vector_view_type > vector_view_;
};

class scalar_view: public ::xml_schema::type
{
  public:
  // default
  // 
  typedef ::default_ default_type;
  typedef ::xsd::cxx::tree::sequence< default_type > default_sequence;
  typedef default_sequence::iterator default_iterator;
  typedef default_sequence::const_iterator default_const_iterator;
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  const default_sequence&
  default_ () const;

  default_sequence&
  default_ ();

  void
  default_ (const default_sequence& s);

  // Constructors.
  //
  scalar_view ();

  scalar_view (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  scalar_view (const scalar_view& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual scalar_view*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~scalar_view ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  default_sequence default__;
};

class vector_view: public ::xml_schema::type
{
  public:
  // default
  // 
  typedef ::default_ default_type;
  typedef ::xsd::cxx::tree::sequence< default_type > default_sequence;
  typedef default_sequence::iterator default_iterator;
  typedef default_sequence::const_iterator default_const_iterator;
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  const default_sequence&
  default_ () const;

  default_sequence&
  default_ ();

  void
  default_ (const default_sequence& s);

  // Constructors.
  //
  vector_view ();

  vector_view (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  vector_view (const vector_view& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual vector_view*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~vector_view ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  default_sequence default__;
};

class volumeintegrals: public ::xml_schema::type
{
  public:
  // volumeintegral
  // 
  typedef ::volumeintegral volumeintegral_type;
  typedef ::xsd::cxx::tree::sequence< volumeintegral_type > volumeintegral_sequence;
  typedef volumeintegral_sequence::iterator volumeintegral_iterator;
  typedef volumeintegral_sequence::const_iterator volumeintegral_const_iterator;
  typedef ::xsd::cxx::tree::traits< volumeintegral_type, char > volumeintegral_traits;

  const volumeintegral_sequence&
  volumeintegral () const;

  volumeintegral_sequence&
  volumeintegral ();

  void
  volumeintegral (const volumeintegral_sequence& s);

  // Constructors.
  //
  volumeintegrals ();

  volumeintegrals (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  volumeintegrals (const volumeintegrals& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual volumeintegrals*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~volumeintegrals ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  volumeintegral_sequence volumeintegral_;
};

class volumeintegral: public ::xml_schema::type
{
  public:
  // expression
  // 
  typedef ::expression expression_type;
  typedef ::xsd::cxx::tree::sequence< expression_type > expression_sequence;
  typedef expression_sequence::iterator expression_iterator;
  typedef expression_sequence::const_iterator expression_const_iterator;
  typedef ::xsd::cxx::tree::traits< expression_type, char > expression_traits;

  const expression_sequence&
  expression () const;

  expression_sequence&
  expression ();

  void
  expression (const expression_sequence& s);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // shortname
  // 
  typedef ::xml_schema::ncname shortname_type;
  typedef ::xsd::cxx::tree::traits< shortname_type, char > shortname_traits;

  const shortname_type&
  shortname () const;

  shortname_type&
  shortname ();

  void
  shortname (const shortname_type& x);

  void
  shortname (::std::auto_ptr< shortname_type > p);

  // shortname_html
  // 
  typedef ::xml_schema::simple_type shortname_html_type;
  typedef ::xsd::cxx::tree::optional< shortname_html_type > shortname_html_optional;
  typedef ::xsd::cxx::tree::traits< shortname_html_type, char > shortname_html_traits;

  const shortname_html_optional&
  shortname_html () const;

  shortname_html_optional&
  shortname_html ();

  void
  shortname_html (const shortname_html_type& x);

  void
  shortname_html (const shortname_html_optional& x);

  void
  shortname_html (::std::auto_ptr< shortname_html_type > p);

  // shortname_latex
  // 
  typedef ::xml_schema::simple_type shortname_latex_type;
  typedef ::xsd::cxx::tree::optional< shortname_latex_type > shortname_latex_optional;
  typedef ::xsd::cxx::tree::traits< shortname_latex_type, char > shortname_latex_traits;

  const shortname_latex_optional&
  shortname_latex () const;

  shortname_latex_optional&
  shortname_latex ();

  void
  shortname_latex (const shortname_latex_type& x);

  void
  shortname_latex (const shortname_latex_optional& x);

  void
  shortname_latex (::std::auto_ptr< shortname_latex_type > p);

  // unit
  // 
  typedef ::xml_schema::ncname unit_type;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_type&
  unit () const;

  unit_type&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (::std::auto_ptr< unit_type > p);

  // unit_html
  // 
  typedef ::xml_schema::simple_type unit_html_type;
  typedef ::xsd::cxx::tree::optional< unit_html_type > unit_html_optional;
  typedef ::xsd::cxx::tree::traits< unit_html_type, char > unit_html_traits;

  const unit_html_optional&
  unit_html () const;

  unit_html_optional&
  unit_html ();

  void
  unit_html (const unit_html_type& x);

  void
  unit_html (const unit_html_optional& x);

  void
  unit_html (::std::auto_ptr< unit_html_type > p);

  // unit_latex
  // 
  typedef ::xml_schema::simple_type unit_latex_type;
  typedef ::xsd::cxx::tree::optional< unit_latex_type > unit_latex_optional;
  typedef ::xsd::cxx::tree::traits< unit_latex_type, char > unit_latex_traits;

  const unit_latex_optional&
  unit_latex () const;

  unit_latex_optional&
  unit_latex ();

  void
  unit_latex (const unit_latex_type& x);

  void
  unit_latex (const unit_latex_optional& x);

  void
  unit_latex (::std::auto_ptr< unit_latex_type > p);

  // Constructors.
  //
  volumeintegral (const id_type&,
                  const name_type&,
                  const shortname_type&,
                  const unit_type&);

  volumeintegral (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  volumeintegral (const volumeintegral& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual volumeintegral*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~volumeintegral ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  expression_sequence expression_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< shortname_type > shortname_;
  shortname_html_optional shortname_html_;
  shortname_latex_optional shortname_latex_;
  ::xsd::cxx::tree::one< unit_type > unit_;
  unit_html_optional unit_html_;
  unit_latex_optional unit_latex_;
};

class surfaceintegrals: public ::xml_schema::type
{
  public:
  // surfaceintegral
  // 
  typedef ::surfaceintegral surfaceintegral_type;
  typedef ::xsd::cxx::tree::sequence< surfaceintegral_type > surfaceintegral_sequence;
  typedef surfaceintegral_sequence::iterator surfaceintegral_iterator;
  typedef surfaceintegral_sequence::const_iterator surfaceintegral_const_iterator;
  typedef ::xsd::cxx::tree::traits< surfaceintegral_type, char > surfaceintegral_traits;

  const surfaceintegral_sequence&
  surfaceintegral () const;

  surfaceintegral_sequence&
  surfaceintegral ();

  void
  surfaceintegral (const surfaceintegral_sequence& s);

  // Constructors.
  //
  surfaceintegrals ();

  surfaceintegrals (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  surfaceintegrals (const surfaceintegrals& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual surfaceintegrals*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~surfaceintegrals ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  surfaceintegral_sequence surfaceintegral_;
};

class surfaceintegral: public ::xml_schema::type
{
  public:
  // expression
  // 
  typedef ::expression expression_type;
  typedef ::xsd::cxx::tree::sequence< expression_type > expression_sequence;
  typedef expression_sequence::iterator expression_iterator;
  typedef expression_sequence::const_iterator expression_const_iterator;
  typedef ::xsd::cxx::tree::traits< expression_type, char > expression_traits;

  const expression_sequence&
  expression () const;

  expression_sequence&
  expression ();

  void
  expression (const expression_sequence& s);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // shortname
  // 
  typedef ::xml_schema::ncname shortname_type;
  typedef ::xsd::cxx::tree::traits< shortname_type, char > shortname_traits;

  const shortname_type&
  shortname () const;

  shortname_type&
  shortname ();

  void
  shortname (const shortname_type& x);

  void
  shortname (::std::auto_ptr< shortname_type > p);

  // shortname_html
  // 
  typedef ::xml_schema::simple_type shortname_html_type;
  typedef ::xsd::cxx::tree::optional< shortname_html_type > shortname_html_optional;
  typedef ::xsd::cxx::tree::traits< shortname_html_type, char > shortname_html_traits;

  const shortname_html_optional&
  shortname_html () const;

  shortname_html_optional&
  shortname_html ();

  void
  shortname_html (const shortname_html_type& x);

  void
  shortname_html (const shortname_html_optional& x);

  void
  shortname_html (::std::auto_ptr< shortname_html_type > p);

  // unit
  // 
  typedef ::xml_schema::ncname unit_type;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_type&
  unit () const;

  unit_type&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (::std::auto_ptr< unit_type > p);

  // unit_html
  // 
  typedef ::xml_schema::simple_type unit_html_type;
  typedef ::xsd::cxx::tree::optional< unit_html_type > unit_html_optional;
  typedef ::xsd::cxx::tree::traits< unit_html_type, char > unit_html_traits;

  const unit_html_optional&
  unit_html () const;

  unit_html_optional&
  unit_html ();

  void
  unit_html (const unit_html_type& x);

  void
  unit_html (const unit_html_optional& x);

  void
  unit_html (::std::auto_ptr< unit_html_type > p);

  // unit_latex
  // 
  typedef ::xml_schema::simple_type unit_latex_type;
  typedef ::xsd::cxx::tree::optional< unit_latex_type > unit_latex_optional;
  typedef ::xsd::cxx::tree::traits< unit_latex_type, char > unit_latex_traits;

  const unit_latex_optional&
  unit_latex () const;

  unit_latex_optional&
  unit_latex ();

  void
  unit_latex (const unit_latex_type& x);

  void
  unit_latex (const unit_latex_optional& x);

  void
  unit_latex (::std::auto_ptr< unit_latex_type > p);

  // Constructors.
  //
  surfaceintegral (const id_type&,
                   const name_type&,
                   const shortname_type&,
                   const unit_type&);

  surfaceintegral (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  surfaceintegral (const surfaceintegral& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual surfaceintegral*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~surfaceintegral ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  expression_sequence expression_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< shortname_type > shortname_;
  shortname_html_optional shortname_html_;
  ::xsd::cxx::tree::one< unit_type > unit_;
  unit_html_optional unit_html_;
  unit_latex_optional unit_latex_;
};

class volume: public ::xml_schema::type
{
  public:
  // quantity
  // 
  typedef ::quantity quantity_type;
  typedef ::xsd::cxx::tree::sequence< quantity_type > quantity_sequence;
  typedef quantity_sequence::iterator quantity_iterator;
  typedef quantity_sequence::const_iterator quantity_const_iterator;
  typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

  const quantity_sequence&
  quantity () const;

  quantity_sequence&
  quantity ();

  void
  quantity (const quantity_sequence& s);

  // weakforms
  // 
  typedef ::weakforms weakforms_type;
  typedef ::xsd::cxx::tree::optional< weakforms_type > weakforms_optional;
  typedef ::xsd::cxx::tree::traits< weakforms_type, char > weakforms_traits;

  const weakforms_optional&
  weakforms () const;

  weakforms_optional&
  weakforms ();

  void
  weakforms (const weakforms_type& x);

  void
  weakforms (const weakforms_optional& x);

  void
  weakforms (::std::auto_ptr< weakforms_type > p);

  // group
  // 
  typedef ::group group_type;
  typedef ::xsd::cxx::tree::sequence< group_type > group_sequence;
  typedef group_sequence::iterator group_iterator;
  typedef group_sequence::const_iterator group_const_iterator;
  typedef ::xsd::cxx::tree::traits< group_type, char > group_traits;

  const group_sequence&
  group () const;

  group_sequence&
  group ();

  void
  group (const group_sequence& s);

  // Constructors.
  //
  volume ();

  volume (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  volume (const volume& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual volume*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~volume ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  quantity_sequence quantity_;
  weakforms_optional weakforms_;
  group_sequence group_;
};

class surface: public ::xml_schema::type
{
  public:
  // group
  // 
  typedef ::group group_type;
  typedef ::xsd::cxx::tree::optional< group_type > group_optional;
  typedef ::xsd::cxx::tree::traits< group_type, char > group_traits;

  const group_optional&
  group () const;

  group_optional&
  group ();

  void
  group (const group_type& x);

  void
  group (const group_optional& x);

  void
  group (::std::auto_ptr< group_type > p);

  // quantity
  // 
  typedef ::quantity quantity_type;
  typedef ::xsd::cxx::tree::sequence< quantity_type > quantity_sequence;
  typedef quantity_sequence::iterator quantity_iterator;
  typedef quantity_sequence::const_iterator quantity_const_iterator;
  typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

  const quantity_sequence&
  quantity () const;

  quantity_sequence&
  quantity ();

  void
  quantity (const quantity_sequence& s);

  // weakforms
  // 
  typedef ::weakforms weakforms_type;
  typedef ::xsd::cxx::tree::optional< weakforms_type > weakforms_optional;
  typedef ::xsd::cxx::tree::traits< weakforms_type, char > weakforms_traits;

  const weakforms_optional&
  weakforms () const;

  weakforms_optional&
  weakforms ();

  void
  weakforms (const weakforms_type& x);

  void
  weakforms (const weakforms_optional& x);

  void
  weakforms (::std::auto_ptr< weakforms_type > p);

  // Constructors.
  //
  surface ();

  surface (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  surface (const surface& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual surface*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~surface ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  group_optional group_;
  quantity_sequence quantity_;
  weakforms_optional weakforms_;
};

class expression: public ::xml_schema::type
{
  public:
  // analysistype
  // 
  typedef ::xml_schema::ncname analysistype_type;
  typedef ::xsd::cxx::tree::traits< analysistype_type, char > analysistype_traits;

  const analysistype_type&
  analysistype () const;

  analysistype_type&
  analysistype ();

  void
  analysistype (const analysistype_type& x);

  void
  analysistype (::std::auto_ptr< analysistype_type > p);

  // axi
  // 
  typedef ::xml_schema::simple_type axi_type;
  typedef ::xsd::cxx::tree::optional< axi_type > axi_optional;
  typedef ::xsd::cxx::tree::traits< axi_type, char > axi_traits;

  const axi_optional&
  axi () const;

  axi_optional&
  axi ();

  void
  axi (const axi_type& x);

  void
  axi (const axi_optional& x);

  void
  axi (::std::auto_ptr< axi_type > p);

  // axi_r
  // 
  typedef ::xml_schema::simple_type axi_r_type;
  typedef ::xsd::cxx::tree::optional< axi_r_type > axi_r_optional;
  typedef ::xsd::cxx::tree::traits< axi_r_type, char > axi_r_traits;

  const axi_r_optional&
  axi_r () const;

  axi_r_optional&
  axi_r ();

  void
  axi_r (const axi_r_type& x);

  void
  axi_r (const axi_r_optional& x);

  void
  axi_r (::std::auto_ptr< axi_r_type > p);

  // axi_z
  // 
  typedef ::xml_schema::simple_type axi_z_type;
  typedef ::xsd::cxx::tree::optional< axi_z_type > axi_z_optional;
  typedef ::xsd::cxx::tree::traits< axi_z_type, char > axi_z_traits;

  const axi_z_optional&
  axi_z () const;

  axi_z_optional&
  axi_z ();

  void
  axi_z (const axi_z_type& x);

  void
  axi_z (const axi_z_optional& x);

  void
  axi_z (::std::auto_ptr< axi_z_type > p);

  // planar
  // 
  typedef ::xml_schema::simple_type planar_type;
  typedef ::xsd::cxx::tree::optional< planar_type > planar_optional;
  typedef ::xsd::cxx::tree::traits< planar_type, char > planar_traits;

  const planar_optional&
  planar () const;

  planar_optional&
  planar ();

  void
  planar (const planar_type& x);

  void
  planar (const planar_optional& x);

  void
  planar (::std::auto_ptr< planar_type > p);

  // planar_x
  // 
  typedef ::xml_schema::simple_type planar_x_type;
  typedef ::xsd::cxx::tree::optional< planar_x_type > planar_x_optional;
  typedef ::xsd::cxx::tree::traits< planar_x_type, char > planar_x_traits;

  const planar_x_optional&
  planar_x () const;

  planar_x_optional&
  planar_x ();

  void
  planar_x (const planar_x_type& x);

  void
  planar_x (const planar_x_optional& x);

  void
  planar_x (::std::auto_ptr< planar_x_type > p);

  // planar_y
  // 
  typedef ::xml_schema::simple_type planar_y_type;
  typedef ::xsd::cxx::tree::optional< planar_y_type > planar_y_optional;
  typedef ::xsd::cxx::tree::traits< planar_y_type, char > planar_y_traits;

  const planar_y_optional&
  planar_y () const;

  planar_y_optional&
  planar_y ();

  void
  planar_y (const planar_y_type& x);

  void
  planar_y (const planar_y_optional& x);

  void
  planar_y (::std::auto_ptr< planar_y_type > p);

  // Constructors.
  //
  expression (const analysistype_type&);

  expression (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  expression (const expression& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual expression*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~expression ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< analysistype_type > analysistype_;
  axi_optional axi_;
  axi_r_optional axi_r_;
  axi_z_optional axi_z_;
  planar_optional planar_;
  planar_x_optional planar_x_;
  planar_y_optional planar_y_;
};

class default_: public ::xml_schema::type
{
  public:
  // analysistype
  // 
  typedef ::xml_schema::ncname analysistype_type;
  typedef ::xsd::cxx::tree::traits< analysistype_type, char > analysistype_traits;

  const analysistype_type&
  analysistype () const;

  analysistype_type&
  analysistype ();

  void
  analysistype (const analysistype_type& x);

  void
  analysistype (::std::auto_ptr< analysistype_type > p);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // Constructors.
  //
  default_ (const analysistype_type&,
            const id_type&);

  default_ (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  default_ (const default_& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual default_*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~default_ ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< analysistype_type > analysistype_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class vector_form: public ::xml_schema::type
{
  public:
  // axi
  // 
  typedef ::xml_schema::simple_type axi_type;
  typedef ::xsd::cxx::tree::optional< axi_type > axi_optional;
  typedef ::xsd::cxx::tree::traits< axi_type, char > axi_traits;

  const axi_optional&
  axi () const;

  axi_optional&
  axi ();

  void
  axi (const axi_type& x);

  void
  axi (const axi_optional& x);

  void
  axi (::std::auto_ptr< axi_type > p);

  // i
  // 
  typedef ::xml_schema::integer i_type;
  typedef ::xsd::cxx::tree::optional< i_type > i_optional;
  typedef ::xsd::cxx::tree::traits< i_type, char > i_traits;

  const i_optional&
  i () const;

  i_optional&
  i ();

  void
  i (const i_type& x);

  void
  i (const i_optional& x);

  // j
  // 
  typedef ::xml_schema::integer j_type;
  typedef ::xsd::cxx::tree::optional< j_type > j_optional;
  typedef ::xsd::cxx::tree::traits< j_type, char > j_traits;

  const j_optional&
  j () const;

  j_optional&
  j ();

  void
  j (const j_type& x);

  void
  j (const j_optional& x);

  // planar
  // 
  typedef ::xml_schema::simple_type planar_type;
  typedef ::xsd::cxx::tree::optional< planar_type > planar_optional;
  typedef ::xsd::cxx::tree::traits< planar_type, char > planar_traits;

  const planar_optional&
  planar () const;

  planar_optional&
  planar ();

  void
  planar (const planar_type& x);

  void
  planar (const planar_optional& x);

  void
  planar (::std::auto_ptr< planar_type > p);

  // Constructors.
  //
  vector_form ();

  vector_form (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  vector_form (const vector_form& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual vector_form*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~vector_form ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  axi_optional axi_;
  i_optional i_;
  j_optional j_;
  planar_optional planar_;
};

class quantity: public ::xml_schema::type
{
  public:
  // condition
  // 
  typedef ::xml_schema::simple_type condition_type;
  typedef ::xsd::cxx::tree::optional< condition_type > condition_optional;
  typedef ::xsd::cxx::tree::traits< condition_type, char > condition_traits;

  const condition_optional&
  condition () const;

  condition_optional&
  condition ();

  void
  condition (const condition_type& x);

  void
  condition (const condition_optional& x);

  void
  condition (::std::auto_ptr< condition_type > p);

  // default
  // 
  typedef ::xml_schema::decimal default_type;
  typedef ::xsd::cxx::tree::optional< default_type > default_optional;
  typedef ::xsd::cxx::tree::traits< default_type, char, ::xsd::cxx::tree::schema_type::decimal > default_traits;

  const default_optional&
  default_ () const;

  default_optional&
  default_ ();

  void
  default_ (const default_type& x);

  void
  default_ (const default_optional& x);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // nonlin
  // 
  typedef ::xml_schema::integer nonlin_type;
  typedef ::xsd::cxx::tree::optional< nonlin_type > nonlin_optional;
  typedef ::xsd::cxx::tree::traits< nonlin_type, char > nonlin_traits;

  const nonlin_optional&
  nonlin () const;

  nonlin_optional&
  nonlin ();

  void
  nonlin (const nonlin_type& x);

  void
  nonlin (const nonlin_optional& x);

  // shortname
  // 
  typedef ::xml_schema::simple_type shortname_type;
  typedef ::xsd::cxx::tree::optional< shortname_type > shortname_optional;
  typedef ::xsd::cxx::tree::traits< shortname_type, char > shortname_traits;

  const shortname_optional&
  shortname () const;

  shortname_optional&
  shortname ();

  void
  shortname (const shortname_type& x);

  void
  shortname (const shortname_optional& x);

  void
  shortname (::std::auto_ptr< shortname_type > p);

  // shortname_html
  // 
  typedef ::xml_schema::simple_type shortname_html_type;
  typedef ::xsd::cxx::tree::optional< shortname_html_type > shortname_html_optional;
  typedef ::xsd::cxx::tree::traits< shortname_html_type, char > shortname_html_traits;

  const shortname_html_optional&
  shortname_html () const;

  shortname_html_optional&
  shortname_html ();

  void
  shortname_html (const shortname_html_type& x);

  void
  shortname_html (const shortname_html_optional& x);

  void
  shortname_html (::std::auto_ptr< shortname_html_type > p);

  // shortname_latex
  // 
  typedef ::xml_schema::simple_type shortname_latex_type;
  typedef ::xsd::cxx::tree::optional< shortname_latex_type > shortname_latex_optional;
  typedef ::xsd::cxx::tree::traits< shortname_latex_type, char > shortname_latex_traits;

  const shortname_latex_optional&
  shortname_latex () const;

  shortname_latex_optional&
  shortname_latex ();

  void
  shortname_latex (const shortname_latex_type& x);

  void
  shortname_latex (const shortname_latex_optional& x);

  void
  shortname_latex (::std::auto_ptr< shortname_latex_type > p);

  // timedep
  // 
  typedef ::xml_schema::integer timedep_type;
  typedef ::xsd::cxx::tree::optional< timedep_type > timedep_optional;
  typedef ::xsd::cxx::tree::traits< timedep_type, char > timedep_traits;

  const timedep_optional&
  timedep () const;

  timedep_optional&
  timedep ();

  void
  timedep (const timedep_type& x);

  void
  timedep (const timedep_optional& x);

  // unit
  // 
  typedef ::xml_schema::simple_type unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::auto_ptr< unit_type > p);

  // unit_html
  // 
  typedef ::xml_schema::simple_type unit_html_type;
  typedef ::xsd::cxx::tree::optional< unit_html_type > unit_html_optional;
  typedef ::xsd::cxx::tree::traits< unit_html_type, char > unit_html_traits;

  const unit_html_optional&
  unit_html () const;

  unit_html_optional&
  unit_html ();

  void
  unit_html (const unit_html_type& x);

  void
  unit_html (const unit_html_optional& x);

  void
  unit_html (::std::auto_ptr< unit_html_type > p);

  // unit_latex
  // 
  typedef ::xml_schema::simple_type unit_latex_type;
  typedef ::xsd::cxx::tree::optional< unit_latex_type > unit_latex_optional;
  typedef ::xsd::cxx::tree::traits< unit_latex_type, char > unit_latex_traits;

  const unit_latex_optional&
  unit_latex () const;

  unit_latex_optional&
  unit_latex ();

  void
  unit_latex (const unit_latex_type& x);

  void
  unit_latex (const unit_latex_optional& x);

  void
  unit_latex (::std::auto_ptr< unit_latex_type > p);

  // Constructors.
  //
  quantity (const id_type&);

  quantity (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  quantity (const quantity& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual quantity*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~quantity ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  condition_optional condition_;
  default_optional default__;
  ::xsd::cxx::tree::one< id_type > id_;
  name_optional name_;
  nonlin_optional nonlin_;
  shortname_optional shortname_;
  shortname_html_optional shortname_html_;
  shortname_latex_optional shortname_latex_;
  timedep_optional timedep_;
  unit_optional unit_;
  unit_html_optional unit_html_;
  unit_latex_optional unit_latex_;
};

class weakforms: public ::xml_schema::type
{
  public:
  // weakform
  // 
  typedef ::weakform weakform_type;
  typedef ::xsd::cxx::tree::sequence< weakform_type > weakform_sequence;
  typedef weakform_sequence::iterator weakform_iterator;
  typedef weakform_sequence::const_iterator weakform_const_iterator;
  typedef ::xsd::cxx::tree::traits< weakform_type, char > weakform_traits;

  const weakform_sequence&
  weakform () const;

  weakform_sequence&
  weakform ();

  void
  weakform (const weakform_sequence& s);

  // Constructors.
  //
  weakforms ();

  weakforms (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  weakforms (const weakforms& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual weakforms*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~weakforms ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  weakform_sequence weakform_;
};

class weakform: public ::xml_schema::type
{
  public:
  // boundary
  // 
  typedef ::boundary boundary_type;
  typedef ::xsd::cxx::tree::sequence< boundary_type > boundary_sequence;
  typedef boundary_sequence::iterator boundary_iterator;
  typedef boundary_sequence::const_iterator boundary_const_iterator;
  typedef ::xsd::cxx::tree::traits< boundary_type, char > boundary_traits;

  const boundary_sequence&
  boundary () const;

  boundary_sequence&
  boundary ();

  void
  boundary (const boundary_sequence& s);

  // quantity
  // 
  typedef ::quantity quantity_type;
  typedef ::xsd::cxx::tree::sequence< quantity_type > quantity_sequence;
  typedef quantity_sequence::iterator quantity_iterator;
  typedef quantity_sequence::const_iterator quantity_const_iterator;
  typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

  const quantity_sequence&
  quantity () const;

  quantity_sequence&
  quantity ();

  void
  quantity (const quantity_sequence& s);

  // matrix_form
  // 
  typedef ::matrix_form matrix_form_type;
  typedef ::xsd::cxx::tree::sequence< matrix_form_type > matrix_form_sequence;
  typedef matrix_form_sequence::iterator matrix_form_iterator;
  typedef matrix_form_sequence::const_iterator matrix_form_const_iterator;
  typedef ::xsd::cxx::tree::traits< matrix_form_type, char > matrix_form_traits;

  const matrix_form_sequence&
  matrix_form () const;

  matrix_form_sequence&
  matrix_form ();

  void
  matrix_form (const matrix_form_sequence& s);

  // vector_form
  // 
  typedef ::vector_form vector_form_type;
  typedef ::xsd::cxx::tree::sequence< vector_form_type > vector_form_sequence;
  typedef vector_form_sequence::iterator vector_form_iterator;
  typedef vector_form_sequence::const_iterator vector_form_const_iterator;
  typedef ::xsd::cxx::tree::traits< vector_form_type, char > vector_form_traits;

  const vector_form_sequence&
  vector_form () const;

  vector_form_sequence&
  vector_form ();

  void
  vector_form (const vector_form_sequence& s);

  // analysistype
  // 
  typedef ::xml_schema::ncname analysistype_type;
  typedef ::xsd::cxx::tree::traits< analysistype_type, char > analysistype_traits;

  const analysistype_type&
  analysistype () const;

  analysistype_type&
  analysistype ();

  void
  analysistype (const analysistype_type& x);

  void
  analysistype (::std::auto_ptr< analysistype_type > p);

  // default
  // 
  typedef ::xml_schema::ncname default_type;
  typedef ::xsd::cxx::tree::optional< default_type > default_optional;
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  const default_optional&
  default_ () const;

  default_optional&
  default_ ();

  void
  default_ (const default_type& x);

  void
  default_ (const default_optional& x);

  void
  default_ (::std::auto_ptr< default_type > p);

  // Constructors.
  //
  weakform (const analysistype_type&);

  weakform (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  weakform (const weakform& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual weakform*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~weakform ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  boundary_sequence boundary_;
  quantity_sequence quantity_;
  matrix_form_sequence matrix_form_;
  vector_form_sequence vector_form_;
  ::xsd::cxx::tree::one< analysistype_type > analysistype_;
  default_optional default__;
};

class boundary: public ::xml_schema::type
{
  public:
  // quantity
  // 
  typedef ::quantity quantity_type;
  typedef ::xsd::cxx::tree::sequence< quantity_type > quantity_sequence;
  typedef quantity_sequence::iterator quantity_iterator;
  typedef quantity_sequence::const_iterator quantity_const_iterator;
  typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

  const quantity_sequence&
  quantity () const;

  quantity_sequence&
  quantity ();

  void
  quantity (const quantity_sequence& s);

  // matrix_form
  // 
  typedef ::matrix_form matrix_form_type;
  typedef ::xsd::cxx::tree::sequence< matrix_form_type > matrix_form_sequence;
  typedef matrix_form_sequence::iterator matrix_form_iterator;
  typedef matrix_form_sequence::const_iterator matrix_form_const_iterator;
  typedef ::xsd::cxx::tree::traits< matrix_form_type, char > matrix_form_traits;

  const matrix_form_sequence&
  matrix_form () const;

  matrix_form_sequence&
  matrix_form ();

  void
  matrix_form (const matrix_form_sequence& s);

  // vector_form
  // 
  typedef ::vector_form vector_form_type;
  typedef ::xsd::cxx::tree::sequence< vector_form_type > vector_form_sequence;
  typedef vector_form_sequence::iterator vector_form_iterator;
  typedef vector_form_sequence::const_iterator vector_form_const_iterator;
  typedef ::xsd::cxx::tree::traits< vector_form_type, char > vector_form_traits;

  const vector_form_sequence&
  vector_form () const;

  vector_form_sequence&
  vector_form ();

  void
  vector_form (const vector_form_sequence& s);

  // essential_form
  // 
  typedef ::essential_form essential_form_type;
  typedef ::xsd::cxx::tree::sequence< essential_form_type > essential_form_sequence;
  typedef essential_form_sequence::iterator essential_form_iterator;
  typedef essential_form_sequence::const_iterator essential_form_const_iterator;
  typedef ::xsd::cxx::tree::traits< essential_form_type, char > essential_form_traits;

  const essential_form_sequence&
  essential_form () const;

  essential_form_sequence&
  essential_form ();

  void
  essential_form (const essential_form_sequence& s);

  // id
  // 
  typedef ::xml_schema::ncname id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  boundary (const id_type&,
            const name_type&);

  boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  boundary (const boundary& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual boundary*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~boundary ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  quantity_sequence quantity_;
  matrix_form_sequence matrix_form_;
  vector_form_sequence vector_form_;
  essential_form_sequence essential_form_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class essential_form: public ::xml_schema::type
{
  public:
  // axi
  // 
  typedef ::xml_schema::ncname axi_type;
  typedef ::xsd::cxx::tree::traits< axi_type, char > axi_traits;

  const axi_type&
  axi () const;

  axi_type&
  axi ();

  void
  axi (const axi_type& x);

  void
  axi (::std::auto_ptr< axi_type > p);

  // i
  // 
  typedef ::xml_schema::integer i_type;
  typedef ::xsd::cxx::tree::traits< i_type, char > i_traits;

  const i_type&
  i () const;

  i_type&
  i ();

  void
  i (const i_type& x);

  // planar
  // 
  typedef ::xml_schema::ncname planar_type;
  typedef ::xsd::cxx::tree::traits< planar_type, char > planar_traits;

  const planar_type&
  planar () const;

  planar_type&
  planar ();

  void
  planar (const planar_type& x);

  void
  planar (::std::auto_ptr< planar_type > p);

  // Constructors.
  //
  essential_form (const axi_type&,
                  const i_type&,
                  const planar_type&);

  essential_form (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  essential_form (const essential_form& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual essential_form*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~essential_form ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< axi_type > axi_;
  ::xsd::cxx::tree::one< i_type > i_;
  ::xsd::cxx::tree::one< planar_type > planar_;
};

class group: public ::xml_schema::type
{
  public:
  // quantity
  // 
  typedef ::quantity quantity_type;
  typedef ::xsd::cxx::tree::sequence< quantity_type > quantity_sequence;
  typedef quantity_sequence::iterator quantity_iterator;
  typedef quantity_sequence::const_iterator quantity_const_iterator;
  typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

  const quantity_sequence&
  quantity () const;

  quantity_sequence&
  quantity ();

  void
  quantity (const quantity_sequence& s);

  // name
  // 
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  group ();

  group (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  group (const group& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual group*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~group ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  quantity_sequence quantity_;
  name_optional name_;
};

class matrix_form: public ::xml_schema::type
{
  public:
  // axi
  // 
  typedef ::xml_schema::simple_type axi_type;
  typedef ::xsd::cxx::tree::traits< axi_type, char > axi_traits;

  const axi_type&
  axi () const;

  axi_type&
  axi ();

  void
  axi (const axi_type& x);

  void
  axi (::std::auto_ptr< axi_type > p);

  // i
  // 
  typedef ::xml_schema::integer i_type;
  typedef ::xsd::cxx::tree::traits< i_type, char > i_traits;

  const i_type&
  i () const;

  i_type&
  i ();

  void
  i (const i_type& x);

  // j
  // 
  typedef ::xml_schema::integer j_type;
  typedef ::xsd::cxx::tree::traits< j_type, char > j_traits;

  const j_type&
  j () const;

  j_type&
  j ();

  void
  j (const j_type& x);

  // planar
  // 
  typedef ::xml_schema::simple_type planar_type;
  typedef ::xsd::cxx::tree::traits< planar_type, char > planar_traits;

  const planar_type&
  planar () const;

  planar_type&
  planar ();

  void
  planar (const planar_type& x);

  void
  planar (::std::auto_ptr< planar_type > p);

  // symmetric
  // 
  typedef ::xml_schema::integer symmetric_type;
  typedef ::xsd::cxx::tree::optional< symmetric_type > symmetric_optional;
  typedef ::xsd::cxx::tree::traits< symmetric_type, char > symmetric_traits;

  const symmetric_optional&
  symmetric () const;

  symmetric_optional&
  symmetric ();

  void
  symmetric (const symmetric_type& x);

  void
  symmetric (const symmetric_optional& x);

  // Constructors.
  //
  matrix_form (const axi_type&,
               const i_type&,
               const j_type&,
               const planar_type&);

  matrix_form (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  matrix_form (const matrix_form& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual matrix_form*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~matrix_form ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< axi_type > axi_;
  ::xsd::cxx::tree::one< i_type > i_;
  ::xsd::cxx::tree::one< j_type > j_;
  ::xsd::cxx::tree::one< planar_type > planar_;
  symmetric_optional symmetric_;
};

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const module&);

::std::ostream&
operator<< (::std::ostream&, const general&);

::std::ostream&
operator<< (::std::ostream&, const analyses&);

::std::ostream&
operator<< (::std::ostream&, const analysis&);

::std::ostream&
operator<< (::std::ostream&, const constants&);

::std::ostream&
operator<< (::std::ostream&, const constant&);

::std::ostream&
operator<< (::std::ostream&, const macros&);

::std::ostream&
operator<< (::std::ostream&, const macro&);

::std::ostream&
operator<< (::std::ostream&, const preprocessor&);

::std::ostream&
operator<< (::std::ostream&, const postprocessor&);

::std::ostream&
operator<< (::std::ostream&, const localvariables&);

::std::ostream&
operator<< (::std::ostream&, const localvariable&);

::std::ostream&
operator<< (::std::ostream&, const view&);

::std::ostream&
operator<< (::std::ostream&, const scalar_view&);

::std::ostream&
operator<< (::std::ostream&, const vector_view&);

::std::ostream&
operator<< (::std::ostream&, const volumeintegrals&);

::std::ostream&
operator<< (::std::ostream&, const volumeintegral&);

::std::ostream&
operator<< (::std::ostream&, const surfaceintegrals&);

::std::ostream&
operator<< (::std::ostream&, const surfaceintegral&);

::std::ostream&
operator<< (::std::ostream&, const volume&);

::std::ostream&
operator<< (::std::ostream&, const surface&);

::std::ostream&
operator<< (::std::ostream&, const expression&);

::std::ostream&
operator<< (::std::ostream&, const default_&);

::std::ostream&
operator<< (::std::ostream&, const vector_form&);

::std::ostream&
operator<< (::std::ostream&, const quantity&);

::std::ostream&
operator<< (::std::ostream&, const weakforms&);

::std::ostream&
operator<< (::std::ostream&, const weakform&);

::std::ostream&
operator<< (::std::ostream&, const boundary&);

::std::ostream&
operator<< (::std::ostream&, const essential_form&);

::std::ostream&
operator<< (::std::ostream&, const group&);

::std::ostream&
operator<< (::std::ostream&, const matrix_form&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::module >
module_ (const ::std::string& uri,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (const ::std::string& uri,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::module >
module_ (::std::istream& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::std::istream& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::module >
module_ (::xercesc::InputSource& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::xercesc::InputSource& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::module >
module_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::module >
module_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
module_ (::std::ostream& os,
         const ::module& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
module_ (::std::ostream& os,
         const ::module& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
module_ (::std::ostream& os,
         const ::module& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
module_ (::xercesc::XMLFormatTarget& ft,
         const ::module& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
module_ (::xercesc::XMLFormatTarget& ft,
         const ::module& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
module_ (::xercesc::XMLFormatTarget& ft,
         const ::module& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
module_ (::xercesc::DOMDocument& d,
         const ::module& x,
         ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
module_ (const ::module& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const module&);

void
operator<< (::xercesc::DOMElement&, const general&);

void
operator<< (::xercesc::DOMElement&, const analyses&);

void
operator<< (::xercesc::DOMElement&, const analysis&);

void
operator<< (::xercesc::DOMElement&, const constants&);

void
operator<< (::xercesc::DOMElement&, const constant&);

void
operator<< (::xercesc::DOMElement&, const macros&);

void
operator<< (::xercesc::DOMElement&, const macro&);

void
operator<< (::xercesc::DOMElement&, const preprocessor&);

void
operator<< (::xercesc::DOMElement&, const postprocessor&);

void
operator<< (::xercesc::DOMElement&, const localvariables&);

void
operator<< (::xercesc::DOMElement&, const localvariable&);

void
operator<< (::xercesc::DOMElement&, const view&);

void
operator<< (::xercesc::DOMElement&, const scalar_view&);

void
operator<< (::xercesc::DOMElement&, const vector_view&);

void
operator<< (::xercesc::DOMElement&, const volumeintegrals&);

void
operator<< (::xercesc::DOMElement&, const volumeintegral&);

void
operator<< (::xercesc::DOMElement&, const surfaceintegrals&);

void
operator<< (::xercesc::DOMElement&, const surfaceintegral&);

void
operator<< (::xercesc::DOMElement&, const volume&);

void
operator<< (::xercesc::DOMElement&, const surface&);

void
operator<< (::xercesc::DOMElement&, const expression&);

void
operator<< (::xercesc::DOMElement&, const default_&);

void
operator<< (::xercesc::DOMElement&, const vector_form&);

void
operator<< (::xercesc::DOMElement&, const quantity&);

void
operator<< (::xercesc::DOMElement&, const weakforms&);

void
operator<< (::xercesc::DOMElement&, const weakform&);

void
operator<< (::xercesc::DOMElement&, const boundary&);

void
operator<< (::xercesc::DOMElement&, const essential_form&);

void
operator<< (::xercesc::DOMElement&, const group&);

void
operator<< (::xercesc::DOMElement&, const matrix_form&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX______RESOURCES_XSD_MODULE_XML_H
