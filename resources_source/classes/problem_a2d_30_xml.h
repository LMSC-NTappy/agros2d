// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX______RESOURCES_XSD_PROBLEM_A2D_30_XML_H
#define CXX______RESOURCES_XSD_PROBLEM_A2D_30_XML_H

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace XMLProblem
{
  class document;
  class geometry;
  class problem;
  class config;
  class nodes;
  class edges;
  class labels;
  class fields;
  class couplings;
  class item;
  class node;
  class edge;
  class label;
  class field;
  class coupling;
  class refinement_edges;
  class refinement_labels;
  class polynomial_orders;
  class adaptivity;
  class solver;
  class boundaries;
  class materials;
  class refinement_edge;
  class refinement_label;
  class polynomial_order;
  class boundary;
  class material;
  class boundary_edges;
  class boundary_types;
  class material_labels;
  class material_types;
  class boundary_edge;
  class boundary_type;
  class material_label;
  class material_type;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace XMLProblem
{
  class document: public ::xml_schema::type
  {
    public:
    // geometry
    // 
    typedef ::XMLProblem::geometry geometry_type;
    typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

    const geometry_type&
    geometry () const;

    geometry_type&
    geometry ();

    void
    geometry (const geometry_type& x);

    void
    geometry (::std::auto_ptr< geometry_type > p);

    // problem
    // 
    typedef ::XMLProblem::problem problem_type;
    typedef ::xsd::cxx::tree::traits< problem_type, char > problem_traits;

    const problem_type&
    problem () const;

    problem_type&
    problem ();

    void
    problem (const problem_type& x);

    void
    problem (::std::auto_ptr< problem_type > p);

    // config
    // 
    typedef ::XMLProblem::config config_type;
    typedef ::xsd::cxx::tree::traits< config_type, char > config_traits;

    const config_type&
    config () const;

    config_type&
    config ();

    void
    config (const config_type& x);

    void
    config (::std::auto_ptr< config_type > p);

    // version
    // 
    typedef ::xml_schema::float_ version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    // Constructors.
    //
    document (const geometry_type&,
              const problem_type&,
              const config_type&);

    document (::std::auto_ptr< geometry_type >&,
              ::std::auto_ptr< problem_type >&,
              ::std::auto_ptr< config_type >&);

    document (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    document (const document& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual document*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~document ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< geometry_type > geometry_;
    ::xsd::cxx::tree::one< problem_type > problem_;
    ::xsd::cxx::tree::one< config_type > config_;
    version_optional version_;
  };

  class geometry: public ::xml_schema::type
  {
    public:
    // nodes
    // 
    typedef ::XMLProblem::nodes nodes_type;
    typedef ::xsd::cxx::tree::traits< nodes_type, char > nodes_traits;

    const nodes_type&
    nodes () const;

    nodes_type&
    nodes ();

    void
    nodes (const nodes_type& x);

    void
    nodes (::std::auto_ptr< nodes_type > p);

    // edges
    // 
    typedef ::XMLProblem::edges edges_type;
    typedef ::xsd::cxx::tree::traits< edges_type, char > edges_traits;

    const edges_type&
    edges () const;

    edges_type&
    edges ();

    void
    edges (const edges_type& x);

    void
    edges (::std::auto_ptr< edges_type > p);

    // labels
    // 
    typedef ::XMLProblem::labels labels_type;
    typedef ::xsd::cxx::tree::traits< labels_type, char > labels_traits;

    const labels_type&
    labels () const;

    labels_type&
    labels ();

    void
    labels (const labels_type& x);

    void
    labels (::std::auto_ptr< labels_type > p);

    // Constructors.
    //
    geometry (const nodes_type&,
              const edges_type&,
              const labels_type&);

    geometry (::std::auto_ptr< nodes_type >&,
              ::std::auto_ptr< edges_type >&,
              ::std::auto_ptr< labels_type >&);

    geometry (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    geometry (const geometry& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual geometry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~geometry ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< nodes_type > nodes_;
    ::xsd::cxx::tree::one< edges_type > edges_;
    ::xsd::cxx::tree::one< labels_type > labels_;
  };

  class problem: public ::xml_schema::type
  {
    public:
    // fields
    // 
    typedef ::XMLProblem::fields fields_type;
    typedef ::xsd::cxx::tree::traits< fields_type, char > fields_traits;

    const fields_type&
    fields () const;

    fields_type&
    fields ();

    void
    fields (const fields_type& x);

    void
    fields (::std::auto_ptr< fields_type > p);

    // couplings
    // 
    typedef ::XMLProblem::couplings couplings_type;
    typedef ::xsd::cxx::tree::traits< couplings_type, char > couplings_traits;

    const couplings_type&
    couplings () const;

    couplings_type&
    couplings ();

    void
    couplings (const couplings_type& x);

    void
    couplings (::std::auto_ptr< couplings_type > p);

    // coordinate_type
    // 
    typedef ::xml_schema::string coordinate_type_type;
    typedef ::xsd::cxx::tree::traits< coordinate_type_type, char > coordinate_type_traits;

    const coordinate_type_type&
    coordinate_type () const;

    coordinate_type_type&
    coordinate_type ();

    void
    coordinate_type (const coordinate_type_type& x);

    void
    coordinate_type (::std::auto_ptr< coordinate_type_type > p);

    // mesh_type
    // 
    typedef ::xml_schema::string mesh_type_type;
    typedef ::xsd::cxx::tree::traits< mesh_type_type, char > mesh_type_traits;

    const mesh_type_type&
    mesh_type () const;

    mesh_type_type&
    mesh_type ();

    void
    mesh_type (const mesh_type_type& x);

    void
    mesh_type (::std::auto_ptr< mesh_type_type > p);

    // matrix_solver
    // 
    typedef ::xml_schema::string matrix_solver_type;
    typedef ::xsd::cxx::tree::traits< matrix_solver_type, char > matrix_solver_traits;

    const matrix_solver_type&
    matrix_solver () const;

    matrix_solver_type&
    matrix_solver ();

    void
    matrix_solver (const matrix_solver_type& x);

    void
    matrix_solver (::std::auto_ptr< matrix_solver_type > p);

    // frequency
    // 
    typedef ::xml_schema::float_ frequency_type;
    typedef ::xsd::cxx::tree::traits< frequency_type, char > frequency_traits;

    const frequency_type&
    frequency () const;

    frequency_type&
    frequency ();

    void
    frequency (const frequency_type& x);

    // time_method
    // 
    typedef ::xml_schema::string time_method_type;
    typedef ::xsd::cxx::tree::traits< time_method_type, char > time_method_traits;

    const time_method_type&
    time_method () const;

    time_method_type&
    time_method ();

    void
    time_method (const time_method_type& x);

    void
    time_method (::std::auto_ptr< time_method_type > p);

    // time_total
    // 
    typedef ::xml_schema::float_ time_total_type;
    typedef ::xsd::cxx::tree::traits< time_total_type, char > time_total_traits;

    const time_total_type&
    time_total () const;

    time_total_type&
    time_total ();

    void
    time_total (const time_total_type& x);

    // time_steps
    // 
    typedef ::xml_schema::int_ time_steps_type;
    typedef ::xsd::cxx::tree::traits< time_steps_type, char > time_steps_traits;

    const time_steps_type&
    time_steps () const;

    time_steps_type&
    time_steps ();

    void
    time_steps (const time_steps_type& x);

    // time_order
    // 
    typedef ::xml_schema::int_ time_order_type;
    typedef ::xsd::cxx::tree::traits< time_order_type, char > time_order_traits;

    const time_order_type&
    time_order () const;

    time_order_type&
    time_order ();

    void
    time_order (const time_order_type& x);

    // time_method_tolerance
    // 
    typedef ::xml_schema::float_ time_method_tolerance_type;
    typedef ::xsd::cxx::tree::traits< time_method_tolerance_type, char > time_method_tolerance_traits;

    const time_method_tolerance_type&
    time_method_tolerance () const;

    time_method_tolerance_type&
    time_method_tolerance ();

    void
    time_method_tolerance (const time_method_tolerance_type& x);

    // Constructors.
    //
    problem (const fields_type&,
             const couplings_type&,
             const coordinate_type_type&,
             const mesh_type_type&,
             const matrix_solver_type&,
             const frequency_type&,
             const time_method_type&,
             const time_total_type&,
             const time_steps_type&,
             const time_order_type&,
             const time_method_tolerance_type&);

    problem (::std::auto_ptr< fields_type >&,
             ::std::auto_ptr< couplings_type >&,
             const coordinate_type_type&,
             const mesh_type_type&,
             const matrix_solver_type&,
             const frequency_type&,
             const time_method_type&,
             const time_total_type&,
             const time_steps_type&,
             const time_order_type&,
             const time_method_tolerance_type&);

    problem (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    problem (const problem& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual problem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~problem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< fields_type > fields_;
    ::xsd::cxx::tree::one< couplings_type > couplings_;
    ::xsd::cxx::tree::one< coordinate_type_type > coordinate_type_;
    ::xsd::cxx::tree::one< mesh_type_type > mesh_type_;
    ::xsd::cxx::tree::one< matrix_solver_type > matrix_solver_;
    ::xsd::cxx::tree::one< frequency_type > frequency_;
    ::xsd::cxx::tree::one< time_method_type > time_method_;
    ::xsd::cxx::tree::one< time_total_type > time_total_;
    ::xsd::cxx::tree::one< time_steps_type > time_steps_;
    ::xsd::cxx::tree::one< time_order_type > time_order_;
    ::xsd::cxx::tree::one< time_method_tolerance_type > time_method_tolerance_;
  };

  class config: public ::xml_schema::type
  {
    public:
    // item
    // 
    typedef ::XMLProblem::item item_type;
    typedef ::xsd::cxx::tree::sequence< item_type > item_sequence;
    typedef item_sequence::iterator item_iterator;
    typedef item_sequence::const_iterator item_const_iterator;
    typedef ::xsd::cxx::tree::traits< item_type, char > item_traits;

    const item_sequence&
    item () const;

    item_sequence&
    item ();

    void
    item (const item_sequence& s);

    // Constructors.
    //
    config ();

    config (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    config (const config& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual config*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~config ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    item_sequence item_;
  };

  class nodes: public ::xml_schema::type
  {
    public:
    // node
    // 
    typedef ::XMLProblem::node node_type;
    typedef ::xsd::cxx::tree::sequence< node_type > node_sequence;
    typedef node_sequence::iterator node_iterator;
    typedef node_sequence::const_iterator node_const_iterator;
    typedef ::xsd::cxx::tree::traits< node_type, char > node_traits;

    const node_sequence&
    node () const;

    node_sequence&
    node ();

    void
    node (const node_sequence& s);

    // Constructors.
    //
    nodes ();

    nodes (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    nodes (const nodes& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual nodes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~nodes ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    node_sequence node_;
  };

  class edges: public ::xml_schema::type
  {
    public:
    // edge
    // 
    typedef ::XMLProblem::edge edge_type;
    typedef ::xsd::cxx::tree::sequence< edge_type > edge_sequence;
    typedef edge_sequence::iterator edge_iterator;
    typedef edge_sequence::const_iterator edge_const_iterator;
    typedef ::xsd::cxx::tree::traits< edge_type, char > edge_traits;

    const edge_sequence&
    edge () const;

    edge_sequence&
    edge ();

    void
    edge (const edge_sequence& s);

    // Constructors.
    //
    edges ();

    edges (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    edges (const edges& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual edges*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~edges ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    edge_sequence edge_;
  };

  class labels: public ::xml_schema::type
  {
    public:
    // label
    // 
    typedef ::XMLProblem::label label_type;
    typedef ::xsd::cxx::tree::sequence< label_type > label_sequence;
    typedef label_sequence::iterator label_iterator;
    typedef label_sequence::const_iterator label_const_iterator;
    typedef ::xsd::cxx::tree::traits< label_type, char > label_traits;

    const label_sequence&
    label () const;

    label_sequence&
    label ();

    void
    label (const label_sequence& s);

    // Constructors.
    //
    labels ();

    labels (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    labels (const labels& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual labels*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~labels ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    label_sequence label_;
  };

  class fields: public ::xml_schema::type
  {
    public:
    // field
    // 
    typedef ::XMLProblem::field field_type;
    typedef ::xsd::cxx::tree::sequence< field_type > field_sequence;
    typedef field_sequence::iterator field_iterator;
    typedef field_sequence::const_iterator field_const_iterator;
    typedef ::xsd::cxx::tree::traits< field_type, char > field_traits;

    const field_sequence&
    field () const;

    field_sequence&
    field ();

    void
    field (const field_sequence& s);

    // Constructors.
    //
    fields ();

    fields (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    fields (const fields& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual fields*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~fields ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    field_sequence field_;
  };

  class couplings: public ::xml_schema::type
  {
    public:
    // coupling
    // 
    typedef ::XMLProblem::coupling coupling_type;
    typedef ::xsd::cxx::tree::sequence< coupling_type > coupling_sequence;
    typedef coupling_sequence::iterator coupling_iterator;
    typedef coupling_sequence::const_iterator coupling_const_iterator;
    typedef ::xsd::cxx::tree::traits< coupling_type, char > coupling_traits;

    const coupling_sequence&
    coupling () const;

    coupling_sequence&
    coupling ();

    void
    coupling (const coupling_sequence& s);

    // Constructors.
    //
    couplings ();

    couplings (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    couplings (const couplings& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual couplings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~couplings ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    coupling_sequence coupling_;
  };

  class item: public ::xml_schema::type
  {
    public:
    // key
    // 
    typedef ::xml_schema::string key_type;
    typedef ::xsd::cxx::tree::traits< key_type, char > key_traits;

    const key_type&
    key () const;

    key_type&
    key ();

    void
    key (const key_type& x);

    void
    key (::std::auto_ptr< key_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::auto_ptr< value_type > p);

    // Constructors.
    //
    item (const key_type&,
          const value_type&);

    item (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    item (const item& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual item*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~item ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< key_type > key_;
    ::xsd::cxx::tree::one< value_type > value_;
  };

  class node: public ::xml_schema::type
  {
    public:
    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // x
    // 
    typedef ::xml_schema::float_ x_type;
    typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

    const x_type&
    x () const;

    x_type&
    x ();

    void
    x (const x_type& x);

    // y
    // 
    typedef ::xml_schema::float_ y_type;
    typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

    const y_type&
    y () const;

    y_type&
    y ();

    void
    y (const y_type& x);

    // Constructors.
    //
    node (const id_type&,
          const x_type&,
          const y_type&);

    node (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    node (const node& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual node*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~node ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< x_type > x_;
    ::xsd::cxx::tree::one< y_type > y_;
  };

  class edge: public ::xml_schema::type
  {
    public:
    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // start
    // 
    typedef ::xml_schema::int_ start_type;
    typedef ::xsd::cxx::tree::traits< start_type, char > start_traits;

    const start_type&
    start () const;

    start_type&
    start ();

    void
    start (const start_type& x);

    // end
    // 
    typedef ::xml_schema::int_ end_type;
    typedef ::xsd::cxx::tree::traits< end_type, char > end_traits;

    const end_type&
    end () const;

    end_type&
    end ();

    void
    end (const end_type& x);

    // angle
    // 
    typedef ::xml_schema::float_ angle_type;
    typedef ::xsd::cxx::tree::traits< angle_type, char > angle_traits;

    const angle_type&
    angle () const;

    angle_type&
    angle ();

    void
    angle (const angle_type& x);

    // Constructors.
    //
    edge (const id_type&,
          const start_type&,
          const end_type&,
          const angle_type&);

    edge (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    edge (const edge& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual edge*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~edge ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< start_type > start_;
    ::xsd::cxx::tree::one< end_type > end_;
    ::xsd::cxx::tree::one< angle_type > angle_;
  };

  class label: public ::xml_schema::type
  {
    public:
    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // x
    // 
    typedef ::xml_schema::float_ x_type;
    typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

    const x_type&
    x () const;

    x_type&
    x ();

    void
    x (const x_type& x);

    // y
    // 
    typedef ::xml_schema::float_ y_type;
    typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

    const y_type&
    y () const;

    y_type&
    y ();

    void
    y (const y_type& x);

    // area
    // 
    typedef ::xml_schema::float_ area_type;
    typedef ::xsd::cxx::tree::traits< area_type, char > area_traits;

    const area_type&
    area () const;

    area_type&
    area ();

    void
    area (const area_type& x);

    // Constructors.
    //
    label (const id_type&,
           const x_type&,
           const y_type&,
           const area_type&);

    label (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    label (const label& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual label*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~label ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< x_type > x_;
    ::xsd::cxx::tree::one< y_type > y_;
    ::xsd::cxx::tree::one< area_type > area_;
  };

  class field: public ::xml_schema::type
  {
    public:
    // refinement_edges
    // 
    typedef ::XMLProblem::refinement_edges refinement_edges_type;
    typedef ::xsd::cxx::tree::traits< refinement_edges_type, char > refinement_edges_traits;

    const refinement_edges_type&
    refinement_edges () const;

    refinement_edges_type&
    refinement_edges ();

    void
    refinement_edges (const refinement_edges_type& x);

    void
    refinement_edges (::std::auto_ptr< refinement_edges_type > p);

    // refinement_labels
    // 
    typedef ::XMLProblem::refinement_labels refinement_labels_type;
    typedef ::xsd::cxx::tree::traits< refinement_labels_type, char > refinement_labels_traits;

    const refinement_labels_type&
    refinement_labels () const;

    refinement_labels_type&
    refinement_labels ();

    void
    refinement_labels (const refinement_labels_type& x);

    void
    refinement_labels (::std::auto_ptr< refinement_labels_type > p);

    // polynomial_orders
    // 
    typedef ::XMLProblem::polynomial_orders polynomial_orders_type;
    typedef ::xsd::cxx::tree::traits< polynomial_orders_type, char > polynomial_orders_traits;

    const polynomial_orders_type&
    polynomial_orders () const;

    polynomial_orders_type&
    polynomial_orders ();

    void
    polynomial_orders (const polynomial_orders_type& x);

    void
    polynomial_orders (::std::auto_ptr< polynomial_orders_type > p);

    // adaptivity
    // 
    typedef ::XMLProblem::adaptivity adaptivity_type;
    typedef ::xsd::cxx::tree::traits< adaptivity_type, char > adaptivity_traits;

    const adaptivity_type&
    adaptivity () const;

    adaptivity_type&
    adaptivity ();

    void
    adaptivity (const adaptivity_type& x);

    void
    adaptivity (::std::auto_ptr< adaptivity_type > p);

    // solver
    // 
    typedef ::XMLProblem::solver solver_type;
    typedef ::xsd::cxx::tree::traits< solver_type, char > solver_traits;

    const solver_type&
    solver () const;

    solver_type&
    solver ();

    void
    solver (const solver_type& x);

    void
    solver (::std::auto_ptr< solver_type > p);

    // boundaries
    // 
    typedef ::XMLProblem::boundaries boundaries_type;
    typedef ::xsd::cxx::tree::traits< boundaries_type, char > boundaries_traits;

    const boundaries_type&
    boundaries () const;

    boundaries_type&
    boundaries ();

    void
    boundaries (const boundaries_type& x);

    void
    boundaries (::std::auto_ptr< boundaries_type > p);

    // materials
    // 
    typedef ::XMLProblem::materials materials_type;
    typedef ::xsd::cxx::tree::traits< materials_type, char > materials_traits;

    const materials_type&
    materials () const;

    materials_type&
    materials ();

    void
    materials (const materials_type& x);

    void
    materials (::std::auto_ptr< materials_type > p);

    // field_id
    // 
    typedef ::xml_schema::string field_id_type;
    typedef ::xsd::cxx::tree::traits< field_id_type, char > field_id_traits;

    const field_id_type&
    field_id () const;

    field_id_type&
    field_id ();

    void
    field_id (const field_id_type& x);

    void
    field_id (::std::auto_ptr< field_id_type > p);

    // analysis_type
    // 
    typedef ::xml_schema::string analysis_type_type;
    typedef ::xsd::cxx::tree::traits< analysis_type_type, char > analysis_type_traits;

    const analysis_type_type&
    analysis_type () const;

    analysis_type_type&
    analysis_type ();

    void
    analysis_type (const analysis_type_type& x);

    void
    analysis_type (::std::auto_ptr< analysis_type_type > p);

    // number_of_refinements
    // 
    typedef ::xml_schema::int_ number_of_refinements_type;
    typedef ::xsd::cxx::tree::traits< number_of_refinements_type, char > number_of_refinements_traits;

    const number_of_refinements_type&
    number_of_refinements () const;

    number_of_refinements_type&
    number_of_refinements ();

    void
    number_of_refinements (const number_of_refinements_type& x);

    // polynomial_order
    // 
    typedef ::xml_schema::int_ polynomial_order_type;
    typedef ::xsd::cxx::tree::traits< polynomial_order_type, char > polynomial_order_traits;

    const polynomial_order_type&
    polynomial_order () const;

    polynomial_order_type&
    polynomial_order ();

    void
    polynomial_order (const polynomial_order_type& x);

    // initial_condition
    // 
    typedef ::xml_schema::float_ initial_condition_type;
    typedef ::xsd::cxx::tree::traits< initial_condition_type, char > initial_condition_traits;

    const initial_condition_type&
    initial_condition () const;

    initial_condition_type&
    initial_condition ();

    void
    initial_condition (const initial_condition_type& x);

    // time_skip
    // 
    typedef ::xml_schema::int_ time_skip_type;
    typedef ::xsd::cxx::tree::traits< time_skip_type, char > time_skip_traits;

    const time_skip_type&
    time_skip () const;

    time_skip_type&
    time_skip ();

    void
    time_skip (const time_skip_type& x);

    // Constructors.
    //
    field (const refinement_edges_type&,
           const refinement_labels_type&,
           const polynomial_orders_type&,
           const adaptivity_type&,
           const solver_type&,
           const boundaries_type&,
           const materials_type&,
           const field_id_type&,
           const analysis_type_type&,
           const number_of_refinements_type&,
           const polynomial_order_type&,
           const initial_condition_type&,
           const time_skip_type&);

    field (::std::auto_ptr< refinement_edges_type >&,
           ::std::auto_ptr< refinement_labels_type >&,
           ::std::auto_ptr< polynomial_orders_type >&,
           ::std::auto_ptr< adaptivity_type >&,
           ::std::auto_ptr< solver_type >&,
           ::std::auto_ptr< boundaries_type >&,
           ::std::auto_ptr< materials_type >&,
           const field_id_type&,
           const analysis_type_type&,
           const number_of_refinements_type&,
           const polynomial_order_type&,
           const initial_condition_type&,
           const time_skip_type&);

    field (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    field (const field& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual field*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~field ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< refinement_edges_type > refinement_edges_;
    ::xsd::cxx::tree::one< refinement_labels_type > refinement_labels_;
    ::xsd::cxx::tree::one< polynomial_orders_type > polynomial_orders_;
    ::xsd::cxx::tree::one< adaptivity_type > adaptivity_;
    ::xsd::cxx::tree::one< solver_type > solver_;
    ::xsd::cxx::tree::one< boundaries_type > boundaries_;
    ::xsd::cxx::tree::one< materials_type > materials_;
    ::xsd::cxx::tree::one< field_id_type > field_id_;
    ::xsd::cxx::tree::one< analysis_type_type > analysis_type_;
    ::xsd::cxx::tree::one< number_of_refinements_type > number_of_refinements_;
    ::xsd::cxx::tree::one< polynomial_order_type > polynomial_order_;
    ::xsd::cxx::tree::one< initial_condition_type > initial_condition_;
    ::xsd::cxx::tree::one< time_skip_type > time_skip_;
  };

  class coupling: public ::xml_schema::type
  {
    public:
    // id
    // 
    typedef ::xml_schema::string id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    void
    id (::std::auto_ptr< id_type > p);

    // type
    // 
    typedef ::xml_schema::string type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::auto_ptr< type_type > p);

    // source_fieldid
    // 
    typedef ::xml_schema::string source_fieldid_type;
    typedef ::xsd::cxx::tree::traits< source_fieldid_type, char > source_fieldid_traits;

    const source_fieldid_type&
    source_fieldid () const;

    source_fieldid_type&
    source_fieldid ();

    void
    source_fieldid (const source_fieldid_type& x);

    void
    source_fieldid (::std::auto_ptr< source_fieldid_type > p);

    // target_fieldid
    // 
    typedef ::xml_schema::string target_fieldid_type;
    typedef ::xsd::cxx::tree::traits< target_fieldid_type, char > target_fieldid_traits;

    const target_fieldid_type&
    target_fieldid () const;

    target_fieldid_type&
    target_fieldid ();

    void
    target_fieldid (const target_fieldid_type& x);

    void
    target_fieldid (::std::auto_ptr< target_fieldid_type > p);

    // Constructors.
    //
    coupling (const id_type&,
              const type_type&,
              const source_fieldid_type&,
              const target_fieldid_type&);

    coupling (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    coupling (const coupling& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual coupling*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coupling ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< type_type > type_;
    ::xsd::cxx::tree::one< source_fieldid_type > source_fieldid_;
    ::xsd::cxx::tree::one< target_fieldid_type > target_fieldid_;
  };

  class refinement_edges: public ::xml_schema::type
  {
    public:
    // refinement_edge
    // 
    typedef ::XMLProblem::refinement_edge refinement_edge_type;
    typedef ::xsd::cxx::tree::sequence< refinement_edge_type > refinement_edge_sequence;
    typedef refinement_edge_sequence::iterator refinement_edge_iterator;
    typedef refinement_edge_sequence::const_iterator refinement_edge_const_iterator;
    typedef ::xsd::cxx::tree::traits< refinement_edge_type, char > refinement_edge_traits;

    const refinement_edge_sequence&
    refinement_edge () const;

    refinement_edge_sequence&
    refinement_edge ();

    void
    refinement_edge (const refinement_edge_sequence& s);

    // Constructors.
    //
    refinement_edges ();

    refinement_edges (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    refinement_edges (const refinement_edges& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual refinement_edges*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~refinement_edges ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    refinement_edge_sequence refinement_edge_;
  };

  class refinement_labels: public ::xml_schema::type
  {
    public:
    // refinement_label
    // 
    typedef ::XMLProblem::refinement_label refinement_label_type;
    typedef ::xsd::cxx::tree::sequence< refinement_label_type > refinement_label_sequence;
    typedef refinement_label_sequence::iterator refinement_label_iterator;
    typedef refinement_label_sequence::const_iterator refinement_label_const_iterator;
    typedef ::xsd::cxx::tree::traits< refinement_label_type, char > refinement_label_traits;

    const refinement_label_sequence&
    refinement_label () const;

    refinement_label_sequence&
    refinement_label ();

    void
    refinement_label (const refinement_label_sequence& s);

    // Constructors.
    //
    refinement_labels ();

    refinement_labels (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    refinement_labels (const refinement_labels& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual refinement_labels*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~refinement_labels ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    refinement_label_sequence refinement_label_;
  };

  class polynomial_orders: public ::xml_schema::type
  {
    public:
    // polynomial_order
    // 
    typedef ::XMLProblem::polynomial_order polynomial_order_type;
    typedef ::xsd::cxx::tree::sequence< polynomial_order_type > polynomial_order_sequence;
    typedef polynomial_order_sequence::iterator polynomial_order_iterator;
    typedef polynomial_order_sequence::const_iterator polynomial_order_const_iterator;
    typedef ::xsd::cxx::tree::traits< polynomial_order_type, char > polynomial_order_traits;

    const polynomial_order_sequence&
    polynomial_order () const;

    polynomial_order_sequence&
    polynomial_order ();

    void
    polynomial_order (const polynomial_order_sequence& s);

    // Constructors.
    //
    polynomial_orders ();

    polynomial_orders (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    polynomial_orders (const polynomial_orders& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual polynomial_orders*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~polynomial_orders ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    polynomial_order_sequence polynomial_order_;
  };

  class adaptivity: public ::xml_schema::type
  {
    public:
    // adaptivity_type
    // 
    typedef ::xml_schema::string adaptivity_type_type;
    typedef ::xsd::cxx::tree::traits< adaptivity_type_type, char > adaptivity_type_traits;

    const adaptivity_type_type&
    adaptivity_type () const;

    adaptivity_type_type&
    adaptivity_type ();

    void
    adaptivity_type (const adaptivity_type_type& x);

    void
    adaptivity_type (::std::auto_ptr< adaptivity_type_type > p);

    // adaptivity_steps
    // 
    typedef ::xml_schema::int_ adaptivity_steps_type;
    typedef ::xsd::cxx::tree::traits< adaptivity_steps_type, char > adaptivity_steps_traits;

    const adaptivity_steps_type&
    adaptivity_steps () const;

    adaptivity_steps_type&
    adaptivity_steps ();

    void
    adaptivity_steps (const adaptivity_steps_type& x);

    // adaptivity_tolerance
    // 
    typedef ::xml_schema::float_ adaptivity_tolerance_type;
    typedef ::xsd::cxx::tree::traits< adaptivity_tolerance_type, char > adaptivity_tolerance_traits;

    const adaptivity_tolerance_type&
    adaptivity_tolerance () const;

    adaptivity_tolerance_type&
    adaptivity_tolerance ();

    void
    adaptivity_tolerance (const adaptivity_tolerance_type& x);

    // adaptivity_back_steps
    // 
    typedef ::xml_schema::int_ adaptivity_back_steps_type;
    typedef ::xsd::cxx::tree::traits< adaptivity_back_steps_type, char > adaptivity_back_steps_traits;

    const adaptivity_back_steps_type&
    adaptivity_back_steps () const;

    adaptivity_back_steps_type&
    adaptivity_back_steps ();

    void
    adaptivity_back_steps (const adaptivity_back_steps_type& x);

    // adaptivity_redone_each
    // 
    typedef ::xml_schema::int_ adaptivity_redone_each_type;
    typedef ::xsd::cxx::tree::traits< adaptivity_redone_each_type, char > adaptivity_redone_each_traits;

    const adaptivity_redone_each_type&
    adaptivity_redone_each () const;

    adaptivity_redone_each_type&
    adaptivity_redone_each ();

    void
    adaptivity_redone_each (const adaptivity_redone_each_type& x);

    // Constructors.
    //
    adaptivity (const adaptivity_type_type&,
                const adaptivity_steps_type&,
                const adaptivity_tolerance_type&,
                const adaptivity_back_steps_type&,
                const adaptivity_redone_each_type&);

    adaptivity (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    adaptivity (const adaptivity& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual adaptivity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~adaptivity ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< adaptivity_type_type > adaptivity_type_;
    ::xsd::cxx::tree::one< adaptivity_steps_type > adaptivity_steps_;
    ::xsd::cxx::tree::one< adaptivity_tolerance_type > adaptivity_tolerance_;
    ::xsd::cxx::tree::one< adaptivity_back_steps_type > adaptivity_back_steps_;
    ::xsd::cxx::tree::one< adaptivity_redone_each_type > adaptivity_redone_each_;
  };

  class solver: public ::xml_schema::type
  {
    public:
    // linearity_type
    // 
    typedef ::xml_schema::string linearity_type_type;
    typedef ::xsd::cxx::tree::traits< linearity_type_type, char > linearity_type_traits;

    const linearity_type_type&
    linearity_type () const;

    linearity_type_type&
    linearity_type ();

    void
    linearity_type (const linearity_type_type& x);

    void
    linearity_type (::std::auto_ptr< linearity_type_type > p);

    // nonlinear_steps
    // 
    typedef ::xml_schema::int_ nonlinear_steps_type;
    typedef ::xsd::cxx::tree::traits< nonlinear_steps_type, char > nonlinear_steps_traits;

    const nonlinear_steps_type&
    nonlinear_steps () const;

    nonlinear_steps_type&
    nonlinear_steps ();

    void
    nonlinear_steps (const nonlinear_steps_type& x);

    // nonlinear_tolerance
    // 
    typedef ::xml_schema::float_ nonlinear_tolerance_type;
    typedef ::xsd::cxx::tree::traits< nonlinear_tolerance_type, char > nonlinear_tolerance_traits;

    const nonlinear_tolerance_type&
    nonlinear_tolerance () const;

    nonlinear_tolerance_type&
    nonlinear_tolerance ();

    void
    nonlinear_tolerance (const nonlinear_tolerance_type& x);

    // newton_damping_coeff
    // 
    typedef ::xml_schema::float_ newton_damping_coeff_type;
    typedef ::xsd::cxx::tree::traits< newton_damping_coeff_type, char > newton_damping_coeff_traits;

    const newton_damping_coeff_type&
    newton_damping_coeff () const;

    newton_damping_coeff_type&
    newton_damping_coeff ();

    void
    newton_damping_coeff (const newton_damping_coeff_type& x);

    // newton_automatic_damping
    // 
    typedef ::xml_schema::int_ newton_automatic_damping_type;
    typedef ::xsd::cxx::tree::traits< newton_automatic_damping_type, char > newton_automatic_damping_traits;

    const newton_automatic_damping_type&
    newton_automatic_damping () const;

    newton_automatic_damping_type&
    newton_automatic_damping ();

    void
    newton_automatic_damping (const newton_automatic_damping_type& x);

    // newton_automatic_damping_coeff
    // 
    typedef ::xml_schema::float_ newton_automatic_damping_coeff_type;
    typedef ::xsd::cxx::tree::traits< newton_automatic_damping_coeff_type, char > newton_automatic_damping_coeff_traits;

    const newton_automatic_damping_coeff_type&
    newton_automatic_damping_coeff () const;

    newton_automatic_damping_coeff_type&
    newton_automatic_damping_coeff ();

    void
    newton_automatic_damping_coeff (const newton_automatic_damping_coeff_type& x);

    // newton_damping_number_to_increase
    // 
    typedef ::xml_schema::int_ newton_damping_number_to_increase_type;
    typedef ::xsd::cxx::tree::traits< newton_damping_number_to_increase_type, char > newton_damping_number_to_increase_traits;

    const newton_damping_number_to_increase_type&
    newton_damping_number_to_increase () const;

    newton_damping_number_to_increase_type&
    newton_damping_number_to_increase ();

    void
    newton_damping_number_to_increase (const newton_damping_number_to_increase_type& x);

    // picard_anderson_acceleration
    // 
    typedef ::xml_schema::int_ picard_anderson_acceleration_type;
    typedef ::xsd::cxx::tree::traits< picard_anderson_acceleration_type, char > picard_anderson_acceleration_traits;

    const picard_anderson_acceleration_type&
    picard_anderson_acceleration () const;

    picard_anderson_acceleration_type&
    picard_anderson_acceleration ();

    void
    picard_anderson_acceleration (const picard_anderson_acceleration_type& x);

    // picard_anderson_beta
    // 
    typedef ::xml_schema::float_ picard_anderson_beta_type;
    typedef ::xsd::cxx::tree::traits< picard_anderson_beta_type, char > picard_anderson_beta_traits;

    const picard_anderson_beta_type&
    picard_anderson_beta () const;

    picard_anderson_beta_type&
    picard_anderson_beta ();

    void
    picard_anderson_beta (const picard_anderson_beta_type& x);

    // picard_anderson_vectors
    // 
    typedef ::xml_schema::int_ picard_anderson_vectors_type;
    typedef ::xsd::cxx::tree::traits< picard_anderson_vectors_type, char > picard_anderson_vectors_traits;

    const picard_anderson_vectors_type&
    picard_anderson_vectors () const;

    picard_anderson_vectors_type&
    picard_anderson_vectors ();

    void
    picard_anderson_vectors (const picard_anderson_vectors_type& x);

    // Constructors.
    //
    solver (const linearity_type_type&,
            const nonlinear_steps_type&,
            const nonlinear_tolerance_type&,
            const newton_damping_coeff_type&,
            const newton_automatic_damping_type&,
            const newton_automatic_damping_coeff_type&,
            const newton_damping_number_to_increase_type&,
            const picard_anderson_acceleration_type&,
            const picard_anderson_beta_type&,
            const picard_anderson_vectors_type&);

    solver (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    solver (const solver& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual solver*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~solver ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< linearity_type_type > linearity_type_;
    ::xsd::cxx::tree::one< nonlinear_steps_type > nonlinear_steps_;
    ::xsd::cxx::tree::one< nonlinear_tolerance_type > nonlinear_tolerance_;
    ::xsd::cxx::tree::one< newton_damping_coeff_type > newton_damping_coeff_;
    ::xsd::cxx::tree::one< newton_automatic_damping_type > newton_automatic_damping_;
    ::xsd::cxx::tree::one< newton_automatic_damping_coeff_type > newton_automatic_damping_coeff_;
    ::xsd::cxx::tree::one< newton_damping_number_to_increase_type > newton_damping_number_to_increase_;
    ::xsd::cxx::tree::one< picard_anderson_acceleration_type > picard_anderson_acceleration_;
    ::xsd::cxx::tree::one< picard_anderson_beta_type > picard_anderson_beta_;
    ::xsd::cxx::tree::one< picard_anderson_vectors_type > picard_anderson_vectors_;
  };

  class boundaries: public ::xml_schema::type
  {
    public:
    // boundary
    // 
    typedef ::XMLProblem::boundary boundary_type;
    typedef ::xsd::cxx::tree::sequence< boundary_type > boundary_sequence;
    typedef boundary_sequence::iterator boundary_iterator;
    typedef boundary_sequence::const_iterator boundary_const_iterator;
    typedef ::xsd::cxx::tree::traits< boundary_type, char > boundary_traits;

    const boundary_sequence&
    boundary () const;

    boundary_sequence&
    boundary ();

    void
    boundary (const boundary_sequence& s);

    // Constructors.
    //
    boundaries ();

    boundaries (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    boundaries (const boundaries& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual boundaries*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~boundaries ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    boundary_sequence boundary_;
  };

  class materials: public ::xml_schema::type
  {
    public:
    // material
    // 
    typedef ::XMLProblem::material material_type;
    typedef ::xsd::cxx::tree::sequence< material_type > material_sequence;
    typedef material_sequence::iterator material_iterator;
    typedef material_sequence::const_iterator material_const_iterator;
    typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

    const material_sequence&
    material () const;

    material_sequence&
    material ();

    void
    material (const material_sequence& s);

    // Constructors.
    //
    materials ();

    materials (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    materials (const materials& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual materials*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~materials ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    material_sequence material_;
  };

  class refinement_edge: public ::xml_schema::type
  {
    public:
    // refinement_edge_id
    // 
    typedef ::xml_schema::int_ refinement_edge_id_type;
    typedef ::xsd::cxx::tree::traits< refinement_edge_id_type, char > refinement_edge_id_traits;

    const refinement_edge_id_type&
    refinement_edge_id () const;

    refinement_edge_id_type&
    refinement_edge_id ();

    void
    refinement_edge_id (const refinement_edge_id_type& x);

    // refinement_edge_number
    // 
    typedef ::xml_schema::int_ refinement_edge_number_type;
    typedef ::xsd::cxx::tree::traits< refinement_edge_number_type, char > refinement_edge_number_traits;

    const refinement_edge_number_type&
    refinement_edge_number () const;

    refinement_edge_number_type&
    refinement_edge_number ();

    void
    refinement_edge_number (const refinement_edge_number_type& x);

    // Constructors.
    //
    refinement_edge (const refinement_edge_id_type&,
                     const refinement_edge_number_type&);

    refinement_edge (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    refinement_edge (const refinement_edge& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual refinement_edge*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~refinement_edge ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< refinement_edge_id_type > refinement_edge_id_;
    ::xsd::cxx::tree::one< refinement_edge_number_type > refinement_edge_number_;
  };

  class refinement_label: public ::xml_schema::type
  {
    public:
    // refinement_label_id
    // 
    typedef ::xml_schema::int_ refinement_label_id_type;
    typedef ::xsd::cxx::tree::traits< refinement_label_id_type, char > refinement_label_id_traits;

    const refinement_label_id_type&
    refinement_label_id () const;

    refinement_label_id_type&
    refinement_label_id ();

    void
    refinement_label_id (const refinement_label_id_type& x);

    // refinement_label_number
    // 
    typedef ::xml_schema::int_ refinement_label_number_type;
    typedef ::xsd::cxx::tree::traits< refinement_label_number_type, char > refinement_label_number_traits;

    const refinement_label_number_type&
    refinement_label_number () const;

    refinement_label_number_type&
    refinement_label_number ();

    void
    refinement_label_number (const refinement_label_number_type& x);

    // Constructors.
    //
    refinement_label (const refinement_label_id_type&,
                      const refinement_label_number_type&);

    refinement_label (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    refinement_label (const refinement_label& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual refinement_label*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~refinement_label ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< refinement_label_id_type > refinement_label_id_;
    ::xsd::cxx::tree::one< refinement_label_number_type > refinement_label_number_;
  };

  class polynomial_order: public ::xml_schema::type
  {
    public:
    // polynomial_order_id
    // 
    typedef ::xml_schema::int_ polynomial_order_id_type;
    typedef ::xsd::cxx::tree::traits< polynomial_order_id_type, char > polynomial_order_id_traits;

    const polynomial_order_id_type&
    polynomial_order_id () const;

    polynomial_order_id_type&
    polynomial_order_id ();

    void
    polynomial_order_id (const polynomial_order_id_type& x);

    // polynomial_order_number
    // 
    typedef ::xml_schema::int_ polynomial_order_number_type;
    typedef ::xsd::cxx::tree::traits< polynomial_order_number_type, char > polynomial_order_number_traits;

    const polynomial_order_number_type&
    polynomial_order_number () const;

    polynomial_order_number_type&
    polynomial_order_number ();

    void
    polynomial_order_number (const polynomial_order_number_type& x);

    // Constructors.
    //
    polynomial_order (const polynomial_order_id_type&,
                      const polynomial_order_number_type&);

    polynomial_order (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    polynomial_order (const polynomial_order& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual polynomial_order*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~polynomial_order ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< polynomial_order_id_type > polynomial_order_id_;
    ::xsd::cxx::tree::one< polynomial_order_number_type > polynomial_order_number_;
  };

  class boundary: public ::xml_schema::type
  {
    public:
    // boundary_edges
    // 
    typedef ::XMLProblem::boundary_edges boundary_edges_type;
    typedef ::xsd::cxx::tree::traits< boundary_edges_type, char > boundary_edges_traits;

    const boundary_edges_type&
    boundary_edges () const;

    boundary_edges_type&
    boundary_edges ();

    void
    boundary_edges (const boundary_edges_type& x);

    void
    boundary_edges (::std::auto_ptr< boundary_edges_type > p);

    // boundary_types
    // 
    typedef ::XMLProblem::boundary_types boundary_types_type;
    typedef ::xsd::cxx::tree::traits< boundary_types_type, char > boundary_types_traits;

    const boundary_types_type&
    boundary_types () const;

    boundary_types_type&
    boundary_types ();

    void
    boundary_types (const boundary_types_type& x);

    void
    boundary_types (::std::auto_ptr< boundary_types_type > p);

    // type
    // 
    typedef ::xml_schema::string type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::auto_ptr< type_type > p);

    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // name
    // 
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::auto_ptr< name_type > p);

    // Constructors.
    //
    boundary (const boundary_edges_type&,
              const boundary_types_type&,
              const type_type&,
              const id_type&,
              const name_type&);

    boundary (::std::auto_ptr< boundary_edges_type >&,
              ::std::auto_ptr< boundary_types_type >&,
              const type_type&,
              const id_type&,
              const name_type&);

    boundary (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    boundary (const boundary& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual boundary*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~boundary ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< boundary_edges_type > boundary_edges_;
    ::xsd::cxx::tree::one< boundary_types_type > boundary_types_;
    ::xsd::cxx::tree::one< type_type > type_;
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< name_type > name_;
  };

  class material: public ::xml_schema::type
  {
    public:
    // material_labels
    // 
    typedef ::XMLProblem::material_labels material_labels_type;
    typedef ::xsd::cxx::tree::traits< material_labels_type, char > material_labels_traits;

    const material_labels_type&
    material_labels () const;

    material_labels_type&
    material_labels ();

    void
    material_labels (const material_labels_type& x);

    void
    material_labels (::std::auto_ptr< material_labels_type > p);

    // material_types
    // 
    typedef ::XMLProblem::material_types material_types_type;
    typedef ::xsd::cxx::tree::traits< material_types_type, char > material_types_traits;

    const material_types_type&
    material_types () const;

    material_types_type&
    material_types ();

    void
    material_types (const material_types_type& x);

    void
    material_types (::std::auto_ptr< material_types_type > p);

    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // name
    // 
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::auto_ptr< name_type > p);

    // Constructors.
    //
    material (const material_labels_type&,
              const material_types_type&,
              const id_type&,
              const name_type&);

    material (::std::auto_ptr< material_labels_type >&,
              ::std::auto_ptr< material_types_type >&,
              const id_type&,
              const name_type&);

    material (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    material (const material& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual material*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~material ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< material_labels_type > material_labels_;
    ::xsd::cxx::tree::one< material_types_type > material_types_;
    ::xsd::cxx::tree::one< id_type > id_;
    ::xsd::cxx::tree::one< name_type > name_;
  };

  class boundary_edges: public ::xml_schema::type
  {
    public:
    // boundary_edge
    // 
    typedef ::XMLProblem::boundary_edge boundary_edge_type;
    typedef ::xsd::cxx::tree::sequence< boundary_edge_type > boundary_edge_sequence;
    typedef boundary_edge_sequence::iterator boundary_edge_iterator;
    typedef boundary_edge_sequence::const_iterator boundary_edge_const_iterator;
    typedef ::xsd::cxx::tree::traits< boundary_edge_type, char > boundary_edge_traits;

    const boundary_edge_sequence&
    boundary_edge () const;

    boundary_edge_sequence&
    boundary_edge ();

    void
    boundary_edge (const boundary_edge_sequence& s);

    // Constructors.
    //
    boundary_edges ();

    boundary_edges (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    boundary_edges (const boundary_edges& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual boundary_edges*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~boundary_edges ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    boundary_edge_sequence boundary_edge_;
  };

  class boundary_types: public ::xml_schema::type
  {
    public:
    // boundary_type
    // 
    typedef ::XMLProblem::boundary_type boundary_type_type;
    typedef ::xsd::cxx::tree::sequence< boundary_type_type > boundary_type_sequence;
    typedef boundary_type_sequence::iterator boundary_type_iterator;
    typedef boundary_type_sequence::const_iterator boundary_type_const_iterator;
    typedef ::xsd::cxx::tree::traits< boundary_type_type, char > boundary_type_traits;

    const boundary_type_sequence&
    boundary_type () const;

    boundary_type_sequence&
    boundary_type ();

    void
    boundary_type (const boundary_type_sequence& s);

    // Constructors.
    //
    boundary_types ();

    boundary_types (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    boundary_types (const boundary_types& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual boundary_types*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~boundary_types ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    boundary_type_sequence boundary_type_;
  };

  class material_labels: public ::xml_schema::type
  {
    public:
    // material_label
    // 
    typedef ::XMLProblem::material_label material_label_type;
    typedef ::xsd::cxx::tree::sequence< material_label_type > material_label_sequence;
    typedef material_label_sequence::iterator material_label_iterator;
    typedef material_label_sequence::const_iterator material_label_const_iterator;
    typedef ::xsd::cxx::tree::traits< material_label_type, char > material_label_traits;

    const material_label_sequence&
    material_label () const;

    material_label_sequence&
    material_label ();

    void
    material_label (const material_label_sequence& s);

    // Constructors.
    //
    material_labels ();

    material_labels (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    material_labels (const material_labels& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual material_labels*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~material_labels ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    material_label_sequence material_label_;
  };

  class material_types: public ::xml_schema::type
  {
    public:
    // material_type
    // 
    typedef ::XMLProblem::material_type material_type_type;
    typedef ::xsd::cxx::tree::sequence< material_type_type > material_type_sequence;
    typedef material_type_sequence::iterator material_type_iterator;
    typedef material_type_sequence::const_iterator material_type_const_iterator;
    typedef ::xsd::cxx::tree::traits< material_type_type, char > material_type_traits;

    const material_type_sequence&
    material_type () const;

    material_type_sequence&
    material_type ();

    void
    material_type (const material_type_sequence& s);

    // Constructors.
    //
    material_types ();

    material_types (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    material_types (const material_types& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual material_types*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~material_types ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    material_type_sequence material_type_;
  };

  class boundary_edge: public ::xml_schema::type
  {
    public:
    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // Constructors.
    //
    boundary_edge (const id_type&);

    boundary_edge (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    boundary_edge (const boundary_edge& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual boundary_edge*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~boundary_edge ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
  };

  class boundary_type: public ::xml_schema::type
  {
    public:
    // key
    // 
    typedef ::xml_schema::string key_type;
    typedef ::xsd::cxx::tree::traits< key_type, char > key_traits;

    const key_type&
    key () const;

    key_type&
    key ();

    void
    key (const key_type& x);

    void
    key (::std::auto_ptr< key_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::auto_ptr< value_type > p);

    // Constructors.
    //
    boundary_type (const key_type&,
                   const value_type&);

    boundary_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    boundary_type (const boundary_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual boundary_type*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~boundary_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< key_type > key_;
    ::xsd::cxx::tree::one< value_type > value_;
  };

  class material_label: public ::xml_schema::type
  {
    public:
    // id
    // 
    typedef ::xml_schema::int_ id_type;
    typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

    const id_type&
    id () const;

    id_type&
    id ();

    void
    id (const id_type& x);

    // Constructors.
    //
    material_label (const id_type&);

    material_label (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    material_label (const material_label& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual material_label*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~material_label ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< id_type > id_;
  };

  class material_type: public ::xml_schema::type
  {
    public:
    // key
    // 
    typedef ::xml_schema::string key_type;
    typedef ::xsd::cxx::tree::traits< key_type, char > key_traits;

    const key_type&
    key () const;

    key_type&
    key ();

    void
    key (const key_type& x);

    void
    key (::std::auto_ptr< key_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::auto_ptr< value_type > p);

    // Constructors.
    //
    material_type (const key_type&,
                   const value_type&);

    material_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    material_type (const material_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual material_type*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~material_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< key_type > key_;
    ::xsd::cxx::tree::one< value_type > value_;
  };
}

#include <iosfwd>

namespace XMLProblem
{
  ::std::ostream&
  operator<< (::std::ostream&, const document&);

  ::std::ostream&
  operator<< (::std::ostream&, const geometry&);

  ::std::ostream&
  operator<< (::std::ostream&, const problem&);

  ::std::ostream&
  operator<< (::std::ostream&, const config&);

  ::std::ostream&
  operator<< (::std::ostream&, const nodes&);

  ::std::ostream&
  operator<< (::std::ostream&, const edges&);

  ::std::ostream&
  operator<< (::std::ostream&, const labels&);

  ::std::ostream&
  operator<< (::std::ostream&, const fields&);

  ::std::ostream&
  operator<< (::std::ostream&, const couplings&);

  ::std::ostream&
  operator<< (::std::ostream&, const item&);

  ::std::ostream&
  operator<< (::std::ostream&, const node&);

  ::std::ostream&
  operator<< (::std::ostream&, const edge&);

  ::std::ostream&
  operator<< (::std::ostream&, const label&);

  ::std::ostream&
  operator<< (::std::ostream&, const field&);

  ::std::ostream&
  operator<< (::std::ostream&, const coupling&);

  ::std::ostream&
  operator<< (::std::ostream&, const refinement_edges&);

  ::std::ostream&
  operator<< (::std::ostream&, const refinement_labels&);

  ::std::ostream&
  operator<< (::std::ostream&, const polynomial_orders&);

  ::std::ostream&
  operator<< (::std::ostream&, const adaptivity&);

  ::std::ostream&
  operator<< (::std::ostream&, const solver&);

  ::std::ostream&
  operator<< (::std::ostream&, const boundaries&);

  ::std::ostream&
  operator<< (::std::ostream&, const materials&);

  ::std::ostream&
  operator<< (::std::ostream&, const refinement_edge&);

  ::std::ostream&
  operator<< (::std::ostream&, const refinement_label&);

  ::std::ostream&
  operator<< (::std::ostream&, const polynomial_order&);

  ::std::ostream&
  operator<< (::std::ostream&, const boundary&);

  ::std::ostream&
  operator<< (::std::ostream&, const material&);

  ::std::ostream&
  operator<< (::std::ostream&, const boundary_edges&);

  ::std::ostream&
  operator<< (::std::ostream&, const boundary_types&);

  ::std::ostream&
  operator<< (::std::ostream&, const material_labels&);

  ::std::ostream&
  operator<< (::std::ostream&, const material_types&);

  ::std::ostream&
  operator<< (::std::ostream&, const boundary_edge&);

  ::std::ostream&
  operator<< (::std::ostream&, const boundary_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const material_label&);

  ::std::ostream&
  operator<< (::std::ostream&, const material_type&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace XMLProblem
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::std::string& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::std::string& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XMLProblem::document >
  document_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace XMLProblem
{
  // Serialize to std::ostream.
  //

  void
  document_ (::std::ostream& os,
             const ::XMLProblem::document& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  document_ (::std::ostream& os,
             const ::XMLProblem::document& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  document_ (::std::ostream& os,
             const ::XMLProblem::document& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  document_ (::xercesc::XMLFormatTarget& ft,
             const ::XMLProblem::document& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  document_ (::xercesc::XMLFormatTarget& ft,
             const ::XMLProblem::document& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  void
  document_ (::xercesc::XMLFormatTarget& ft,
             const ::XMLProblem::document& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  document_ (::xercesc::DOMDocument& d,
             const ::XMLProblem::document& x,
             ::xml_schema::flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  document_ (const ::XMLProblem::document& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const document&);

  void
  operator<< (::xercesc::DOMElement&, const geometry&);

  void
  operator<< (::xercesc::DOMElement&, const problem&);

  void
  operator<< (::xercesc::DOMElement&, const config&);

  void
  operator<< (::xercesc::DOMElement&, const nodes&);

  void
  operator<< (::xercesc::DOMElement&, const edges&);

  void
  operator<< (::xercesc::DOMElement&, const labels&);

  void
  operator<< (::xercesc::DOMElement&, const fields&);

  void
  operator<< (::xercesc::DOMElement&, const couplings&);

  void
  operator<< (::xercesc::DOMElement&, const item&);

  void
  operator<< (::xercesc::DOMElement&, const node&);

  void
  operator<< (::xercesc::DOMElement&, const edge&);

  void
  operator<< (::xercesc::DOMElement&, const label&);

  void
  operator<< (::xercesc::DOMElement&, const field&);

  void
  operator<< (::xercesc::DOMElement&, const coupling&);

  void
  operator<< (::xercesc::DOMElement&, const refinement_edges&);

  void
  operator<< (::xercesc::DOMElement&, const refinement_labels&);

  void
  operator<< (::xercesc::DOMElement&, const polynomial_orders&);

  void
  operator<< (::xercesc::DOMElement&, const adaptivity&);

  void
  operator<< (::xercesc::DOMElement&, const solver&);

  void
  operator<< (::xercesc::DOMElement&, const boundaries&);

  void
  operator<< (::xercesc::DOMElement&, const materials&);

  void
  operator<< (::xercesc::DOMElement&, const refinement_edge&);

  void
  operator<< (::xercesc::DOMElement&, const refinement_label&);

  void
  operator<< (::xercesc::DOMElement&, const polynomial_order&);

  void
  operator<< (::xercesc::DOMElement&, const boundary&);

  void
  operator<< (::xercesc::DOMElement&, const material&);

  void
  operator<< (::xercesc::DOMElement&, const boundary_edges&);

  void
  operator<< (::xercesc::DOMElement&, const boundary_types&);

  void
  operator<< (::xercesc::DOMElement&, const material_labels&);

  void
  operator<< (::xercesc::DOMElement&, const material_types&);

  void
  operator<< (::xercesc::DOMElement&, const boundary_edge&);

  void
  operator<< (::xercesc::DOMElement&, const boundary_type&);

  void
  operator<< (::xercesc::DOMElement&, const material_label&);

  void
  operator<< (::xercesc::DOMElement&, const material_type&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX______RESOURCES_XSD_PROBLEM_A2D_30_XML_H
