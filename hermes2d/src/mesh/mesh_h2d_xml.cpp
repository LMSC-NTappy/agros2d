// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mesh_h2d_xml.h"

namespace XMLMesh
{
  // variables_type
  // 

  const variables_type::variable_sequence& variables_type::
  variable () const
  {
    return this->variable_;
  }

  variables_type::variable_sequence& variables_type::
  variable ()
  {
    return this->variable_;
  }

  void variables_type::
  variable (const variable_sequence& s)
  {
    this->variable_ = s;
  }


  // vertices_type
  // 

  const vertices_type::vertex_sequence& vertices_type::
  vertex () const
  {
    return this->vertex_;
  }

  vertices_type::vertex_sequence& vertices_type::
  vertex ()
  {
    return this->vertex_;
  }

  void vertices_type::
  vertex (const vertex_sequence& s)
  {
    this->vertex_ = s;
  }


  // elements_type
  // 

  const elements_type::element_sequence& elements_type::
  element () const
  {
    return this->element_;
  }

  elements_type::element_sequence& elements_type::
  element ()
  {
    return this->element_;
  }

  void elements_type::
  element (const element_sequence& s)
  {
    this->element_ = s;
  }


  // element_type
  // 

  const element_type::v1_type& element_type::
  v1 () const
  {
    return this->v1_.get ();
  }

  element_type::v1_type& element_type::
  v1 ()
  {
    return this->v1_.get ();
  }

  void element_type::
  v1 (const v1_type& x)
  {
    this->v1_.set (x);
  }

  const element_type::v2_type& element_type::
  v2 () const
  {
    return this->v2_.get ();
  }

  element_type::v2_type& element_type::
  v2 ()
  {
    return this->v2_.get ();
  }

  void element_type::
  v2 (const v2_type& x)
  {
    this->v2_.set (x);
  }

  const element_type::v3_type& element_type::
  v3 () const
  {
    return this->v3_.get ();
  }

  element_type::v3_type& element_type::
  v3 ()
  {
    return this->v3_.get ();
  }

  void element_type::
  v3 (const v3_type& x)
  {
    this->v3_.set (x);
  }

  const element_type::marker_type& element_type::
  marker () const
  {
    return this->marker_.get ();
  }

  element_type::marker_type& element_type::
  marker ()
  {
    return this->marker_.get ();
  }

  void element_type::
  marker (const marker_type& x)
  {
    this->marker_.set (x);
  }

  void element_type::
  marker (::std::auto_ptr< marker_type > x)
  {
    this->marker_.set (x);
  }


  // triangle_type
  // 


  // quad_type
  // 

  const quad_type::v4_type& quad_type::
  v4 () const
  {
    return this->v4_.get ();
  }

  quad_type::v4_type& quad_type::
  v4 ()
  {
    return this->v4_.get ();
  }

  void quad_type::
  v4 (const v4_type& x)
  {
    this->v4_.set (x);
  }


  // edges_type
  // 

  const edges_type::edge_sequence& edges_type::
  edge () const
  {
    return this->edge_;
  }

  edges_type::edge_sequence& edges_type::
  edge ()
  {
    return this->edge_;
  }

  void edges_type::
  edge (const edge_sequence& s)
  {
    this->edge_ = s;
  }


  // curves_type
  // 

  const curves_type::arc_sequence& curves_type::
  arc () const
  {
    return this->arc_;
  }

  curves_type::arc_sequence& curves_type::
  arc ()
  {
    return this->arc_;
  }

  void curves_type::
  arc (const arc_sequence& s)
  {
    this->arc_ = s;
  }

  const curves_type::NURBS_sequence& curves_type::
  NURBS () const
  {
    return this->NURBS_;
  }

  curves_type::NURBS_sequence& curves_type::
  NURBS ()
  {
    return this->NURBS_;
  }

  void curves_type::
  NURBS (const NURBS_sequence& s)
  {
    this->NURBS_ = s;
  }


  // refinements_type
  // 

  const refinements_type::refinement_sequence& refinements_type::
  refinement () const
  {
    return this->refinement_;
  }

  refinements_type::refinement_sequence& refinements_type::
  refinement ()
  {
    return this->refinement_;
  }

  void refinements_type::
  refinement (const refinement_sequence& s)
  {
    this->refinement_ = s;
  }


  // mesh
  // 

  const mesh::variables_optional& mesh::
  variables () const
  {
    return this->variables_;
  }

  mesh::variables_optional& mesh::
  variables ()
  {
    return this->variables_;
  }

  void mesh::
  variables (const variables_type& x)
  {
    this->variables_.set (x);
  }

  void mesh::
  variables (const variables_optional& x)
  {
    this->variables_ = x;
  }

  void mesh::
  variables (::std::auto_ptr< variables_type > x)
  {
    this->variables_.set (x);
  }

  const mesh::vertices_type& mesh::
  vertices () const
  {
    return this->vertices_.get ();
  }

  mesh::vertices_type& mesh::
  vertices ()
  {
    return this->vertices_.get ();
  }

  void mesh::
  vertices (const vertices_type& x)
  {
    this->vertices_.set (x);
  }

  void mesh::
  vertices (::std::auto_ptr< vertices_type > x)
  {
    this->vertices_.set (x);
  }

  const mesh::elements_type& mesh::
  elements () const
  {
    return this->elements_.get ();
  }

  mesh::elements_type& mesh::
  elements ()
  {
    return this->elements_.get ();
  }

  void mesh::
  elements (const elements_type& x)
  {
    this->elements_.set (x);
  }

  void mesh::
  elements (::std::auto_ptr< elements_type > x)
  {
    this->elements_.set (x);
  }

  const mesh::edges_type& mesh::
  edges () const
  {
    return this->edges_.get ();
  }

  mesh::edges_type& mesh::
  edges ()
  {
    return this->edges_.get ();
  }

  void mesh::
  edges (const edges_type& x)
  {
    this->edges_.set (x);
  }

  void mesh::
  edges (::std::auto_ptr< edges_type > x)
  {
    this->edges_.set (x);
  }

  const mesh::curves_optional& mesh::
  curves () const
  {
    return this->curves_;
  }

  mesh::curves_optional& mesh::
  curves ()
  {
    return this->curves_;
  }

  void mesh::
  curves (const curves_type& x)
  {
    this->curves_.set (x);
  }

  void mesh::
  curves (const curves_optional& x)
  {
    this->curves_ = x;
  }

  void mesh::
  curves (::std::auto_ptr< curves_type > x)
  {
    this->curves_.set (x);
  }

  const mesh::refinements_optional& mesh::
  refinements () const
  {
    return this->refinements_;
  }

  mesh::refinements_optional& mesh::
  refinements ()
  {
    return this->refinements_;
  }

  void mesh::
  refinements (const refinements_type& x)
  {
    this->refinements_.set (x);
  }

  void mesh::
  refinements (const refinements_optional& x)
  {
    this->refinements_ = x;
  }

  void mesh::
  refinements (::std::auto_ptr< refinements_type > x)
  {
    this->refinements_.set (x);
  }


  // variable
  // 

  const variable::name_type& variable::
  name () const
  {
    return this->name_.get ();
  }

  variable::name_type& variable::
  name ()
  {
    return this->name_.get ();
  }

  void variable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void variable::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const variable::value_type& variable::
  value () const
  {
    return this->value_.get ();
  }

  variable::value_type& variable::
  value ()
  {
    return this->value_.get ();
  }

  void variable::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // vertex
  // 

  const vertex::x_type& vertex::
  x () const
  {
    return this->x_.get ();
  }

  vertex::x_type& vertex::
  x ()
  {
    return this->x_.get ();
  }

  void vertex::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void vertex::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const vertex::y_type& vertex::
  y () const
  {
    return this->y_.get ();
  }

  vertex::y_type& vertex::
  y ()
  {
    return this->y_.get ();
  }

  void vertex::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  void vertex::
  y (::std::auto_ptr< y_type > x)
  {
    this->y_.set (x);
  }

  const vertex::i_type& vertex::
  i () const
  {
    return this->i_.get ();
  }

  vertex::i_type& vertex::
  i ()
  {
    return this->i_.get ();
  }

  void vertex::
  i (const i_type& x)
  {
    this->i_.set (x);
  }


  // edge
  // 

  const edge::v1_type& edge::
  v1 () const
  {
    return this->v1_.get ();
  }

  edge::v1_type& edge::
  v1 ()
  {
    return this->v1_.get ();
  }

  void edge::
  v1 (const v1_type& x)
  {
    this->v1_.set (x);
  }

  const edge::v2_type& edge::
  v2 () const
  {
    return this->v2_.get ();
  }

  edge::v2_type& edge::
  v2 ()
  {
    return this->v2_.get ();
  }

  void edge::
  v2 (const v2_type& x)
  {
    this->v2_.set (x);
  }

  const edge::marker_type& edge::
  marker () const
  {
    return this->marker_.get ();
  }

  edge::marker_type& edge::
  marker ()
  {
    return this->marker_.get ();
  }

  void edge::
  marker (const marker_type& x)
  {
    this->marker_.set (x);
  }

  void edge::
  marker (::std::auto_ptr< marker_type > x)
  {
    this->marker_.set (x);
  }


  // arc
  // 

  const arc::v1_type& arc::
  v1 () const
  {
    return this->v1_.get ();
  }

  arc::v1_type& arc::
  v1 ()
  {
    return this->v1_.get ();
  }

  void arc::
  v1 (const v1_type& x)
  {
    this->v1_.set (x);
  }

  const arc::v2_type& arc::
  v2 () const
  {
    return this->v2_.get ();
  }

  arc::v2_type& arc::
  v2 ()
  {
    return this->v2_.get ();
  }

  void arc::
  v2 (const v2_type& x)
  {
    this->v2_.set (x);
  }

  const arc::angle_type& arc::
  angle () const
  {
    return this->angle_.get ();
  }

  arc::angle_type& arc::
  angle ()
  {
    return this->angle_.get ();
  }

  void arc::
  angle (const angle_type& x)
  {
    this->angle_.set (x);
  }


  // NURBS
  // 

  const NURBS::inner_point_sequence& NURBS::
  inner_point () const
  {
    return this->inner_point_;
  }

  NURBS::inner_point_sequence& NURBS::
  inner_point ()
  {
    return this->inner_point_;
  }

  void NURBS::
  inner_point (const inner_point_sequence& s)
  {
    this->inner_point_ = s;
  }

  const NURBS::knot_sequence& NURBS::
  knot () const
  {
    return this->knot_;
  }

  NURBS::knot_sequence& NURBS::
  knot ()
  {
    return this->knot_;
  }

  void NURBS::
  knot (const knot_sequence& s)
  {
    this->knot_ = s;
  }

  const NURBS::v1_type& NURBS::
  v1 () const
  {
    return this->v1_.get ();
  }

  NURBS::v1_type& NURBS::
  v1 ()
  {
    return this->v1_.get ();
  }

  void NURBS::
  v1 (const v1_type& x)
  {
    this->v1_.set (x);
  }

  const NURBS::v2_type& NURBS::
  v2 () const
  {
    return this->v2_.get ();
  }

  NURBS::v2_type& NURBS::
  v2 ()
  {
    return this->v2_.get ();
  }

  void NURBS::
  v2 (const v2_type& x)
  {
    this->v2_.set (x);
  }

  const NURBS::degree_type& NURBS::
  degree () const
  {
    return this->degree_.get ();
  }

  NURBS::degree_type& NURBS::
  degree ()
  {
    return this->degree_.get ();
  }

  void NURBS::
  degree (const degree_type& x)
  {
    this->degree_.set (x);
  }


  // refinement
  // 

  const refinement::element_id_type& refinement::
  element_id () const
  {
    return this->element_id_.get ();
  }

  refinement::element_id_type& refinement::
  element_id ()
  {
    return this->element_id_.get ();
  }

  void refinement::
  element_id (const element_id_type& x)
  {
    this->element_id_.set (x);
  }

  const refinement::refinement_type_type& refinement::
  refinement_type () const
  {
    return this->refinement_type_.get ();
  }

  refinement::refinement_type_type& refinement::
  refinement_type ()
  {
    return this->refinement_type_.get ();
  }

  void refinement::
  refinement_type (const refinement_type_type& x)
  {
    this->refinement_type_.set (x);
  }


  // inner_point
  // 

  const inner_point::x_type& inner_point::
  x () const
  {
    return this->x_.get ();
  }

  inner_point::x_type& inner_point::
  x ()
  {
    return this->x_.get ();
  }

  void inner_point::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const inner_point::y_type& inner_point::
  y () const
  {
    return this->y_.get ();
  }

  inner_point::y_type& inner_point::
  y ()
  {
    return this->y_.get ();
  }

  void inner_point::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const inner_point::weight_type& inner_point::
  weight () const
  {
    return this->weight_.get ();
  }

  inner_point::weight_type& inner_point::
  weight ()
  {
    return this->weight_.get ();
  }

  void inner_point::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }


  // knot
  // 

  const knot::value_type& knot::
  value () const
  {
    return this->value_.get ();
  }

  knot::value_type& knot::
  value ()
  {
    return this->value_.get ();
  }

  void knot::
  value (const value_type& x)
  {
    this->value_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace XMLMesh
{
  // variables_type
  //

  variables_type::
  variables_type ()
  : ::xml_schema::type (),
    variable_ (::xml_schema::flags (), this)
  {
  }

  variables_type::
  variables_type (const variables_type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    variable_ (x.variable_, f, this)
  {
  }

  variables_type::
  variables_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    variable_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void variables_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< variable_type > r (
          variable_traits::create (i, f, this));

        this->variable_.push_back (r);
        continue;
      }

      break;
    }
  }

  variables_type* variables_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class variables_type (*this, f, c);
  }

  variables_type::
  ~variables_type ()
  {
  }

  // vertices_type
  //

  vertices_type::
  vertices_type ()
  : ::xml_schema::type (),
    vertex_ (::xml_schema::flags (), this)
  {
  }

  vertices_type::
  vertices_type (const vertices_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    vertex_ (x.vertex_, f, this)
  {
  }

  vertices_type::
  vertices_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    vertex_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void vertices_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // vertex
      //
      if (n.name () == "vertex" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vertex_type > r (
          vertex_traits::create (i, f, this));

        this->vertex_.push_back (r);
        continue;
      }

      break;
    }
  }

  vertices_type* vertices_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vertices_type (*this, f, c);
  }

  vertices_type::
  ~vertices_type ()
  {
  }

  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::XMLMesh::triangle_type >
  _xsd_triangle_element_factory_init (
    "element",
    "XMLMesh",
    "triangle",
    "XMLMesh");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::XMLMesh::quad_type >
  _xsd_quad_element_factory_init (
    "element",
    "XMLMesh",
    "quad",
    "XMLMesh");


  // elements_type
  //

  elements_type::
  elements_type ()
  : ::xml_schema::type (),
    element_ (::xml_schema::flags (), this)
  {
  }

  elements_type::
  elements_type (const elements_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    element_ (x.element_, f, this)
  {
  }

  elements_type::
  elements_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    element_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void elements_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // element
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "element",
            "XMLMesh",
            &::xsd::cxx::tree::factory_impl< element_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< element_type > r (
            dynamic_cast< element_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->element_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  elements_type* elements_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class elements_type (*this, f, c);
  }

  elements_type::
  ~elements_type ()
  {
  }

  // element_type
  //

  element_type::
  element_type (const v1_type& v1,
                const v2_type& v2,
                const v3_type& v3,
                const marker_type& marker)
  : ::xml_schema::type (),
    v1_ (v1, ::xml_schema::flags (), this),
    v2_ (v2, ::xml_schema::flags (), this),
    v3_ (v3, ::xml_schema::flags (), this),
    marker_ (marker, ::xml_schema::flags (), this)
  {
  }

  element_type::
  element_type (const element_type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    v1_ (x.v1_, f, this),
    v2_ (x.v2_, f, this),
    v3_ (x.v3_, f, this),
    marker_ (x.marker_, f, this)
  {
  }

  element_type::
  element_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    v1_ (f, this),
    v2_ (f, this),
    v3_ (f, this),
    marker_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void element_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v1" && n.namespace_ ().empty ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v2" && n.namespace_ ().empty ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v3" && n.namespace_ ().empty ())
      {
        this->v3_.set (v3_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "marker" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< marker_type > r (
          marker_traits::create (i, f, this));

        this->marker_.set (r);
        continue;
      }
    }

    if (!v1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v1",
        "");
    }

    if (!v2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v2",
        "");
    }

    if (!v3_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v3",
        "");
    }

    if (!marker_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "marker",
        "");
    }
  }

  element_type* element_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class element_type (*this, f, c);
  }

  element_type::
  ~element_type ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, element_type >
  _xsd_element_type_type_factory_init (
    "element_type",
    "XMLMesh");

  // triangle_type
  //

  triangle_type::
  triangle_type (const v1_type& v1,
                 const v2_type& v2,
                 const v3_type& v3,
                 const marker_type& marker)
  : ::XMLMesh::element_type (v1,
                             v2,
                             v3,
                             marker)
  {
  }

  triangle_type::
  triangle_type (const triangle_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLMesh::element_type (x, f, c)
  {
  }

  triangle_type::
  triangle_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLMesh::element_type (e, f, c)
  {
  }

  triangle_type* triangle_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class triangle_type (*this, f, c);
  }

  triangle_type::
  ~triangle_type ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, triangle_type >
  _xsd_triangle_type_type_factory_init (
    "triangle_type",
    "XMLMesh");

  // quad_type
  //

  quad_type::
  quad_type (const v1_type& v1,
             const v2_type& v2,
             const v3_type& v3,
             const marker_type& marker,
             const v4_type& v4)
  : ::XMLMesh::element_type (v1,
                             v2,
                             v3,
                             marker),
    v4_ (v4, ::xml_schema::flags (), this)
  {
  }

  quad_type::
  quad_type (const quad_type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::XMLMesh::element_type (x, f, c),
    v4_ (x.v4_, f, this)
  {
  }

  quad_type::
  quad_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::XMLMesh::element_type (e, f | ::xml_schema::flags::base, c),
    v4_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void quad_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLMesh::element_type::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v4" && n.namespace_ ().empty ())
      {
        this->v4_.set (v4_traits::create (i, f, this));
        continue;
      }
    }

    if (!v4_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v4",
        "");
    }
  }

  quad_type* quad_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class quad_type (*this, f, c);
  }

  quad_type::
  ~quad_type ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, quad_type >
  _xsd_quad_type_type_factory_init (
    "quad_type",
    "XMLMesh");

  // edges_type
  //

  edges_type::
  edges_type ()
  : ::xml_schema::type (),
    edge_ (::xml_schema::flags (), this)
  {
  }

  edges_type::
  edges_type (const edges_type& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    edge_ (x.edge_, f, this)
  {
  }

  edges_type::
  edges_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    edge_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void edges_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // edge
      //
      if (n.name () == "edge" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< edge_type > r (
          edge_traits::create (i, f, this));

        this->edge_.push_back (r);
        continue;
      }

      break;
    }
  }

  edges_type* edges_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class edges_type (*this, f, c);
  }

  edges_type::
  ~edges_type ()
  {
  }

  // curves_type
  //

  curves_type::
  curves_type ()
  : ::xml_schema::type (),
    arc_ (::xml_schema::flags (), this),
    NURBS_ (::xml_schema::flags (), this)
  {
  }

  curves_type::
  curves_type (const curves_type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    arc_ (x.arc_, f, this),
    NURBS_ (x.NURBS_, f, this)
  {
  }

  curves_type::
  curves_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    arc_ (f, this),
    NURBS_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void curves_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // arc
      //
      if (n.name () == "arc" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< arc_type > r (
          arc_traits::create (i, f, this));

        this->arc_.push_back (r);
        continue;
      }

      // NURBS
      //
      if (n.name () == "NURBS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NURBS_type > r (
          NURBS_traits::create (i, f, this));

        this->NURBS_.push_back (r);
        continue;
      }

      break;
    }
  }

  curves_type* curves_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class curves_type (*this, f, c);
  }

  curves_type::
  ~curves_type ()
  {
  }

  // refinements_type
  //

  refinements_type::
  refinements_type ()
  : ::xml_schema::type (),
    refinement_ (::xml_schema::flags (), this)
  {
  }

  refinements_type::
  refinements_type (const refinements_type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refinement_ (x.refinement_, f, this)
  {
  }

  refinements_type::
  refinements_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refinement_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void refinements_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // refinement
      //
      if (n.name () == "refinement" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinement_type > r (
          refinement_traits::create (i, f, this));

        this->refinement_.push_back (r);
        continue;
      }

      break;
    }
  }

  refinements_type* refinements_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class refinements_type (*this, f, c);
  }

  refinements_type::
  ~refinements_type ()
  {
  }

  // mesh
  //

  mesh::
  mesh (const vertices_type& vertices,
        const elements_type& elements,
        const edges_type& edges)
  : ::xml_schema::type (),
    variables_ (::xml_schema::flags (), this),
    vertices_ (vertices, ::xml_schema::flags (), this),
    elements_ (elements, ::xml_schema::flags (), this),
    edges_ (edges, ::xml_schema::flags (), this),
    curves_ (::xml_schema::flags (), this),
    refinements_ (::xml_schema::flags (), this)
  {
  }

  mesh::
  mesh (::std::auto_ptr< vertices_type >& vertices,
        ::std::auto_ptr< elements_type >& elements,
        ::std::auto_ptr< edges_type >& edges)
  : ::xml_schema::type (),
    variables_ (::xml_schema::flags (), this),
    vertices_ (vertices, ::xml_schema::flags (), this),
    elements_ (elements, ::xml_schema::flags (), this),
    edges_ (edges, ::xml_schema::flags (), this),
    curves_ (::xml_schema::flags (), this),
    refinements_ (::xml_schema::flags (), this)
  {
  }

  mesh::
  mesh (const mesh& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    variables_ (x.variables_, f, this),
    vertices_ (x.vertices_, f, this),
    elements_ (x.elements_, f, this),
    edges_ (x.edges_, f, this),
    curves_ (x.curves_, f, this),
    refinements_ (x.refinements_, f, this)
  {
  }

  mesh::
  mesh (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    variables_ (f, this),
    vertices_ (f, this),
    elements_ (f, this),
    edges_ (f, this),
    curves_ (f, this),
    refinements_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void mesh::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variables
      //
      if (n.name () == "variables" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< variables_type > r (
          variables_traits::create (i, f, this));

        if (!this->variables_)
        {
          this->variables_.set (r);
          continue;
        }
      }

      // vertices
      //
      if (n.name () == "vertices" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vertices_type > r (
          vertices_traits::create (i, f, this));

        if (!vertices_.present ())
        {
          this->vertices_.set (r);
          continue;
        }
      }

      // elements
      //
      if (n.name () == "elements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elements_type > r (
          elements_traits::create (i, f, this));

        if (!elements_.present ())
        {
          this->elements_.set (r);
          continue;
        }
      }

      // edges
      //
      if (n.name () == "edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< edges_type > r (
          edges_traits::create (i, f, this));

        if (!edges_.present ())
        {
          this->edges_.set (r);
          continue;
        }
      }

      // curves
      //
      if (n.name () == "curves" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< curves_type > r (
          curves_traits::create (i, f, this));

        if (!this->curves_)
        {
          this->curves_.set (r);
          continue;
        }
      }

      // refinements
      //
      if (n.name () == "refinements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinements_type > r (
          refinements_traits::create (i, f, this));

        if (!this->refinements_)
        {
          this->refinements_.set (r);
          continue;
        }
      }

      break;
    }

    if (!vertices_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vertices",
        "");
    }

    if (!elements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "elements",
        "");
    }

    if (!edges_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "edges",
        "");
    }
  }

  mesh* mesh::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mesh (*this, f, c);
  }

  mesh::
  ~mesh ()
  {
  }

  // variable
  //

  variable::
  variable (const name_type& name,
            const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  variable::
  variable (const variable& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  variable::
  variable (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void variable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  variable* variable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class variable (*this, f, c);
  }

  variable::
  ~variable ()
  {
  }

  // vertex
  //

  vertex::
  vertex (const x_type& x,
          const y_type& y,
          const i_type& i)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this)
  {
  }

  vertex::
  vertex (const vertex& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    i_ (x.i_, f, this)
  {
  }

  vertex::
  vertex (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void vertex::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.set (r);
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< y_type > r (
          y_traits::create (i, f, this));

        this->y_.set (r);
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }
  }

  vertex* vertex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vertex (*this, f, c);
  }

  vertex::
  ~vertex ()
  {
  }

  // edge
  //

  edge::
  edge (const v1_type& v1,
        const v2_type& v2,
        const marker_type& marker)
  : ::xml_schema::type (),
    v1_ (v1, ::xml_schema::flags (), this),
    v2_ (v2, ::xml_schema::flags (), this),
    marker_ (marker, ::xml_schema::flags (), this)
  {
  }

  edge::
  edge (const edge& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    v1_ (x.v1_, f, this),
    v2_ (x.v2_, f, this),
    marker_ (x.marker_, f, this)
  {
  }

  edge::
  edge (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    v1_ (f, this),
    v2_ (f, this),
    marker_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void edge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v1" && n.namespace_ ().empty ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v2" && n.namespace_ ().empty ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "marker" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< marker_type > r (
          marker_traits::create (i, f, this));

        this->marker_.set (r);
        continue;
      }
    }

    if (!v1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v1",
        "");
    }

    if (!v2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v2",
        "");
    }

    if (!marker_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "marker",
        "");
    }
  }

  edge* edge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class edge (*this, f, c);
  }

  edge::
  ~edge ()
  {
  }

  // arc
  //

  arc::
  arc (const v1_type& v1,
       const v2_type& v2,
       const angle_type& angle)
  : ::xml_schema::type (),
    v1_ (v1, ::xml_schema::flags (), this),
    v2_ (v2, ::xml_schema::flags (), this),
    angle_ (angle, ::xml_schema::flags (), this)
  {
  }

  arc::
  arc (const arc& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    v1_ (x.v1_, f, this),
    v2_ (x.v2_, f, this),
    angle_ (x.angle_, f, this)
  {
  }

  arc::
  arc (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    v1_ (f, this),
    v2_ (f, this),
    angle_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void arc::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v1" && n.namespace_ ().empty ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v2" && n.namespace_ ().empty ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "angle" && n.namespace_ ().empty ())
      {
        this->angle_.set (angle_traits::create (i, f, this));
        continue;
      }
    }

    if (!v1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v1",
        "");
    }

    if (!v2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v2",
        "");
    }

    if (!angle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "angle",
        "");
    }
  }

  arc* arc::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arc (*this, f, c);
  }

  arc::
  ~arc ()
  {
  }

  // NURBS
  //

  NURBS::
  NURBS (const v1_type& v1,
         const v2_type& v2,
         const degree_type& degree)
  : ::xml_schema::type (),
    inner_point_ (::xml_schema::flags (), this),
    knot_ (::xml_schema::flags (), this),
    v1_ (v1, ::xml_schema::flags (), this),
    v2_ (v2, ::xml_schema::flags (), this),
    degree_ (degree, ::xml_schema::flags (), this)
  {
  }

  NURBS::
  NURBS (const NURBS& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    inner_point_ (x.inner_point_, f, this),
    knot_ (x.knot_, f, this),
    v1_ (x.v1_, f, this),
    v2_ (x.v2_, f, this),
    degree_ (x.degree_, f, this)
  {
  }

  NURBS::
  NURBS (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    inner_point_ (f, this),
    knot_ (f, this),
    v1_ (f, this),
    v2_ (f, this),
    degree_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void NURBS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inner_point
      //
      if (n.name () == "inner_point" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inner_point_type > r (
          inner_point_traits::create (i, f, this));

        this->inner_point_.push_back (r);
        continue;
      }

      // knot
      //
      if (n.name () == "knot" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< knot_type > r (
          knot_traits::create (i, f, this));

        this->knot_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v1" && n.namespace_ ().empty ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v2" && n.namespace_ ().empty ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "degree" && n.namespace_ ().empty ())
      {
        this->degree_.set (degree_traits::create (i, f, this));
        continue;
      }
    }

    if (!v1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v1",
        "");
    }

    if (!v2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v2",
        "");
    }

    if (!degree_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "degree",
        "");
    }
  }

  NURBS* NURBS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NURBS (*this, f, c);
  }

  NURBS::
  ~NURBS ()
  {
  }

  // refinement
  //

  refinement::
  refinement (const element_id_type& element_id,
              const refinement_type_type& refinement_type)
  : ::xml_schema::type (),
    element_id_ (element_id, ::xml_schema::flags (), this),
    refinement_type_ (refinement_type, ::xml_schema::flags (), this)
  {
  }

  refinement::
  refinement (const refinement& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    element_id_ (x.element_id_, f, this),
    refinement_type_ (x.refinement_type_, f, this)
  {
  }

  refinement::
  refinement (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    element_id_ (f, this),
    refinement_type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void refinement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "element_id" && n.namespace_ ().empty ())
      {
        this->element_id_.set (element_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "refinement_type" && n.namespace_ ().empty ())
      {
        this->refinement_type_.set (refinement_type_traits::create (i, f, this));
        continue;
      }
    }

    if (!element_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "element_id",
        "");
    }

    if (!refinement_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refinement_type",
        "");
    }
  }

  refinement* refinement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class refinement (*this, f, c);
  }

  refinement::
  ~refinement ()
  {
  }

  // inner_point
  //

  inner_point::
  inner_point (const x_type& x,
               const y_type& y,
               const weight_type& weight)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    weight_ (weight, ::xml_schema::flags (), this)
  {
  }

  inner_point::
  inner_point (const inner_point& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    weight_ (x.weight_, f, this)
  {
  }

  inner_point::
  inner_point (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    weight_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void inner_point::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        this->weight_.set (weight_traits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }
  }

  inner_point* inner_point::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inner_point (*this, f, c);
  }

  inner_point::
  ~inner_point ()
  {
  }

  // knot
  //

  knot::
  knot (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  knot::
  knot (const knot& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  knot::
  knot (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void knot::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  knot* knot::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class knot (*this, f, c);
  }

  knot::
  ~knot ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace XMLMesh
{
  ::std::ostream&
  operator<< (::std::ostream& o, const variables_type& i)
  {
    for (variables_type::variable_const_iterator
         b (i.variable ().begin ()), e (i.variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vertices_type& i)
  {
    for (vertices_type::vertex_const_iterator
         b (i.vertex ().begin ()), e (i.vertex ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vertex: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const elements_type& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (elements_type::element_const_iterator
           b (i.element ().begin ()), e (i.element ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "element: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const element_type& i)
  {
    o << ::std::endl << "v1: " << i.v1 ();
    o << ::std::endl << "v2: " << i.v2 ();
    o << ::std::endl << "v3: " << i.v3 ();
    o << ::std::endl << "marker: " << i.marker ();
    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, element_type >
  _xsd_element_type_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const triangle_type& i)
  {
    o << static_cast< const ::XMLMesh::element_type& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, triangle_type >
  _xsd_triangle_type_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const quad_type& i)
  {
    o << static_cast< const ::XMLMesh::element_type& > (i);

    o << ::std::endl << "v4: " << i.v4 ();
    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, quad_type >
  _xsd_quad_type_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const edges_type& i)
  {
    for (edges_type::edge_const_iterator
         b (i.edge ().begin ()), e (i.edge ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "edge: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const curves_type& i)
  {
    for (curves_type::arc_const_iterator
         b (i.arc ().begin ()), e (i.arc ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "arc: " << *b;
    }

    for (curves_type::NURBS_const_iterator
         b (i.NURBS ().begin ()), e (i.NURBS ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "NURBS: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const refinements_type& i)
  {
    for (refinements_type::refinement_const_iterator
         b (i.refinement ().begin ()), e (i.refinement ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "refinement: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const mesh& i)
  {
    if (i.variables ())
    {
      o << ::std::endl << "variables: " << *i.variables ();
    }

    o << ::std::endl << "vertices: " << i.vertices ();
    o << ::std::endl << "elements: " << i.elements ();
    o << ::std::endl << "edges: " << i.edges ();
    if (i.curves ())
    {
      o << ::std::endl << "curves: " << *i.curves ();
    }

    if (i.refinements ())
    {
      o << ::std::endl << "refinements: " << *i.refinements ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const variable& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vertex& i)
  {
    o << ::std::endl << "x: " << i.x ();
    o << ::std::endl << "y: " << i.y ();
    o << ::std::endl << "i: " << i.i ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const edge& i)
  {
    o << ::std::endl << "v1: " << i.v1 ();
    o << ::std::endl << "v2: " << i.v2 ();
    o << ::std::endl << "marker: " << i.marker ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const arc& i)
  {
    o << ::std::endl << "v1: " << i.v1 ();
    o << ::std::endl << "v2: " << i.v2 ();
    o << ::std::endl << "angle: " << i.angle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NURBS& i)
  {
    for (NURBS::inner_point_const_iterator
         b (i.inner_point ().begin ()), e (i.inner_point ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "inner_point: " << *b;
    }

    for (NURBS::knot_const_iterator
         b (i.knot ().begin ()), e (i.knot ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "knot: " << *b;
    }

    o << ::std::endl << "v1: " << i.v1 ();
    o << ::std::endl << "v2: " << i.v2 ();
    o << ::std::endl << "degree: " << i.degree ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const refinement& i)
  {
    o << ::std::endl << "element_id: " << i.element_id ();
    o << ::std::endl << "refinement_type: " << i.refinement_type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const inner_point& i)
  {
    o << ::std::endl << "x: " << i.x ();
    o << ::std::endl << "y: " << i.y ();
    o << ::std::endl << "weight: " << i.weight ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const knot& i)
  {
    o << ::std::endl << "value: " << i.value ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLMesh
{
  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLMesh::mesh > r (
      ::XMLMesh::mesh_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLMesh::mesh > r (
      ::XMLMesh::mesh_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLMesh::mesh > r (
      ::XMLMesh::mesh_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLMesh::mesh_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLMesh::mesh_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLMesh::mesh_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLMesh::mesh_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLMesh::mesh_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLMesh::mesh_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLMesh::mesh > r (
      ::XMLMesh::mesh_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLMesh::mesh > r (
      ::XMLMesh::mesh_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLMesh::mesh > r (
      ::XMLMesh::mesh_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::XMLMesh::mesh > r (
        ::XMLMesh::mesh_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "mesh" &&
        n.namespace_ () == "XMLMesh")
    {
      ::std::auto_ptr< ::XMLMesh::mesh > r (
        ::xsd::cxx::tree::traits< ::XMLMesh::mesh, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "mesh",
      "XMLMesh");
  }

  ::std::auto_ptr< ::XMLMesh::mesh >
  mesh_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "mesh" &&
        n.namespace_ () == "XMLMesh")
    {
      ::std::auto_ptr< ::XMLMesh::mesh > r (
        ::xsd::cxx::tree::traits< ::XMLMesh::mesh, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "mesh",
      "XMLMesh");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace XMLMesh
{
  void
  mesh_ (::std::ostream& o,
         const ::XMLMesh::mesh& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLMesh::mesh_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  mesh_ (::std::ostream& o,
         const ::XMLMesh::mesh& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLMesh::mesh_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  mesh_ (::std::ostream& o,
         const ::XMLMesh::mesh& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLMesh::mesh_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  mesh_ (::xercesc::XMLFormatTarget& t,
         const ::XMLMesh::mesh& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLMesh::mesh_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  mesh_ (::xercesc::XMLFormatTarget& t,
         const ::XMLMesh::mesh& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLMesh::mesh_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  mesh_ (::xercesc::XMLFormatTarget& t,
         const ::XMLMesh::mesh& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLMesh::mesh_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  mesh_ (::xercesc::DOMDocument& d,
         const ::XMLMesh::mesh& s,
         ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "mesh" &&
        n.namespace_ () == "XMLMesh")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "mesh",
        "XMLMesh");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  mesh_ (const ::XMLMesh::mesh& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "mesh",
        "XMLMesh",
        m, f));

    ::XMLMesh::mesh_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const variables_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // variable
    //
    for (variables_type::variable_const_iterator
         b (i.variable ().begin ()), n (i.variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vertices_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // vertex
    //
    for (vertices_type::vertex_const_iterator
         b (i.vertex ().begin ()), n (i.vertex ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vertex",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::XMLMesh::triangle_type >
  _xsd_triangle_element_serializer_init (
    "element",
    "XMLMesh",
    "triangle",
    "XMLMesh");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::XMLMesh::quad_type >
  _xsd_quad_element_serializer_init (
    "element",
    "XMLMesh",
    "quad",
    "XMLMesh");


  void
  operator<< (::xercesc::DOMElement& e, const elements_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // element
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (elements_type::element_const_iterator
           b (i.element ().begin ()), n (i.element ().end ());
           b != n; ++b)
      {
        if (typeid (elements_type::element_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "element",
              "XMLMesh",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "element",
            "XMLMesh",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const element_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // v1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v1",
          e));

      a << i.v1 ();
    }

    // v2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v2",
          e));

      a << i.v2 ();
    }

    // v3
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v3",
          e));

      a << i.v3 ();
    }

    // marker
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "marker",
          e));

      a << i.marker ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, element_type >
  _xsd_element_type_type_serializer_init (
    "element_type",
    "XMLMesh");


  void
  operator<< (::xercesc::DOMElement& e, const triangle_type& i)
  {
    e << static_cast< const ::XMLMesh::element_type& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, triangle_type >
  _xsd_triangle_type_type_serializer_init (
    "triangle_type",
    "XMLMesh");


  void
  operator<< (::xercesc::DOMElement& e, const quad_type& i)
  {
    e << static_cast< const ::XMLMesh::element_type& > (i);

    // v4
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v4",
          e));

      a << i.v4 ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, quad_type >
  _xsd_quad_type_type_serializer_init (
    "quad_type",
    "XMLMesh");


  void
  operator<< (::xercesc::DOMElement& e, const edges_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // edge
    //
    for (edges_type::edge_const_iterator
         b (i.edge ().begin ()), n (i.edge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edge",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const curves_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // arc
    //
    for (curves_type::arc_const_iterator
         b (i.arc ().begin ()), n (i.arc ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arc",
          e));

      s << *b;
    }

    // NURBS
    //
    for (curves_type::NURBS_const_iterator
         b (i.NURBS ().begin ()), n (i.NURBS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NURBS",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const refinements_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // refinement
    //
    for (refinements_type::refinement_const_iterator
         b (i.refinement ().begin ()), n (i.refinement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinement",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mesh& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // variables
    //
    if (i.variables ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variables",
          e));

      s << *i.variables ();
    }

    // vertices
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vertices",
          e));

      s << i.vertices ();
    }

    // elements
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elements",
          e));

      s << i.elements ();
    }

    // edges
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edges",
          e));

      s << i.edges ();
    }

    // curves
    //
    if (i.curves ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "curves",
          e));

      s << *i.curves ();
    }

    // refinements
    //
    if (i.refinements ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinements",
          e));

      s << *i.refinements ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const variable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_decimal(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vertex& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << i.y ();
    }

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const edge& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // v1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v1",
          e));

      a << i.v1 ();
    }

    // v2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v2",
          e));

      a << i.v2 ();
    }

    // marker
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "marker",
          e));

      a << i.marker ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const arc& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // v1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v1",
          e));

      a << i.v1 ();
    }

    // v2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v2",
          e));

      a << i.v2 ();
    }

    // angle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "angle",
          e));

      a << ::xml_schema::as_decimal(i.angle ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NURBS& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // inner_point
    //
    for (NURBS::inner_point_const_iterator
         b (i.inner_point ().begin ()), n (i.inner_point ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inner_point",
          e));

      s << *b;
    }

    // knot
    //
    for (NURBS::knot_const_iterator
         b (i.knot ().begin ()), n (i.knot ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "knot",
          e));

      s << *b;
    }

    // v1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v1",
          e));

      a << i.v1 ();
    }

    // v2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v2",
          e));

      a << i.v2 ();
    }

    // degree
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "degree",
          e));

      a << i.degree ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const refinement& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // element_id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "element_id",
          e));

      a << i.element_id ();
    }

    // refinement_type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refinement_type",
          e));

      a << i.refinement_type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const inner_point& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << ::xml_schema::as_decimal(i.x ());
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << ::xml_schema::as_decimal(i.y ());
    }

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << ::xml_schema::as_decimal(i.weight ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const knot& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_decimal(i.value ());
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

