// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mesh_h2d_xml.h"

// mesh_h2d
// 

const mesh_h2d::variables_type& mesh_h2d::
variables () const
{
  return this->variables_.get ();
}

mesh_h2d::variables_type& mesh_h2d::
variables ()
{
  return this->variables_.get ();
}

void mesh_h2d::
variables (const variables_type& x)
{
  this->variables_.set (x);
}

void mesh_h2d::
variables (::std::auto_ptr< variables_type > x)
{
  this->variables_.set (x);
}

const mesh_h2d::vertices_type& mesh_h2d::
vertices () const
{
  return this->vertices_.get ();
}

mesh_h2d::vertices_type& mesh_h2d::
vertices ()
{
  return this->vertices_.get ();
}

void mesh_h2d::
vertices (const vertices_type& x)
{
  this->vertices_.set (x);
}

void mesh_h2d::
vertices (::std::auto_ptr< vertices_type > x)
{
  this->vertices_.set (x);
}

const mesh_h2d::elements_type& mesh_h2d::
elements () const
{
  return this->elements_.get ();
}

mesh_h2d::elements_type& mesh_h2d::
elements ()
{
  return this->elements_.get ();
}

void mesh_h2d::
elements (const elements_type& x)
{
  this->elements_.set (x);
}

void mesh_h2d::
elements (::std::auto_ptr< elements_type > x)
{
  this->elements_.set (x);
}

const mesh_h2d::boundaries_type& mesh_h2d::
boundaries () const
{
  return this->boundaries_.get ();
}

mesh_h2d::boundaries_type& mesh_h2d::
boundaries ()
{
  return this->boundaries_.get ();
}

void mesh_h2d::
boundaries (const boundaries_type& x)
{
  this->boundaries_.set (x);
}

void mesh_h2d::
boundaries (::std::auto_ptr< boundaries_type > x)
{
  this->boundaries_.set (x);
}

const mesh_h2d::curves_type& mesh_h2d::
curves () const
{
  return this->curves_.get ();
}

mesh_h2d::curves_type& mesh_h2d::
curves ()
{
  return this->curves_.get ();
}

void mesh_h2d::
curves (const curves_type& x)
{
  this->curves_.set (x);
}

void mesh_h2d::
curves (::std::auto_ptr< curves_type > x)
{
  this->curves_.set (x);
}


// variables
// 

const variables::variable_sequence& variables::
variable () const
{
  return this->variable_;
}

variables::variable_sequence& variables::
variable ()
{
  return this->variable_;
}

void variables::
variable (const variable_sequence& s)
{
  this->variable_ = s;
}


// vertices
// 

const vertices::vertex_sequence& vertices::
vertex () const
{
  return this->vertex_;
}

vertices::vertex_sequence& vertices::
vertex ()
{
  return this->vertex_;
}

void vertices::
vertex (const vertex_sequence& s)
{
  this->vertex_ = s;
}


// elements
// 

const elements::quad_sequence& elements::
quad () const
{
  return this->quad_;
}

elements::quad_sequence& elements::
quad ()
{
  return this->quad_;
}

void elements::
quad (const quad_sequence& s)
{
  this->quad_ = s;
}

const elements::triangle_sequence& elements::
triangle () const
{
  return this->triangle_;
}

elements::triangle_sequence& elements::
triangle ()
{
  return this->triangle_;
}

void elements::
triangle (const triangle_sequence& s)
{
  this->triangle_ = s;
}


// boundaries
// 

const boundaries::boundary_edge_sequence& boundaries::
boundary_edge () const
{
  return this->boundary_edge_;
}

boundaries::boundary_edge_sequence& boundaries::
boundary_edge ()
{
  return this->boundary_edge_;
}

void boundaries::
boundary_edge (const boundary_edge_sequence& s)
{
  this->boundary_edge_ = s;
}


// curves
// 

const curves::curve_sequence& curves::
curve () const
{
  return this->curve_;
}

curves::curve_sequence& curves::
curve ()
{
  return this->curve_;
}

void curves::
curve (const curve_sequence& s)
{
  this->curve_ = s;
}


// variable
// 

const variable::name_type& variable::
name () const
{
  return this->name_.get ();
}

variable::name_type& variable::
name ()
{
  return this->name_.get ();
}

void variable::
name (const name_type& x)
{
  this->name_.set (x);
}

void variable::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const variable::value_type& variable::
value () const
{
  return this->value_.get ();
}

variable::value_type& variable::
value ()
{
  return this->value_.get ();
}

void variable::
value (const value_type& x)
{
  this->value_.set (x);
}


// vertex
// 

const vertex::x_type& vertex::
x () const
{
  return this->x_.get ();
}

vertex::x_type& vertex::
x ()
{
  return this->x_.get ();
}

void vertex::
x (const x_type& x)
{
  this->x_.set (x);
}

const vertex::y_type& vertex::
y () const
{
  return this->y_.get ();
}

vertex::y_type& vertex::
y ()
{
  return this->y_.get ();
}

void vertex::
y (const y_type& x)
{
  this->y_.set (x);
}


// quad
// 

const quad::vertices_type& quad::
vertices () const
{
  return this->vertices_.get ();
}

quad::vertices_type& quad::
vertices ()
{
  return this->vertices_.get ();
}

void quad::
vertices (const vertices_type& x)
{
  this->vertices_.set (x);
}

void quad::
vertices (::std::auto_ptr< vertices_type > x)
{
  this->vertices_.set (x);
}

const quad::marker_type& quad::
marker () const
{
  return this->marker_.get ();
}

quad::marker_type& quad::
marker ()
{
  return this->marker_.get ();
}

void quad::
marker (const marker_type& x)
{
  this->marker_.set (x);
}

void quad::
marker (::std::auto_ptr< marker_type > x)
{
  this->marker_.set (x);
}

const quad::empty_optional& quad::
empty () const
{
  return this->empty_;
}

quad::empty_optional& quad::
empty ()
{
  return this->empty_;
}

void quad::
empty (const empty_type& x)
{
  this->empty_.set (x);
}

void quad::
empty (const empty_optional& x)
{
  this->empty_ = x;
}


// triangle
// 

const triangle::vertices_type& triangle::
vertices () const
{
  return this->vertices_.get ();
}

triangle::vertices_type& triangle::
vertices ()
{
  return this->vertices_.get ();
}

void triangle::
vertices (const vertices_type& x)
{
  this->vertices_.set (x);
}

void triangle::
vertices (::std::auto_ptr< vertices_type > x)
{
  this->vertices_.set (x);
}

const triangle::marker_type& triangle::
marker () const
{
  return this->marker_.get ();
}

triangle::marker_type& triangle::
marker ()
{
  return this->marker_.get ();
}

void triangle::
marker (const marker_type& x)
{
  this->marker_.set (x);
}

void triangle::
marker (::std::auto_ptr< marker_type > x)
{
  this->marker_.set (x);
}

const triangle::empty_optional& triangle::
empty () const
{
  return this->empty_;
}

triangle::empty_optional& triangle::
empty ()
{
  return this->empty_;
}

void triangle::
empty (const empty_type& x)
{
  this->empty_.set (x);
}

void triangle::
empty (const empty_optional& x)
{
  this->empty_ = x;
}


// boundary_edge
// 

const boundary_edge::vertex_sequence& boundary_edge::
vertex () const
{
  return this->vertex_;
}

boundary_edge::vertex_sequence& boundary_edge::
vertex ()
{
  return this->vertex_;
}

void boundary_edge::
vertex (const vertex_sequence& s)
{
  this->vertex_ = s;
}

const boundary_edge::marker_type& boundary_edge::
marker () const
{
  return this->marker_.get ();
}

boundary_edge::marker_type& boundary_edge::
marker ()
{
  return this->marker_.get ();
}

void boundary_edge::
marker (const marker_type& x)
{
  this->marker_.set (x);
}

void boundary_edge::
marker (::std::auto_ptr< marker_type > x)
{
  this->marker_.set (x);
}


// curve
// 

const curve::vertex_sequence& curve::
vertex () const
{
  return this->vertex_;
}

curve::vertex_sequence& curve::
vertex ()
{
  return this->vertex_;
}

void curve::
vertex (const vertex_sequence& s)
{
  this->vertex_ = s;
}

const curve::angle_type& curve::
angle () const
{
  return this->angle_.get ();
}

curve::angle_type& curve::
angle ()
{
  return this->angle_.get ();
}

void curve::
angle (const angle_type& x)
{
  this->angle_.set (x);
}


// vertices1
// 

const vertices1::vertex_sequence& vertices1::
vertex () const
{
  return this->vertex_;
}

vertices1::vertex_sequence& vertices1::
vertex ()
{
  return this->vertex_;
}

void vertices1::
vertex (const vertex_sequence& s)
{
  this->vertex_ = s;
}


// vertices2
// 

const vertices2::vertex_sequence& vertices2::
vertex () const
{
  return this->vertex_;
}

vertices2::vertex_sequence& vertices2::
vertex ()
{
  return this->vertex_;
}

void vertices2::
vertex (const vertex_sequence& s)
{
  this->vertex_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// mesh_h2d
//

mesh_h2d::
mesh_h2d (const variables_type& variables,
          const vertices_type& vertices,
          const elements_type& elements,
          const boundaries_type& boundaries,
          const curves_type& curves)
: ::xml_schema::type (),
  variables_ (variables, ::xml_schema::flags (), this),
  vertices_ (vertices, ::xml_schema::flags (), this),
  elements_ (elements, ::xml_schema::flags (), this),
  boundaries_ (boundaries, ::xml_schema::flags (), this),
  curves_ (curves, ::xml_schema::flags (), this)
{
}

mesh_h2d::
mesh_h2d (::std::auto_ptr< variables_type >& variables,
          ::std::auto_ptr< vertices_type >& vertices,
          ::std::auto_ptr< elements_type >& elements,
          ::std::auto_ptr< boundaries_type >& boundaries,
          ::std::auto_ptr< curves_type >& curves)
: ::xml_schema::type (),
  variables_ (variables, ::xml_schema::flags (), this),
  vertices_ (vertices, ::xml_schema::flags (), this),
  elements_ (elements, ::xml_schema::flags (), this),
  boundaries_ (boundaries, ::xml_schema::flags (), this),
  curves_ (curves, ::xml_schema::flags (), this)
{
}

mesh_h2d::
mesh_h2d (const mesh_h2d& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  variables_ (x.variables_, f, this),
  vertices_ (x.vertices_, f, this),
  elements_ (x.elements_, f, this),
  boundaries_ (x.boundaries_, f, this),
  curves_ (x.curves_, f, this)
{
}

mesh_h2d::
mesh_h2d (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  variables_ (f, this),
  vertices_ (f, this),
  elements_ (f, this),
  boundaries_ (f, this),
  curves_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void mesh_h2d::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // variables
    //
    if (n.name () == "variables" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< variables_type > r (
        variables_traits::create (i, f, this));

      if (!variables_.present ())
      {
        this->variables_.set (r);
        continue;
      }
    }

    // vertices
    //
    if (n.name () == "vertices" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertices_type > r (
        vertices_traits::create (i, f, this));

      if (!vertices_.present ())
      {
        this->vertices_.set (r);
        continue;
      }
    }

    // elements
    //
    if (n.name () == "elements" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elements_type > r (
        elements_traits::create (i, f, this));

      if (!elements_.present ())
      {
        this->elements_.set (r);
        continue;
      }
    }

    // boundaries
    //
    if (n.name () == "boundaries" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< boundaries_type > r (
        boundaries_traits::create (i, f, this));

      if (!boundaries_.present ())
      {
        this->boundaries_.set (r);
        continue;
      }
    }

    // curves
    //
    if (n.name () == "curves" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< curves_type > r (
        curves_traits::create (i, f, this));

      if (!curves_.present ())
      {
        this->curves_.set (r);
        continue;
      }
    }

    break;
  }

  if (!variables_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "variables",
      "");
  }

  if (!vertices_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vertices",
      "");
  }

  if (!elements_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "elements",
      "");
  }

  if (!boundaries_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaries",
      "");
  }

  if (!curves_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "curves",
      "");
  }
}

mesh_h2d* mesh_h2d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mesh_h2d (*this, f, c);
}

mesh_h2d::
~mesh_h2d ()
{
}

// variables
//

variables::
variables ()
: ::xml_schema::type (),
  variable_ (::xml_schema::flags (), this)
{
}

variables::
variables (const variables& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  variable_ (x.variable_, f, this)
{
}

variables::
variables (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  variable_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void variables::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // variable
    //
    if (n.name () == "variable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< variable_type > r (
        variable_traits::create (i, f, this));

      this->variable_.push_back (r);
      continue;
    }

    break;
  }
}

variables* variables::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class variables (*this, f, c);
}

variables::
~variables ()
{
}

// vertices
//

vertices::
vertices ()
: ::xml_schema::type (),
  vertex_ (::xml_schema::flags (), this)
{
}

vertices::
vertices (const vertices& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertex_ (x.vertex_, f, this)
{
}

vertices::
vertices (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertex_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void vertices::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertex
    //
    if (n.name () == "vertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertex_type > r (
        vertex_traits::create (i, f, this));

      this->vertex_.push_back (r);
      continue;
    }

    break;
  }
}

vertices* vertices::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vertices (*this, f, c);
}

vertices::
~vertices ()
{
}

// elements
//

elements::
elements ()
: ::xml_schema::type (),
  quad_ (::xml_schema::flags (), this),
  triangle_ (::xml_schema::flags (), this)
{
}

elements::
elements (const elements& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  quad_ (x.quad_, f, this),
  triangle_ (x.triangle_, f, this)
{
}

elements::
elements (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  quad_ (f, this),
  triangle_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void elements::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // quad
    //
    if (n.name () == "quad" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< quad_type > r (
        quad_traits::create (i, f, this));

      this->quad_.push_back (r);
      continue;
    }

    // triangle
    //
    if (n.name () == "triangle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< triangle_type > r (
        triangle_traits::create (i, f, this));

      this->triangle_.push_back (r);
      continue;
    }

    break;
  }
}

elements* elements::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class elements (*this, f, c);
}

elements::
~elements ()
{
}

// boundaries
//

boundaries::
boundaries ()
: ::xml_schema::type (),
  boundary_edge_ (::xml_schema::flags (), this)
{
}

boundaries::
boundaries (const boundaries& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundary_edge_ (x.boundary_edge_, f, this)
{
}

boundaries::
boundaries (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundary_edge_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void boundaries::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundary_edge
    //
    if (n.name () == "boundary_edge" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< boundary_edge_type > r (
        boundary_edge_traits::create (i, f, this));

      this->boundary_edge_.push_back (r);
      continue;
    }

    break;
  }
}

boundaries* boundaries::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaries (*this, f, c);
}

boundaries::
~boundaries ()
{
}

// curves
//

curves::
curves ()
: ::xml_schema::type (),
  curve_ (::xml_schema::flags (), this)
{
}

curves::
curves (const curves& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  curve_ (x.curve_, f, this)
{
}

curves::
curves (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  curve_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void curves::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // curve
    //
    if (n.name () == "curve" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< curve_type > r (
        curve_traits::create (i, f, this));

      this->curve_.push_back (r);
      continue;
    }

    break;
  }
}

curves* curves::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class curves (*this, f, c);
}

curves::
~curves ()
{
}

// variable
//

variable::
variable (const name_type& name,
          const value_type& value)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this),
  value_ (value, ::xml_schema::flags (), this)
{
}

variable::
variable (const variable& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  value_ (x.value_, f, this)
{
}

variable::
variable (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void variable::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

variable* variable::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class variable (*this, f, c);
}

variable::
~variable ()
{
}

// vertex
//

vertex::
vertex (const x_type& x,
        const y_type& y)
: ::xml_schema::type (),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this)
{
}

vertex::
vertex (const vertex& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this)
{
}

vertex::
vertex (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (f, this),
  y_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void vertex::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }
}

vertex* vertex::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vertex (*this, f, c);
}

vertex::
~vertex ()
{
}

// quad
//

quad::
quad (const vertices_type& vertices,
      const marker_type& marker)
: ::xml_schema::type (),
  vertices_ (vertices, ::xml_schema::flags (), this),
  marker_ (marker, ::xml_schema::flags (), this),
  empty_ (::xml_schema::flags (), this)
{
}

quad::
quad (::std::auto_ptr< vertices_type >& vertices,
      const marker_type& marker)
: ::xml_schema::type (),
  vertices_ (vertices, ::xml_schema::flags (), this),
  marker_ (marker, ::xml_schema::flags (), this),
  empty_ (::xml_schema::flags (), this)
{
}

quad::
quad (const quad& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertices_ (x.vertices_, f, this),
  marker_ (x.marker_, f, this),
  empty_ (x.empty_, f, this)
{
}

quad::
quad (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertices_ (f, this),
  marker_ (f, this),
  empty_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void quad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertices
    //
    if (n.name () == "vertices" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertices_type > r (
        vertices_traits::create (i, f, this));

      if (!vertices_.present ())
      {
        this->vertices_.set (r);
        continue;
      }
    }

    // marker
    //
    if (n.name () == "marker" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marker_type > r (
        marker_traits::create (i, f, this));

      if (!marker_.present ())
      {
        this->marker_.set (r);
        continue;
      }
    }

    break;
  }

  if (!vertices_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vertices",
      "");
  }

  if (!marker_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "marker",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "empty" && n.namespace_ ().empty ())
    {
      this->empty_.set (empty_traits::create (i, f, this));
      continue;
    }
  }
}

quad* quad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class quad (*this, f, c);
}

quad::
~quad ()
{
}

// triangle
//

triangle::
triangle (const vertices_type& vertices,
          const marker_type& marker)
: ::xml_schema::type (),
  vertices_ (vertices, ::xml_schema::flags (), this),
  marker_ (marker, ::xml_schema::flags (), this),
  empty_ (::xml_schema::flags (), this)
{
}

triangle::
triangle (::std::auto_ptr< vertices_type >& vertices,
          const marker_type& marker)
: ::xml_schema::type (),
  vertices_ (vertices, ::xml_schema::flags (), this),
  marker_ (marker, ::xml_schema::flags (), this),
  empty_ (::xml_schema::flags (), this)
{
}

triangle::
triangle (const triangle& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertices_ (x.vertices_, f, this),
  marker_ (x.marker_, f, this),
  empty_ (x.empty_, f, this)
{
}

triangle::
triangle (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertices_ (f, this),
  marker_ (f, this),
  empty_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void triangle::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertices
    //
    if (n.name () == "vertices" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertices_type > r (
        vertices_traits::create (i, f, this));

      if (!vertices_.present ())
      {
        this->vertices_.set (r);
        continue;
      }
    }

    // marker
    //
    if (n.name () == "marker" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marker_type > r (
        marker_traits::create (i, f, this));

      if (!marker_.present ())
      {
        this->marker_.set (r);
        continue;
      }
    }

    break;
  }

  if (!vertices_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vertices",
      "");
  }

  if (!marker_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "marker",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "empty" && n.namespace_ ().empty ())
    {
      this->empty_.set (empty_traits::create (i, f, this));
      continue;
    }
  }
}

triangle* triangle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class triangle (*this, f, c);
}

triangle::
~triangle ()
{
}

// boundary_edge
//

boundary_edge::
boundary_edge (const marker_type& marker)
: ::xml_schema::type (),
  vertex_ (::xml_schema::flags (), this),
  marker_ (marker, ::xml_schema::flags (), this)
{
}

boundary_edge::
boundary_edge (const boundary_edge& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertex_ (x.vertex_, f, this),
  marker_ (x.marker_, f, this)
{
}

boundary_edge::
boundary_edge (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertex_ (f, this),
  marker_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void boundary_edge::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertex
    //
    if (n.name () == "vertex" && n.namespace_ ().empty ())
    {
      this->vertex_.push_back (vertex_traits::create (i, f, this));
      continue;
    }

    // marker
    //
    if (n.name () == "marker" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marker_type > r (
        marker_traits::create (i, f, this));

      if (!marker_.present ())
      {
        this->marker_.set (r);
        continue;
      }
    }

    break;
  }

  if (!marker_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "marker",
      "");
  }
}

boundary_edge* boundary_edge::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_edge (*this, f, c);
}

boundary_edge::
~boundary_edge ()
{
}

// curve
//

curve::
curve (const angle_type& angle)
: ::xml_schema::type (),
  vertex_ (::xml_schema::flags (), this),
  angle_ (angle, ::xml_schema::flags (), this)
{
}

curve::
curve (const curve& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertex_ (x.vertex_, f, this),
  angle_ (x.angle_, f, this)
{
}

curve::
curve (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertex_ (f, this),
  angle_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void curve::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertex
    //
    if (n.name () == "vertex" && n.namespace_ ().empty ())
    {
      this->vertex_.push_back (vertex_traits::create (i, f, this));
      continue;
    }

    // angle
    //
    if (n.name () == "angle" && n.namespace_ ().empty ())
    {
      if (!angle_.present ())
      {
        this->angle_.set (angle_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!angle_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "angle",
      "");
  }
}

curve* curve::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class curve (*this, f, c);
}

curve::
~curve ()
{
}

// vertices1
//

vertices1::
vertices1 ()
: ::xml_schema::type (),
  vertex_ (::xml_schema::flags (), this)
{
}

vertices1::
vertices1 (const vertices1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertex_ (x.vertex_, f, this)
{
}

vertices1::
vertices1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertex_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void vertices1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertex
    //
    if (n.name () == "vertex" && n.namespace_ ().empty ())
    {
      this->vertex_.push_back (vertex_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

vertices1* vertices1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vertices1 (*this, f, c);
}

vertices1::
~vertices1 ()
{
}

// vertices2
//

vertices2::
vertices2 ()
: ::xml_schema::type (),
  vertex_ (::xml_schema::flags (), this)
{
}

vertices2::
vertices2 (const vertices2& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  vertex_ (x.vertex_, f, this)
{
}

vertices2::
vertices2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  vertex_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void vertices2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // vertex
    //
    if (n.name () == "vertex" && n.namespace_ ().empty ())
    {
      this->vertex_.push_back (vertex_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

vertices2* vertices2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vertices2 (*this, f, c);
}

vertices2::
~vertices2 ()
{
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, const mesh_h2d& i)
{
  o << ::std::endl << "variables: " << i.variables ();
  o << ::std::endl << "vertices: " << i.vertices ();
  o << ::std::endl << "elements: " << i.elements ();
  o << ::std::endl << "boundaries: " << i.boundaries ();
  o << ::std::endl << "curves: " << i.curves ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const variables& i)
{
  for (variables::variable_const_iterator
       b (i.variable ().begin ()), e (i.variable ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "variable: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const vertices& i)
{
  for (vertices::vertex_const_iterator
       b (i.vertex ().begin ()), e (i.vertex ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "vertex: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const elements& i)
{
  for (elements::quad_const_iterator
       b (i.quad ().begin ()), e (i.quad ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "quad: " << *b;
  }

  for (elements::triangle_const_iterator
       b (i.triangle ().begin ()), e (i.triangle ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "triangle: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const boundaries& i)
{
  for (boundaries::boundary_edge_const_iterator
       b (i.boundary_edge ().begin ()), e (i.boundary_edge ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "boundary_edge: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const curves& i)
{
  for (curves::curve_const_iterator
       b (i.curve ().begin ()), e (i.curve ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "curve: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const variable& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "value: " << i.value ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const vertex& i)
{
  o << ::std::endl << "x: " << i.x ();
  o << ::std::endl << "y: " << i.y ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const quad& i)
{
  o << ::std::endl << "vertices: " << i.vertices ();
  o << ::std::endl << "marker: " << i.marker ();
  if (i.empty ())
  {
    o << ::std::endl << "empty: " << *i.empty ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const triangle& i)
{
  o << ::std::endl << "vertices: " << i.vertices ();
  o << ::std::endl << "marker: " << i.marker ();
  if (i.empty ())
  {
    o << ::std::endl << "empty: " << *i.empty ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const boundary_edge& i)
{
  for (boundary_edge::vertex_const_iterator
       b (i.vertex ().begin ()), e (i.vertex ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "vertex: " << *b;
  }

  o << ::std::endl << "marker: " << i.marker ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const curve& i)
{
  for (curve::vertex_const_iterator
       b (i.vertex ().begin ()), e (i.vertex ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "vertex: " << *b;
  }

  o << ::std::endl << "angle: " << i.angle ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const vertices1& i)
{
  for (vertices1::vertex_const_iterator
       b (i.vertex ().begin ()), e (i.vertex ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "vertex: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const vertices2& i)
{
  for (vertices2::vertex_const_iterator
       b (i.vertex ().begin ()), e (i.vertex ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "vertex: " << *b;
  }

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::mesh_h2d > r (
    ::mesh_h2d_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::mesh_h2d > r (
    ::mesh_h2d_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::mesh_h2d > r (
    ::mesh_h2d_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::mesh_h2d_ (isrc, f, p);
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::mesh_h2d_ (isrc, h, f, p);
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::mesh_h2d_ (isrc, h, f, p);
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::mesh_h2d_ (isrc, f, p);
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::mesh_h2d_ (isrc, h, f, p);
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::mesh_h2d_ (isrc, h, f, p);
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::mesh_h2d > r (
    ::mesh_h2d_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::mesh_h2d > r (
    ::mesh_h2d_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::mesh_h2d > r (
    ::mesh_h2d_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::mesh_h2d > r (
      ::mesh_h2d_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "mesh_h2d" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::mesh_h2d > r (
      ::xsd::cxx::tree::traits< ::mesh_h2d, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "mesh_h2d",
    "");
}

::std::auto_ptr< ::mesh_h2d >
mesh_h2d_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "mesh_h2d" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::mesh_h2d > r (
      ::xsd::cxx::tree::traits< ::mesh_h2d, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "mesh_h2d",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

